{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"source/assets/blogImg/left-arrow.png","path":"assets/blogImg/left-arrow.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/lufei.jpg","path":"assets/blogImg/lufei.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/right-arrow.png","path":"assets/blogImg/right-arrow.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/mulu.png","path":"assets/blogImg/mulu.png","modified":1,"renderable":0},{"_id":"source/assets/img/blogFile.png","path":"assets/img/blogFile.png","modified":1,"renderable":0},{"_id":"source/assets/img/GC.png","path":"assets/img/GC.png","modified":1,"renderable":0},{"_id":"source/assets/img/ali.png","path":"assets/img/ali.png","modified":1,"renderable":0},{"_id":"source/assets/img/childClassInit.png","path":"assets/img/childClassInit.png","modified":1,"renderable":0},{"_id":"source/assets/img/classInit.png","path":"assets/img/classInit.png","modified":1,"renderable":0},{"_id":"source/assets/img/classLoader.png","path":"assets/img/classLoader.png","modified":1,"renderable":0},{"_id":"source/assets/img/cnpmInstall1.png","path":"assets/img/cnpmInstall1.png","modified":1,"renderable":0},{"_id":"source/assets/img/construction.png","path":"assets/img/construction.png","modified":1,"renderable":0},{"_id":"source/assets/img/cnpmInstall2.png","path":"assets/img/cnpmInstall2.png","modified":1,"renderable":0},{"_id":"source/assets/img/collector.png","path":"assets/img/collector.png","modified":1,"renderable":0},{"_id":"source/assets/img/copySSH.png","path":"assets/img/copySSH.png","modified":1,"renderable":0},{"_id":"source/assets/img/copying.png","path":"assets/img/copying.png","modified":1,"renderable":0},{"_id":"source/assets/img/cpuArea.png","path":"assets/img/cpuArea.png","modified":1,"renderable":0},{"_id":"source/assets/img/doc.png","path":"assets/img/doc.png","modified":1,"renderable":0},{"_id":"source/assets/img/gitbash.png","path":"assets/img/gitbash.png","modified":1,"renderable":0},{"_id":"source/assets/img/hexoGit.png","path":"assets/img/hexoGit.png","modified":1,"renderable":0},{"_id":"source/assets/img/hexoVersion.png","path":"assets/img/hexoVersion.png","modified":1,"renderable":0},{"_id":"source/assets/img/initHexo.png","path":"assets/img/initHexo.png","modified":1,"renderable":0},{"_id":"source/assets/img/javaCompiler.png","path":"assets/img/javaCompiler.png","modified":1,"renderable":0},{"_id":"source/assets/img/linkRep.png","path":"assets/img/linkRep.png","modified":1,"renderable":0},{"_id":"source/assets/img/localPub.png","path":"assets/img/localPub.png","modified":1,"renderable":0},{"_id":"source/assets/img/listDifferent.png","path":"assets/img/listDifferent.png","modified":1,"renderable":0},{"_id":"source/assets/img/localStart.png","path":"assets/img/localStart.png","modified":1,"renderable":0},{"_id":"source/assets/img/mapDifferent.png","path":"assets/img/mapDifferent.png","modified":1,"renderable":0},{"_id":"source/assets/img/markSweep.png","path":"assets/img/markSweep.png","modified":1,"renderable":0},{"_id":"source/assets/img/newRep.png","path":"assets/img/newRep.png","modified":1,"renderable":0},{"_id":"source/assets/img/markCompact.png","path":"assets/img/markCompact.png","modified":1,"renderable":0},{"_id":"source/assets/img/npmInstall.png","path":"assets/img/npmInstall.png","modified":1,"renderable":0},{"_id":"source/assets/img/overrideResult.png","path":"assets/img/overrideResult.png","modified":1,"renderable":0},{"_id":"source/assets/img/setting.png","path":"assets/img/setting.png","modified":1,"renderable":0},{"_id":"source/assets/img/semaphoreResult.png","path":"assets/img/semaphoreResult.png","modified":1,"renderable":0},{"_id":"source/assets/img/sshFile.png","path":"assets/img/sshFile.png","modified":1,"renderable":0},{"_id":"source/assets/img/sshKeys.png","path":"assets/img/sshKeys.png","modified":1,"renderable":0},{"_id":"source/assets/img/string.png","path":"assets/img/string.png","modified":1,"renderable":0},{"_id":"source/assets/img/sshSuccess.png","path":"assets/img/sshSuccess.png","modified":1,"renderable":0},{"_id":"source/assets/img/threadPoolExcute.png","path":"assets/img/threadPoolExcute.png","modified":1,"renderable":0},{"_id":"source/assets/img/visit1.png","path":"assets/img/visit1.png","modified":1,"renderable":0},{"_id":"source/assets/img/visit2.png","path":"assets/img/visit2.png","modified":1,"renderable":0},{"_id":"source/assets/img/windr.png","path":"assets/img/windr.png","modified":1,"renderable":0},{"_id":"source/assets/img/yiliaConf.png","path":"assets/img/yiliaConf.png","modified":1,"renderable":0},{"_id":"source/assets/img/yiliaTheme.png","path":"assets/img/yiliaTheme.png","modified":1,"renderable":0},{"_id":"source/assets/img/young.png","path":"assets/img/young.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"source/assets/img/editConf.png","path":"assets/img/editConf.png","modified":1,"renderable":0},{"_id":"source/assets/img/editConf1.png","path":"assets/img/editConf1.png","modified":1,"renderable":0},{"_id":"source/assets/img/editConf2.png","path":"assets/img/editConf2.png","modified":1,"renderable":0},{"_id":"source/assets/img/weixin.png","path":"assets/img/weixin.png","modified":1,"renderable":0},{"_id":"source/assets/img/yilia.png","path":"assets/img/yilia.png","modified":1,"renderable":0},{"_id":"source/assets/img/yiliaIndex.png","path":"assets/img/yiliaIndex.png","modified":1,"renderable":0},{"_id":"source/assets/img/hexoIndex.png","path":"assets/img/hexoIndex.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1537176182282},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1537176182282},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1537176182282},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1537176182282},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1537176182298},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1537176182298},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1537176182298},{"_id":"themes/yilia/_config.yml","hash":"057a8294eb4001f175a05b1f7cda6ee36749f4ce","modified":1545059161780},{"_id":"themes/yilia/_config.yml.bak","hash":"f9fdee4228909687956c504351fc8c4a3b4815a0","modified":1537265099278},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1537176182407},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1537176182594},{"_id":"source/_posts/2018-09-18-github-hexo搭建个人免费博客.md","hash":"37c80135dbf908532f4b8d5493dc942439badab1","modified":1537323631338},{"_id":"source/_posts/2018-09-24-String类的底层实现和内存存储.md","hash":"9b5ca4543d2bf7cbc370aef05f488301acdab452","modified":1537802929593},{"_id":"source/_posts/2018-09-26-java内存分配解析.md","hash":"42d00e75cc62996ea543b89b8cd6bf3f5bea7989","modified":1537977125276},{"_id":"source/_posts/2018-09-28-java-GC垃圾回收机制浅析.md","hash":"abb22ae1af7c129892e296e930e3d30db8510aca","modified":1538150073523},{"_id":"source/_posts/2018-10-11-java类的创建过程解析.md","hash":"4025624a08933bbbc53fc0871258bc9496feaa9d","modified":1539273130371},{"_id":"source/_posts/2018-10-12-重载和重写的区别解析.md","hash":"63e32f268ef02bd99f8868875917c604f71f24fa","modified":1539358782284},{"_id":"source/_posts/2018-10-15-markdown基本语法.md","hash":"15f82d39841cd87266afe860196d34a361f30d43","modified":1542553191125},{"_id":"source/_posts/2018-10-30-ArrayList和LinkedList的区别比较.md","hash":"d2b66e1be50e345a58bd95892935004df8e7566e","modified":1540914679072},{"_id":"source/_posts/2018-11-04-HashMap和Hashtable的区别比较.md","hash":"5318bdca412151106fb76e53b01c4a149c13f1c7","modified":1541342447444},{"_id":"source/_posts/2018-11-14-java线程池的使用与区别解析.md","hash":"5f6daa549bc20ce61b4cce37bf0d7b70b056e15e","modified":1542378828795},{"_id":"source/_posts/2018-11-16-Semaphore源码解析.md","hash":"c58bf6e9a68ff6448b7022e3abccc27fb6a78499","modified":1542383448939},{"_id":"source/_posts/hello-world.md","hash":"c956b21471bf3d08beec4d9acc40aeeb7646572d","modified":1537265417072},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1537176182298},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1537176182298},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1537176182314},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1537176182314},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1537176182314},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1537176182314},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1537176182314},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1537176182392},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1537176182392},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1537176182407},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1537176182407},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1537176182407},{"_id":"themes/yilia/layout/layout.ejs","hash":"4b27a491b33de4cedd7bb49a092624350881cb03","modified":1542558611792},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1537176182407},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"9dccd41c80fb414bbc2229c7c40fd21c7fd22f3d","modified":1542635608255},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1537176182594},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1537176182548},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537176182392},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537176182563},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537176182563},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537176182563},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1537176182594},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1537176182594},{"_id":"source/assets/blogImg/left-arrow.png","hash":"96122ffa89e7bff0359e6e4d172e78c86ab33b79","modified":1542558164978},{"_id":"source/assets/blogImg/lufei.jpg","hash":"77061aed300da8d0ae35fc943496c75200de1ef8","modified":1537178002260},{"_id":"source/assets/blogImg/right-arrow.png","hash":"2e0cafef4d8a45ab70c58da101e25c9dc2f06ede","modified":1542558273104},{"_id":"source/assets/blogImg/mulu.png","hash":"861a8430d3cfe7a735b845f066df1046c11cb543","modified":1542559507160},{"_id":"source/assets/img/blogFile.png","hash":"ea949ebef63b826ebc6f3391244000be94914358","modified":1537256219762},{"_id":"source/assets/img/GC.png","hash":"b20bdf2e941819e3aa520216ae0bbb80bdda365c","modified":1538131197569},{"_id":"source/assets/img/ali.png","hash":"326c0ec97b9dfba5e2af1babb6330607ccec6c43","modified":1537191726315},{"_id":"source/assets/img/childClassInit.png","hash":"009b2bdae3414f00915af5a8b2014ea2ae804da5","modified":1539272649148},{"_id":"source/assets/img/classInit.png","hash":"ea35255e8c0992410c678c56a2587c0161d1ccd5","modified":1539270983398},{"_id":"source/assets/img/classLoader.png","hash":"c2be2c0f2ef50bed96e3ea96ab08a52605c477f7","modified":1537954369074},{"_id":"source/assets/img/cnpmInstall1.png","hash":"c40663dff1813bce5a5e851b2b99bbe33f65e936","modified":1537255597283},{"_id":"source/assets/img/construction.png","hash":"b07e3ed995d0f59bdcc3795636611be116e51593","modified":1537258404629},{"_id":"source/assets/img/cnpmInstall2.png","hash":"d17b6f7c441cbd5441ff9d2d0f83dfe8d1b117e9","modified":1537255714970},{"_id":"source/assets/img/collector.png","hash":"f4ea242e75f7fb8c88dbd5c002b57102556f3e1d","modified":1538150025623},{"_id":"source/assets/img/copySSH.png","hash":"990f5599a5571b9257455919d3c41e403dced44d","modified":1537263121727},{"_id":"source/assets/img/copying.png","hash":"c2823ab6d5aa4bc74491e976fbd0b9d4fa9dcbf8","modified":1538146753360},{"_id":"source/assets/img/cpuArea.png","hash":"2848500f8b08c4e3f5b44b58961b802aa56100f8","modified":1537973731922},{"_id":"source/assets/img/doc.png","hash":"bbb41c590d601f0bdc3ab524924bc42227dd0125","modified":1537254639713},{"_id":"source/assets/img/gitbash.png","hash":"353a383a8bea09a1c2735026bd6a73197c343cd6","modified":1537253699611},{"_id":"source/assets/img/hexoGit.png","hash":"383b64e1abdcaaf4d6e1d336c104b6a78e204ffe","modified":1537262361357},{"_id":"source/assets/img/hexoVersion.png","hash":"7df53d511d17880b77a5aba781013eb210c85dfd","modified":1537255993276},{"_id":"source/assets/img/initHexo.png","hash":"b6bf3d404db3ba9ace440fd3319f64d29538afa8","modified":1537258287044},{"_id":"source/assets/img/javaCompiler.png","hash":"1853a609f5b259b6e8e4c7a5bef2ffba90dbd19f","modified":1537952812826},{"_id":"source/assets/img/linkRep.png","hash":"47194939010a4a42ba8b6406e46c12bc9b550eda","modified":1537262077196},{"_id":"source/assets/img/localPub.png","hash":"587e751e1677da290011700303870b29bc996563","modified":1537258760940},{"_id":"source/assets/img/listDifferent.png","hash":"ab56a4278cfdeab332525ff169c4315967874cfe","modified":1540911798734},{"_id":"source/assets/img/localStart.png","hash":"e17257692c2f6bb67d7e97880217c36388c6ddd1","modified":1537258825335},{"_id":"source/assets/img/mapDifferent.png","hash":"cb28975b96556cfc64feecc17e80a608256987ae","modified":1541337309709},{"_id":"source/assets/img/markSweep.png","hash":"8ad1a1fe9fc4e533dd402199e06cc22775f85fd7","modified":1538146240750},{"_id":"source/assets/img/newRep.png","hash":"61efac4e5050a31f43b69eba5ed90c31a4211d90","modified":1537261740571},{"_id":"source/assets/img/markCompact.png","hash":"c75488d01e7eaaf385bc2c97a483c9ece0a8e877","modified":1538147067345},{"_id":"source/assets/img/npmInstall.png","hash":"8d7a0aa4b539e2b1a9519f4da23adb90783545f1","modified":1537255310826},{"_id":"source/assets/img/overrideResult.png","hash":"1d5d1df74e6a550b1d3a39ea18be68a9cfb946b4","modified":1539356699442},{"_id":"source/assets/img/setting.png","hash":"184f45a7444a386c2ae49e0dad7dd70c837366f2","modified":1537262840042},{"_id":"source/assets/img/semaphoreResult.png","hash":"94c95ed5889b74a522631a4f731c4b26186fd089","modified":1542379940486},{"_id":"source/assets/img/sshFile.png","hash":"3a34f3ed26757b8d55507f771fc2e4af6f6d19b5","modified":1537262684192},{"_id":"source/assets/img/sshKeys.png","hash":"dd19c584b6f80570bf988444d076552849bb8efc","modified":1537262954856},{"_id":"source/assets/img/string.png","hash":"fc7ad555a6c3acd0b3fe51648dd42089018aed20","modified":1537801955387},{"_id":"source/assets/img/sshSuccess.png","hash":"534b80ab8c448d233b95710bf300989c162fc91f","modified":1537263283825},{"_id":"source/assets/img/threadPoolExcute.png","hash":"1aea126ed4978fd4b390c736bd4863e17b143d02","modified":1542209609735},{"_id":"source/assets/img/visit1.png","hash":"dfe6c1992b03adec08c687cbf1c5082fbebb722b","modified":1537977625008},{"_id":"source/assets/img/visit2.png","hash":"2060f8461a9532daca64a14be205e089b5be61a7","modified":1537977449033},{"_id":"source/assets/img/windr.png","hash":"9085c13700048fa59de1a93eedc48f613af145b3","modified":1537254617218},{"_id":"source/assets/img/yiliaConf.png","hash":"e8aef95eaf7be034b6451246a59c87d0ac8d05c3","modified":1537261171063},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1537176182423},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1537176182329},{"_id":"source/assets/img/yiliaTheme.png","hash":"a2e36c3c686f8f58a8614c896894fc1b331e58f9","modified":1537260456229},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1537176182329},{"_id":"source/assets/img/young.png","hash":"1d04d1bf011f4d4e4624796d9974ab5eeb549580","modified":1538143229586},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1537176182329},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1537176182345},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"e50db2c439a0d65b85e1396d6750ee7a88c6fde0","modified":1542546899165},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1537176182329},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1537176182345},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1537176182329},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"db76ac2cfe1d4824c571c46fc31cd4f4489f1dc6","modified":1542592625273},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1537176182345},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1537176182345},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1537176182360},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1537176182345},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1537176182360},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1537176182392},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1537176182563},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1537176182579},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1537176182579},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1537176182392},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1537176182579},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1537176182563},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1537176182579},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1537176182423},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1537176182423},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1537176182423},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1537176182423},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1537176182438},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1537176182423},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1537176182438},{"_id":"themes/yilia/source-src/css/article.scss","hash":"8984516338bf222129cfb0c627e2ce51a954447f","modified":1542549380170},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1537176182470},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1537176182470},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1537176182454},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1537176182485},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1537176182501},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1537176182485},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1537176182501},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1537176182485},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1537176182501},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1537176182501},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1537176182501},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1537176182501},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1537176182516},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1537176182516},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1537176182516},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1537176182516},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1537176182516},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1537176182532},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1537176182532},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1537176182532},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1537176182532},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1537176182532},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1537176182532},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1537176182548},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1537176182548},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1537176182548},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1537176182548},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1537176182438},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1537176182548},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1537176182548},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1537176182516},{"_id":"source/assets/img/editConf.png","hash":"21605d785c9cf47d4920fe27d22a2de4194a678c","modified":1537258528823},{"_id":"source/assets/img/editConf1.png","hash":"59467e20b430a52e7b56eeeb065911a1a43a8e1a","modified":1537260698329},{"_id":"source/assets/img/editConf2.png","hash":"ff8e88d77c8bacd156475d4944cccb52b1e56afb","modified":1537261039311},{"_id":"source/assets/img/weixin.png","hash":"871477ee01667f6815e55f8d4ac52994bce32aee","modified":1537191799866},{"_id":"source/assets/img/yilia.png","hash":"570abe9e4abaea80942786b0c27937136cdb524d","modified":1537260518970},{"_id":"source/assets/img/yiliaIndex.png","hash":"c604dbbfbe36ace612d9dd6761f9e89b10f5e8ed","modified":1537260891579},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"642245643c7b846f36122a2f4204615fd8157fdf","modified":1542635269950},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537176182454},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537176182470},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537176182470},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1537176182360},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1537176182360},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1537176182360},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1537176182376},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1537176182376},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1537176182360},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1537176182376},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1537176182376},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1537176182376},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1537176182376},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1537176182454},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1537176182454},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1537176182454},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1537176182454},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1537176182485},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1537176182438},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1537176182485},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1537176182485},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1537176182470},{"_id":"source/assets/img/hexoIndex.png","hash":"45759c9bac05c8874dcdcc2d41eabd4dffc6ebdd","modified":1537259358993},{"_id":"public/content.json","hash":"75dcf492315498e97114e4e406500f2702f213fa","modified":1545061072846},{"_id":"public/2018/11/16/Semaphore源码解析/index.html","hash":"c3518c1463fef919f7c604fa64e8a537a04228c8","modified":1545061073126},{"_id":"public/2018/11/14/java线程池的使用与区别解析/index.html","hash":"35c1cca186a9320c01a363f6ce2c0270fa940327","modified":1545061073126},{"_id":"public/2018/11/04/HashMap和Hashtable的区别比较/index.html","hash":"caeb9bba0ea7c18725a2b6f7bdc0ddd2fbfada42","modified":1545061073126},{"_id":"public/2018/10/30/ArrayList和LinkedList的区别比较/index.html","hash":"e85453b4ce17d40a9cdfc72f9574f0a12ff9c0c4","modified":1545061073127},{"_id":"public/2018/10/15/markdown基本语法/index.html","hash":"03959ff5a05598e9f70f4c2a5ae153155dd854f6","modified":1545061073127},{"_id":"public/2018/10/12/重载和重写的区别解析/index.html","hash":"481456ad6645d1797ef71ea2a087b087d1ec99cc","modified":1545061073127},{"_id":"public/2018/10/11/java类的创建过程解析/index.html","hash":"ba348ae9983fb1209c64d3eeaf309c46ea7f420a","modified":1545061073128},{"_id":"public/2018/09/28/java-GC垃圾回收机制浅析/index.html","hash":"a3725f96a1d7a783313bd56346da9d4e1df6eedd","modified":1545061073128},{"_id":"public/2018/09/26/java内存分配解析/index.html","hash":"48e0af838a0ba003e18c16f69bd028b8544dc995","modified":1545061073128},{"_id":"public/2018/09/24/String类的底层实现和内存存储/index.html","hash":"c93db4d33aba9f70a500a84dacb63f580cf640e9","modified":1545061073128},{"_id":"public/2018/09/18/github-hexo搭建个人免费博客/index.html","hash":"e688e92bb878e8d64313fb57795c781ed1762f3a","modified":1545061073128},{"_id":"public/2018/09/17/hello-world/index.html","hash":"f7936c10d02c0acd9558c516331a3d8805ab78ce","modified":1545061073128},{"_id":"public/archives/index.html","hash":"7394787e5ddee4c52e0cf3788d946404859ee7ca","modified":1545061073128},{"_id":"public/archives/2018/index.html","hash":"85c7ac997c34311c5716dae5ed26965427397170","modified":1545061073129},{"_id":"public/archives/2018/09/index.html","hash":"9e1918f1c7e035543bd6017b282d936b3f32148f","modified":1545061073129},{"_id":"public/archives/2018/10/index.html","hash":"b989d7c9f0d5a5f1be9a22f946e5f77fce56a626","modified":1545061073129},{"_id":"public/archives/2018/11/index.html","hash":"d862c1cadd8e5e6deaf595f3704a450ca51919ea","modified":1545061073129},{"_id":"public/categories/blog/index.html","hash":"8646c2455c3fbdaf0a8d72db16ee2c8c6080a56f","modified":1545061073129},{"_id":"public/index.html","hash":"1bff60823d219c26ed568d7ec5b15fb0fe73240b","modified":1545061073129},{"_id":"public/page/2/index.html","hash":"6d92f98d92ea7ca685870ebb8e038c826fe35fe1","modified":1545061073130},{"_id":"public/page/3/index.html","hash":"fcc963af2ddf8c4e6944b80f276ba67848913130","modified":1545061073131},{"_id":"public/tags/hexo/index.html","hash":"43bd88c3718c530899301f13462526e90a524766","modified":1545061073131},{"_id":"public/tags/blog/index.html","hash":"20b2d73be119486054b07368cef3e82b16c298b6","modified":1545061073131},{"_id":"public/tags/github/index.html","hash":"0465e0bc6d66309cb06008091798959da04d9fe1","modified":1545061073131},{"_id":"public/tags/java/index.html","hash":"79c8d62e23a4f3024841eded82c451508c850508","modified":1545061073131},{"_id":"public/tags/java/page/2/index.html","hash":"580a63c883386a1bd48a86e3950a064699d2efa1","modified":1545061073131},{"_id":"public/tags/创建过程/index.html","hash":"0cf4b95bfbccf96f1e38c4896d67ac9f7b1e768c","modified":1545061073131},{"_id":"public/tags/Overriding/index.html","hash":"a7f6115dfe8ac2ba8d569368563197efec4914b2","modified":1545061073131},{"_id":"public/tags/Overloading/index.html","hash":"7b58517702304ca191c16532457efa7edeaf00b4","modified":1545061073132},{"_id":"public/tags/markdown/index.html","hash":"2ad918ed28bbd41626598729f15951fc517b9486","modified":1545061073132},{"_id":"public/tags/basic/index.html","hash":"42f8d62d857c4110d0a4f4ae8134eba7c39ce61a","modified":1545061073132},{"_id":"public/tags/集合/index.html","hash":"6c61c1bd1d64fb3deffe57094b9744a1e6da492c","modified":1545061073132},{"_id":"public/tags/HashMap/index.html","hash":"b860e66afa3006b3aadb9a289a5a13d049a5c91f","modified":1545061073132},{"_id":"public/tags/Hashtable/index.html","hash":"878c016f5d1bd1cb43267690669755b9bfda0810","modified":1545061073132},{"_id":"public/tags/demo/index.html","hash":"a5738b6a7998dd044858fa6e306fb6206d833bf5","modified":1545061073132},{"_id":"public/tags/String/index.html","hash":"d7e26ff05ad7dce498e47eecc1f25dc97ffd0280","modified":1545061073133},{"_id":"public/tags/内存分配/index.html","hash":"a034913e8d133db419433adcf2c4a48bdda55f65","modified":1545061073133},{"_id":"public/tags/GC/index.html","hash":"35314d99913f946d7dc2eb405a72d6823388e179","modified":1545061073134},{"_id":"public/tags/ArrayList/index.html","hash":"fd2c2759833dfd80e533ca2d7292cc8a2ef8771c","modified":1545061073135},{"_id":"public/tags/LinkedList/index.html","hash":"6306628c43299b10ac2e6637e2e8ac9b9e6c0710","modified":1545061073135},{"_id":"public/tags/多线程/index.html","hash":"04b88d6bf4b109fe75e19b205fdb107b7993fb31","modified":1545061073135},{"_id":"public/tags/Semaphore/index.html","hash":"5e72642abbc05e1f22eece6c0caa78a38f363641","modified":1545061073135},{"_id":"public/tags/源码/index.html","hash":"d6eb0c6280bba2d03c14cff28e2aff86b6266b9f","modified":1545061073135},{"_id":"public/tags/线程池/index.html","hash":"44d09d482011cc65eab7b97cc7af1e2707ee55b7","modified":1545061073135},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545061073163},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545061073164},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545061073164},{"_id":"public/assets/blogImg/left-arrow.png","hash":"96122ffa89e7bff0359e6e4d172e78c86ab33b79","modified":1545061073175},{"_id":"public/assets/blogImg/lufei.jpg","hash":"77061aed300da8d0ae35fc943496c75200de1ef8","modified":1545061073175},{"_id":"public/assets/blogImg/right-arrow.png","hash":"2e0cafef4d8a45ab70c58da101e25c9dc2f06ede","modified":1545061073175},{"_id":"public/assets/blogImg/mulu.png","hash":"861a8430d3cfe7a735b845f066df1046c11cb543","modified":1545061073175},{"_id":"public/assets/img/blogFile.png","hash":"ea949ebef63b826ebc6f3391244000be94914358","modified":1545061073175},{"_id":"public/assets/img/GC.png","hash":"b20bdf2e941819e3aa520216ae0bbb80bdda365c","modified":1545061073175},{"_id":"public/assets/img/ali.png","hash":"326c0ec97b9dfba5e2af1babb6330607ccec6c43","modified":1545061073175},{"_id":"public/assets/img/childClassInit.png","hash":"009b2bdae3414f00915af5a8b2014ea2ae804da5","modified":1545061073175},{"_id":"public/assets/img/classInit.png","hash":"ea35255e8c0992410c678c56a2587c0161d1ccd5","modified":1545061073175},{"_id":"public/assets/img/classLoader.png","hash":"c2be2c0f2ef50bed96e3ea96ab08a52605c477f7","modified":1545061073175},{"_id":"public/assets/img/cnpmInstall1.png","hash":"c40663dff1813bce5a5e851b2b99bbe33f65e936","modified":1545061073175},{"_id":"public/assets/img/construction.png","hash":"b07e3ed995d0f59bdcc3795636611be116e51593","modified":1545061073175},{"_id":"public/assets/img/cnpmInstall2.png","hash":"d17b6f7c441cbd5441ff9d2d0f83dfe8d1b117e9","modified":1545061073175},{"_id":"public/assets/img/collector.png","hash":"f4ea242e75f7fb8c88dbd5c002b57102556f3e1d","modified":1545061073175},{"_id":"public/assets/img/doc.png","hash":"bbb41c590d601f0bdc3ab524924bc42227dd0125","modified":1545061073176},{"_id":"public/assets/img/gitbash.png","hash":"353a383a8bea09a1c2735026bd6a73197c343cd6","modified":1545061073176},{"_id":"public/assets/img/hexoGit.png","hash":"383b64e1abdcaaf4d6e1d336c104b6a78e204ffe","modified":1545061073176},{"_id":"public/assets/img/hexoVersion.png","hash":"7df53d511d17880b77a5aba781013eb210c85dfd","modified":1545061073176},{"_id":"public/assets/img/initHexo.png","hash":"b6bf3d404db3ba9ace440fd3319f64d29538afa8","modified":1545061073176},{"_id":"public/assets/img/javaCompiler.png","hash":"1853a609f5b259b6e8e4c7a5bef2ffba90dbd19f","modified":1545061073176},{"_id":"public/assets/img/linkRep.png","hash":"47194939010a4a42ba8b6406e46c12bc9b550eda","modified":1545061073176},{"_id":"public/assets/img/localPub.png","hash":"587e751e1677da290011700303870b29bc996563","modified":1545061073176},{"_id":"public/assets/img/listDifferent.png","hash":"ab56a4278cfdeab332525ff169c4315967874cfe","modified":1545061073176},{"_id":"public/assets/img/localStart.png","hash":"e17257692c2f6bb67d7e97880217c36388c6ddd1","modified":1545061073176},{"_id":"public/assets/img/mapDifferent.png","hash":"cb28975b96556cfc64feecc17e80a608256987ae","modified":1545061073176},{"_id":"public/assets/img/markSweep.png","hash":"8ad1a1fe9fc4e533dd402199e06cc22775f85fd7","modified":1545061073176},{"_id":"public/assets/img/newRep.png","hash":"61efac4e5050a31f43b69eba5ed90c31a4211d90","modified":1545061073177},{"_id":"public/assets/img/overrideResult.png","hash":"1d5d1df74e6a550b1d3a39ea18be68a9cfb946b4","modified":1545061073177},{"_id":"public/assets/img/npmInstall.png","hash":"8d7a0aa4b539e2b1a9519f4da23adb90783545f1","modified":1545061073177},{"_id":"public/assets/img/setting.png","hash":"184f45a7444a386c2ae49e0dad7dd70c837366f2","modified":1545061073177},{"_id":"public/assets/img/semaphoreResult.png","hash":"94c95ed5889b74a522631a4f731c4b26186fd089","modified":1545061073177},{"_id":"public/assets/img/sshKeys.png","hash":"dd19c584b6f80570bf988444d076552849bb8efc","modified":1545061073177},{"_id":"public/assets/img/sshSuccess.png","hash":"534b80ab8c448d233b95710bf300989c162fc91f","modified":1545061073177},{"_id":"public/assets/img/string.png","hash":"fc7ad555a6c3acd0b3fe51648dd42089018aed20","modified":1545061073177},{"_id":"public/assets/img/threadPoolExcute.png","hash":"1aea126ed4978fd4b390c736bd4863e17b143d02","modified":1545061073177},{"_id":"public/assets/img/visit1.png","hash":"dfe6c1992b03adec08c687cbf1c5082fbebb722b","modified":1545061073177},{"_id":"public/assets/img/visit2.png","hash":"2060f8461a9532daca64a14be205e089b5be61a7","modified":1545061073177},{"_id":"public/assets/img/yiliaConf.png","hash":"e8aef95eaf7be034b6451246a59c87d0ac8d05c3","modified":1545061073177},{"_id":"public/assets/img/windr.png","hash":"9085c13700048fa59de1a93eedc48f613af145b3","modified":1545061073178},{"_id":"public/assets/img/yiliaTheme.png","hash":"a2e36c3c686f8f58a8614c896894fc1b331e58f9","modified":1545061073178},{"_id":"public/assets/img/young.png","hash":"1d04d1bf011f4d4e4624796d9974ab5eeb549580","modified":1545061073178},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1545061073178},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1545061073178},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1545061073178},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1545061073178},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1545061073178},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1545061073178},{"_id":"public/assets/img/copySSH.png","hash":"990f5599a5571b9257455919d3c41e403dced44d","modified":1545061073190},{"_id":"public/assets/img/copying.png","hash":"c2823ab6d5aa4bc74491e976fbd0b9d4fa9dcbf8","modified":1545061073190},{"_id":"public/assets/img/cpuArea.png","hash":"2848500f8b08c4e3f5b44b58961b802aa56100f8","modified":1545061073190},{"_id":"public/assets/img/sshFile.png","hash":"3a34f3ed26757b8d55507f771fc2e4af6f6d19b5","modified":1545061073190},{"_id":"public/assets/img/editConf.png","hash":"21605d785c9cf47d4920fe27d22a2de4194a678c","modified":1545061073190},{"_id":"public/assets/img/editConf1.png","hash":"59467e20b430a52e7b56eeeb065911a1a43a8e1a","modified":1545061073190},{"_id":"public/assets/img/editConf2.png","hash":"ff8e88d77c8bacd156475d4944cccb52b1e56afb","modified":1545061073190},{"_id":"public/assets/img/weixin.png","hash":"871477ee01667f6815e55f8d4ac52994bce32aee","modified":1545061073190},{"_id":"public/assets/img/yilia.png","hash":"570abe9e4abaea80942786b0c27937136cdb524d","modified":1545061073191},{"_id":"public/assets/img/yiliaIndex.png","hash":"c604dbbfbe36ace612d9dd6761f9e89b10f5e8ed","modified":1545061073191},{"_id":"public/assets/img/markCompact.png","hash":"c75488d01e7eaaf385bc2c97a483c9ece0a8e877","modified":1545061073198},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1545061073227},{"_id":"public/main.0cf68a.css","hash":"9dccd41c80fb414bbc2229c7c40fd21c7fd22f3d","modified":1545061073253},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1545061073268},{"_id":"public/assets/img/hexoIndex.png","hash":"45759c9bac05c8874dcdcc2d41eabd4dffc6ebdd","modified":1545061073277},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1545061073281}],"Category":[{"name":"blog","_id":"cjpshgviq0009ogre8grsfoqy"}],"Data":[],"Page":[],"Post":[{"title":"github+hexo搭建个人免费博客","date":"2018-09-18T06:04:43.000Z","toc":true,"_content":"github作为全球最大的开源软件交流平台，除了能够在这里学习、交流、研究IT各个领域的最新技术与成果以外，其实还可以使用github pages服务搭建属于自己的个人免费博客。\n这种个人博客不依赖于后台服务，访问的都是静态资源，所以速度很快。\n\n### 准备工作\n* 有属于自己的个人github账号，没有的话可以去这里申请一下<https://github.com/join?source=header-home>\n* 安装了node.js,官网下载<http://nodejs.cn/>\n* 安装了npm，关于npm的介绍可以参考官网<https://www.npmjs.com.cn/>\n* 安装了git客户端，下载地址是<https://gitforwindows.org/>\n\n<!--more-->\n\n### 一、安装hexo\n###### 1.打开命令行窗口\n通过鼠标右键选择Git Bash Here,会弹出git的命令行窗口\n\n![git 命令行窗口](/assets/img/gitbash.png)\n\n或者 win + r 输入cmd，打开Windows自带的命令行窗口\n\n![wind + r](/assets/img/windr.png)\n\n![doc命令行窗口](/assets/img/doc.png)\n\n###### 2.使用npm命令安装hexo\n\n``` bash\n$ npm install -g hexo\n```\n![npm install hexo](/assets/img/npmInstall.png)\n\n由于国内网络问题肯能会安装失败，可以设置淘宝镜像使用cnpm命令安装\n``` bash\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n$ cnpm insatll -g hexo-cli\n$ cnpm install hexo --sava\n```\n\n![cnpm 设置](/assets/img/cnpmInstall1.png)\n\n![cnpm install hexo](/assets/img/cnpmInstall2.png)\n\n###### 3.验证hexo安装成功\n```bash\n$ hexo -v\n```\n![hexo version](/assets/img/hexoVersion.png)\n\n### 二、初始化Hexo\n###### 1.新建文件夹\n创建用于创建博客的文件夹，这里我用的blog的名字，你可以取其他的文件夹名\n![blog文件夹](/assets/img/blogFile.png)\n\n###### 2.输入hexo初始化命令\n```bash\n$ hexo init\n```\n![hexo init](/assets/img/initHexo.png)\n\n初始化完成时候的目录结构\n![hexo 初始目录结构](/assets/img/construction.png)\n\n###### 3.修改配置文件\n使用编辑器修改_config.yml配置文件，这里我使用的是editplus，文件保存编码选择UTF-8\n![编辑配置文件](/assets/img/editConf.png)\n\n###### 4.本地部署\n```bash\n$ hexo g\n```\n![本地部署](/assets/img/localPub.png)\n\n###### 5.本地启动测试\n```bash\n$ hexo s\n```\n![本地启动](/assets/img/localStart.png)\n\n浏览器访问<localhost:4000>\n![hexo首页](/assets/img/hexoIndex.png)\n\n如果无法打开首页，可能是端口被占用了，可以切换端口启动\n\n```bash\n$ hexo s -p 端口号\n```\n###### 6.切换主题\n如果默认主题不喜欢，可以去[官网](https://hexo.io/themes/)选择喜欢的主题进行修改\n这里我自己选择的是[hexo-theme-yilia](https://github.com/litten/hexo-theme-yilia),所以已这个主题为例\n\n```bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n![yilia主题](/assets/img/yiliaTheme.png)\n\n克隆后的文件都放在themes文件夹下，结构如图\n![yilia主题文件](/assets/img/yilia.png)\n\n需要将根目录下的_config.yml修改主题，如果有中文语言应该修改为zh-CN\n![修改主题](/assets/img/editConf1.png)\n\n![修改语言](/assets/img/editConf2.png)\n\n需要修改yilia文件夹下的配置文件，可以参照作者的[示例](https://github.com/litten/BlogBackup)修改\n![yilia主题配置](/assets/img/yiliaConf.png)\n\n重新部署启动后的主页是这样的\n![yilia主页](/assets/img/yiliaIndex.png)\n\n### 三、部署到github上\n###### 1.新建仓库\n登录github账号点击new repository，新建仓库\n\n![新建仓库](/assets/img/newRep.png)\n\n###### 2.关联仓库\n修改hexo根目录_config.yml配置文件，关联新建的仓库\n\n![关联仓库](/assets/img/linkRep.png)\n\n###### 3.安装hexo发布插件\n```bash\n$ npm install hexo-deployer-git --save\n```\n![安装hexo发布插件](/assets/img/hexoGit.png)\n\n###### 4.配置生成SSH key\nssh是本地仓库和你的远程仓库的管理密匙，右键打开git bash窗口输入命令\n```bash\n$ ssh-keygen -t rsa -C \"你的github注册邮件地址\"\n```\n连续3次回车，会在用户目录生成文件目录\n![ssh文件目录](/assets/img/sshFile.png)\n\n###### 4.github账号添加ssh\n登录github，选择setting->SSH and GPG keys -> new SSH key\n![seeting](/assets/img/setting.png)\n\n![sshKeys](/assets/img/sshKeys.png)\n\n![拷贝ssh](/assets/img/copySSH.png)\n\n在git bash中验证是否添加成功\n```bash\n$ ssh -T git@github.com\n```\n如图提示则表示验证成功\n\n![验证](/assets/img/sshSuccess.png)\n\n###### 5.设置用户名邮箱\n```bash\n$ git config --global user.name \"your name\"  \n$ git config --global user.email \"your_email@youremail.com\"\n```\n\n### 四、上传博客\n如果顺利到这一步，恭喜你马上就要成功了，只需要输入一下命令上传博客即可\n```bash\n$ hexo g \n$ hexo d\n```\n\n# 结束\n完成上面的所有步骤，属于你自己的免费博客就搭建成功了，你可以直接使用自己的访问地址访问自己发布的博客了，\n这是我的[博客](https://jordanhank.github.io/),欢迎你来访问，如果你觉得这篇博客对你有所帮助，可以点击下面的打赏，支持一下！","source":"_posts/2018-09-18-github-hexo搭建个人免费博客.md","raw":"---\ntitle: github+hexo搭建个人免费博客\ndate: 2018-09-18 14:04:43\ntoc: true\ntags:\n  - hexo\n  - blog\n  - github\n---\ngithub作为全球最大的开源软件交流平台，除了能够在这里学习、交流、研究IT各个领域的最新技术与成果以外，其实还可以使用github pages服务搭建属于自己的个人免费博客。\n这种个人博客不依赖于后台服务，访问的都是静态资源，所以速度很快。\n\n### 准备工作\n* 有属于自己的个人github账号，没有的话可以去这里申请一下<https://github.com/join?source=header-home>\n* 安装了node.js,官网下载<http://nodejs.cn/>\n* 安装了npm，关于npm的介绍可以参考官网<https://www.npmjs.com.cn/>\n* 安装了git客户端，下载地址是<https://gitforwindows.org/>\n\n<!--more-->\n\n### 一、安装hexo\n###### 1.打开命令行窗口\n通过鼠标右键选择Git Bash Here,会弹出git的命令行窗口\n\n![git 命令行窗口](/assets/img/gitbash.png)\n\n或者 win + r 输入cmd，打开Windows自带的命令行窗口\n\n![wind + r](/assets/img/windr.png)\n\n![doc命令行窗口](/assets/img/doc.png)\n\n###### 2.使用npm命令安装hexo\n\n``` bash\n$ npm install -g hexo\n```\n![npm install hexo](/assets/img/npmInstall.png)\n\n由于国内网络问题肯能会安装失败，可以设置淘宝镜像使用cnpm命令安装\n``` bash\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n$ cnpm insatll -g hexo-cli\n$ cnpm install hexo --sava\n```\n\n![cnpm 设置](/assets/img/cnpmInstall1.png)\n\n![cnpm install hexo](/assets/img/cnpmInstall2.png)\n\n###### 3.验证hexo安装成功\n```bash\n$ hexo -v\n```\n![hexo version](/assets/img/hexoVersion.png)\n\n### 二、初始化Hexo\n###### 1.新建文件夹\n创建用于创建博客的文件夹，这里我用的blog的名字，你可以取其他的文件夹名\n![blog文件夹](/assets/img/blogFile.png)\n\n###### 2.输入hexo初始化命令\n```bash\n$ hexo init\n```\n![hexo init](/assets/img/initHexo.png)\n\n初始化完成时候的目录结构\n![hexo 初始目录结构](/assets/img/construction.png)\n\n###### 3.修改配置文件\n使用编辑器修改_config.yml配置文件，这里我使用的是editplus，文件保存编码选择UTF-8\n![编辑配置文件](/assets/img/editConf.png)\n\n###### 4.本地部署\n```bash\n$ hexo g\n```\n![本地部署](/assets/img/localPub.png)\n\n###### 5.本地启动测试\n```bash\n$ hexo s\n```\n![本地启动](/assets/img/localStart.png)\n\n浏览器访问<localhost:4000>\n![hexo首页](/assets/img/hexoIndex.png)\n\n如果无法打开首页，可能是端口被占用了，可以切换端口启动\n\n```bash\n$ hexo s -p 端口号\n```\n###### 6.切换主题\n如果默认主题不喜欢，可以去[官网](https://hexo.io/themes/)选择喜欢的主题进行修改\n这里我自己选择的是[hexo-theme-yilia](https://github.com/litten/hexo-theme-yilia),所以已这个主题为例\n\n```bash\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n![yilia主题](/assets/img/yiliaTheme.png)\n\n克隆后的文件都放在themes文件夹下，结构如图\n![yilia主题文件](/assets/img/yilia.png)\n\n需要将根目录下的_config.yml修改主题，如果有中文语言应该修改为zh-CN\n![修改主题](/assets/img/editConf1.png)\n\n![修改语言](/assets/img/editConf2.png)\n\n需要修改yilia文件夹下的配置文件，可以参照作者的[示例](https://github.com/litten/BlogBackup)修改\n![yilia主题配置](/assets/img/yiliaConf.png)\n\n重新部署启动后的主页是这样的\n![yilia主页](/assets/img/yiliaIndex.png)\n\n### 三、部署到github上\n###### 1.新建仓库\n登录github账号点击new repository，新建仓库\n\n![新建仓库](/assets/img/newRep.png)\n\n###### 2.关联仓库\n修改hexo根目录_config.yml配置文件，关联新建的仓库\n\n![关联仓库](/assets/img/linkRep.png)\n\n###### 3.安装hexo发布插件\n```bash\n$ npm install hexo-deployer-git --save\n```\n![安装hexo发布插件](/assets/img/hexoGit.png)\n\n###### 4.配置生成SSH key\nssh是本地仓库和你的远程仓库的管理密匙，右键打开git bash窗口输入命令\n```bash\n$ ssh-keygen -t rsa -C \"你的github注册邮件地址\"\n```\n连续3次回车，会在用户目录生成文件目录\n![ssh文件目录](/assets/img/sshFile.png)\n\n###### 4.github账号添加ssh\n登录github，选择setting->SSH and GPG keys -> new SSH key\n![seeting](/assets/img/setting.png)\n\n![sshKeys](/assets/img/sshKeys.png)\n\n![拷贝ssh](/assets/img/copySSH.png)\n\n在git bash中验证是否添加成功\n```bash\n$ ssh -T git@github.com\n```\n如图提示则表示验证成功\n\n![验证](/assets/img/sshSuccess.png)\n\n###### 5.设置用户名邮箱\n```bash\n$ git config --global user.name \"your name\"  \n$ git config --global user.email \"your_email@youremail.com\"\n```\n\n### 四、上传博客\n如果顺利到这一步，恭喜你马上就要成功了，只需要输入一下命令上传博客即可\n```bash\n$ hexo g \n$ hexo d\n```\n\n# 结束\n完成上面的所有步骤，属于你自己的免费博客就搭建成功了，你可以直接使用自己的访问地址访问自己发布的博客了，\n这是我的[博客](https://jordanhank.github.io/),欢迎你来访问，如果你觉得这篇博客对你有所帮助，可以点击下面的打赏，支持一下！","slug":"github-hexo搭建个人免费博客","published":1,"updated":"2018-09-19T02:20:31.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvi00000ogre5v8y2j2f","content":"<p>github作为全球最大的开源软件交流平台，除了能够在这里学习、交流、研究IT各个领域的最新技术与成果以外，其实还可以使用github pages服务搭建属于自己的个人免费博客。<br>这种个人博客不依赖于后台服务，访问的都是静态资源，所以速度很快。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><ul>\n<li>有属于自己的个人github账号，没有的话可以去这里申请一下<a href=\"https://github.com/join?source=header-home\" target=\"_blank\" rel=\"noopener\">https://github.com/join?source=header-home</a></li>\n<li>安装了node.js,官网下载<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/</a></li>\n<li>安装了npm，关于npm的介绍可以参考官网<a href=\"https://www.npmjs.com.cn/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com.cn/</a></li>\n<li>安装了git客户端，下载地址是<a href=\"https://gitforwindows.org/\" target=\"_blank\" rel=\"noopener\">https://gitforwindows.org/</a></li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"一、安装hexo\"><a href=\"#一、安装hexo\" class=\"headerlink\" title=\"一、安装hexo\"></a>一、安装hexo</h3><h6 id=\"1-打开命令行窗口\"><a href=\"#1-打开命令行窗口\" class=\"headerlink\" title=\"1.打开命令行窗口\"></a>1.打开命令行窗口</h6><p>通过鼠标右键选择Git Bash Here,会弹出git的命令行窗口</p>\n<p><img src=\"/assets/img/gitbash.png\" alt=\"git 命令行窗口\"></p>\n<p>或者 win + r 输入cmd，打开Windows自带的命令行窗口</p>\n<p><img src=\"/assets/img/windr.png\" alt=\"wind + r\"></p>\n<p><img src=\"/assets/img/doc.png\" alt=\"doc命令行窗口\"></p>\n<h6 id=\"2-使用npm命令安装hexo\"><a href=\"#2-使用npm命令安装hexo\" class=\"headerlink\" title=\"2.使用npm命令安装hexo\"></a>2.使用npm命令安装hexo</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/npmInstall.png\" alt=\"npm install hexo\"></p>\n<p>由于国内网络问题肯能会安装失败，可以设置淘宝镜像使用cnpm命令安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class=\"line\">$ cnpm insatll -g hexo-cli</span><br><span class=\"line\">$ cnpm install hexo --sava</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/assets/img/cnpmInstall1.png\" alt=\"cnpm 设置\"></p>\n<p><img src=\"/assets/img/cnpmInstall2.png\" alt=\"cnpm install hexo\"></p>\n<h6 id=\"3-验证hexo安装成功\"><a href=\"#3-验证hexo安装成功\" class=\"headerlink\" title=\"3.验证hexo安装成功\"></a>3.验证hexo安装成功</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/hexoVersion.png\" alt=\"hexo version\"></p>\n<h3 id=\"二、初始化Hexo\"><a href=\"#二、初始化Hexo\" class=\"headerlink\" title=\"二、初始化Hexo\"></a>二、初始化Hexo</h3><h6 id=\"1-新建文件夹\"><a href=\"#1-新建文件夹\" class=\"headerlink\" title=\"1.新建文件夹\"></a>1.新建文件夹</h6><p>创建用于创建博客的文件夹，这里我用的blog的名字，你可以取其他的文件夹名<br><img src=\"/assets/img/blogFile.png\" alt=\"blog文件夹\"></p>\n<h6 id=\"2-输入hexo初始化命令\"><a href=\"#2-输入hexo初始化命令\" class=\"headerlink\" title=\"2.输入hexo初始化命令\"></a>2.输入hexo初始化命令</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/initHexo.png\" alt=\"hexo init\"></p>\n<p>初始化完成时候的目录结构<br><img src=\"/assets/img/construction.png\" alt=\"hexo 初始目录结构\"></p>\n<h6 id=\"3-修改配置文件\"><a href=\"#3-修改配置文件\" class=\"headerlink\" title=\"3.修改配置文件\"></a>3.修改配置文件</h6><p>使用编辑器修改_config.yml配置文件，这里我使用的是editplus，文件保存编码选择UTF-8<br><img src=\"/assets/img/editConf.png\" alt=\"编辑配置文件\"></p>\n<h6 id=\"4-本地部署\"><a href=\"#4-本地部署\" class=\"headerlink\" title=\"4.本地部署\"></a>4.本地部署</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/localPub.png\" alt=\"本地部署\"></p>\n<h6 id=\"5-本地启动测试\"><a href=\"#5-本地启动测试\" class=\"headerlink\" title=\"5.本地启动测试\"></a>5.本地启动测试</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/localStart.png\" alt=\"本地启动\"></p>\n<p>浏览器访问<a href=\"localhost:4000\" target=\"_blank\" rel=\"noopener\">localhost:4000</a><br><img src=\"/assets/img/hexoIndex.png\" alt=\"hexo首页\"></p>\n<p>如果无法打开首页，可能是端口被占用了，可以切换端口启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s -p 端口号</span><br></pre></td></tr></table></figure>\n<h6 id=\"6-切换主题\"><a href=\"#6-切换主题\" class=\"headerlink\" title=\"6.切换主题\"></a>6.切换主题</h6><p>如果默认主题不喜欢，可以去<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">官网</a>选择喜欢的主题进行修改<br>这里我自己选择的是<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"noopener\">hexo-theme-yilia</a>,所以已这个主题为例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/yiliaTheme.png\" alt=\"yilia主题\"></p>\n<p>克隆后的文件都放在themes文件夹下，结构如图<br><img src=\"/assets/img/yilia.png\" alt=\"yilia主题文件\"></p>\n<p>需要将根目录下的_config.yml修改主题，如果有中文语言应该修改为zh-CN<br><img src=\"/assets/img/editConf1.png\" alt=\"修改主题\"></p>\n<p><img src=\"/assets/img/editConf2.png\" alt=\"修改语言\"></p>\n<p>需要修改yilia文件夹下的配置文件，可以参照作者的<a href=\"https://github.com/litten/BlogBackup\" target=\"_blank\" rel=\"noopener\">示例</a>修改<br><img src=\"/assets/img/yiliaConf.png\" alt=\"yilia主题配置\"></p>\n<p>重新部署启动后的主页是这样的<br><img src=\"/assets/img/yiliaIndex.png\" alt=\"yilia主页\"></p>\n<h3 id=\"三、部署到github上\"><a href=\"#三、部署到github上\" class=\"headerlink\" title=\"三、部署到github上\"></a>三、部署到github上</h3><h6 id=\"1-新建仓库\"><a href=\"#1-新建仓库\" class=\"headerlink\" title=\"1.新建仓库\"></a>1.新建仓库</h6><p>登录github账号点击new repository，新建仓库</p>\n<p><img src=\"/assets/img/newRep.png\" alt=\"新建仓库\"></p>\n<h6 id=\"2-关联仓库\"><a href=\"#2-关联仓库\" class=\"headerlink\" title=\"2.关联仓库\"></a>2.关联仓库</h6><p>修改hexo根目录_config.yml配置文件，关联新建的仓库</p>\n<p><img src=\"/assets/img/linkRep.png\" alt=\"关联仓库\"></p>\n<h6 id=\"3-安装hexo发布插件\"><a href=\"#3-安装hexo发布插件\" class=\"headerlink\" title=\"3.安装hexo发布插件\"></a>3.安装hexo发布插件</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/hexoGit.png\" alt=\"安装hexo发布插件\"></p>\n<h6 id=\"4-配置生成SSH-key\"><a href=\"#4-配置生成SSH-key\" class=\"headerlink\" title=\"4.配置生成SSH key\"></a>4.配置生成SSH key</h6><p>ssh是本地仓库和你的远程仓库的管理密匙，右键打开git bash窗口输入命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"你的github注册邮件地址\"</span></span><br></pre></td></tr></table></figure></p>\n<p>连续3次回车，会在用户目录生成文件目录<br><img src=\"/assets/img/sshFile.png\" alt=\"ssh文件目录\"></p>\n<h6 id=\"4-github账号添加ssh\"><a href=\"#4-github账号添加ssh\" class=\"headerlink\" title=\"4.github账号添加ssh\"></a>4.github账号添加ssh</h6><p>登录github，选择setting-&gt;SSH and GPG keys -&gt; new SSH key<br><img src=\"/assets/img/setting.png\" alt=\"seeting\"></p>\n<p><img src=\"/assets/img/sshKeys.png\" alt=\"sshKeys\"></p>\n<p><img src=\"/assets/img/copySSH.png\" alt=\"拷贝ssh\"></p>\n<p>在git bash中验证是否添加成功<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>\n<p>如图提示则表示验证成功</p>\n<p><img src=\"/assets/img/sshSuccess.png\" alt=\"验证\"></p>\n<h6 id=\"5-设置用户名邮箱\"><a href=\"#5-设置用户名邮箱\" class=\"headerlink\" title=\"5.设置用户名邮箱\"></a>5.设置用户名邮箱</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"your name\"</span>  </span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"your_email@youremail.com\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"四、上传博客\"><a href=\"#四、上传博客\" class=\"headerlink\" title=\"四、上传博客\"></a>四、上传博客</h3><p>如果顺利到这一步，恭喜你马上就要成功了，只需要输入一下命令上传博客即可<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g </span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>完成上面的所有步骤，属于你自己的免费博客就搭建成功了，你可以直接使用自己的访问地址访问自己发布的博客了，<br>这是我的<a href=\"https://jordanhank.github.io/\" target=\"_blank\" rel=\"noopener\">博客</a>,欢迎你来访问，如果你觉得这篇博客对你有所帮助，可以点击下面的打赏，支持一下！</p>\n","site":{"data":{}},"excerpt":"<p>github作为全球最大的开源软件交流平台，除了能够在这里学习、交流、研究IT各个领域的最新技术与成果以外，其实还可以使用github pages服务搭建属于自己的个人免费博客。<br>这种个人博客不依赖于后台服务，访问的都是静态资源，所以速度很快。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><ul>\n<li>有属于自己的个人github账号，没有的话可以去这里申请一下<a href=\"https://github.com/join?source=header-home\" target=\"_blank\" rel=\"noopener\">https://github.com/join?source=header-home</a></li>\n<li>安装了node.js,官网下载<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/</a></li>\n<li>安装了npm，关于npm的介绍可以参考官网<a href=\"https://www.npmjs.com.cn/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com.cn/</a></li>\n<li>安装了git客户端，下载地址是<a href=\"https://gitforwindows.org/\" target=\"_blank\" rel=\"noopener\">https://gitforwindows.org/</a></li>\n</ul>","more":"<h3 id=\"一、安装hexo\"><a href=\"#一、安装hexo\" class=\"headerlink\" title=\"一、安装hexo\"></a>一、安装hexo</h3><h6 id=\"1-打开命令行窗口\"><a href=\"#1-打开命令行窗口\" class=\"headerlink\" title=\"1.打开命令行窗口\"></a>1.打开命令行窗口</h6><p>通过鼠标右键选择Git Bash Here,会弹出git的命令行窗口</p>\n<p><img src=\"/assets/img/gitbash.png\" alt=\"git 命令行窗口\"></p>\n<p>或者 win + r 输入cmd，打开Windows自带的命令行窗口</p>\n<p><img src=\"/assets/img/windr.png\" alt=\"wind + r\"></p>\n<p><img src=\"/assets/img/doc.png\" alt=\"doc命令行窗口\"></p>\n<h6 id=\"2-使用npm命令安装hexo\"><a href=\"#2-使用npm命令安装hexo\" class=\"headerlink\" title=\"2.使用npm命令安装hexo\"></a>2.使用npm命令安装hexo</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/npmInstall.png\" alt=\"npm install hexo\"></p>\n<p>由于国内网络问题肯能会安装失败，可以设置淘宝镜像使用cnpm命令安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class=\"line\">$ cnpm insatll -g hexo-cli</span><br><span class=\"line\">$ cnpm install hexo --sava</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/assets/img/cnpmInstall1.png\" alt=\"cnpm 设置\"></p>\n<p><img src=\"/assets/img/cnpmInstall2.png\" alt=\"cnpm install hexo\"></p>\n<h6 id=\"3-验证hexo安装成功\"><a href=\"#3-验证hexo安装成功\" class=\"headerlink\" title=\"3.验证hexo安装成功\"></a>3.验证hexo安装成功</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/hexoVersion.png\" alt=\"hexo version\"></p>\n<h3 id=\"二、初始化Hexo\"><a href=\"#二、初始化Hexo\" class=\"headerlink\" title=\"二、初始化Hexo\"></a>二、初始化Hexo</h3><h6 id=\"1-新建文件夹\"><a href=\"#1-新建文件夹\" class=\"headerlink\" title=\"1.新建文件夹\"></a>1.新建文件夹</h6><p>创建用于创建博客的文件夹，这里我用的blog的名字，你可以取其他的文件夹名<br><img src=\"/assets/img/blogFile.png\" alt=\"blog文件夹\"></p>\n<h6 id=\"2-输入hexo初始化命令\"><a href=\"#2-输入hexo初始化命令\" class=\"headerlink\" title=\"2.输入hexo初始化命令\"></a>2.输入hexo初始化命令</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/initHexo.png\" alt=\"hexo init\"></p>\n<p>初始化完成时候的目录结构<br><img src=\"/assets/img/construction.png\" alt=\"hexo 初始目录结构\"></p>\n<h6 id=\"3-修改配置文件\"><a href=\"#3-修改配置文件\" class=\"headerlink\" title=\"3.修改配置文件\"></a>3.修改配置文件</h6><p>使用编辑器修改_config.yml配置文件，这里我使用的是editplus，文件保存编码选择UTF-8<br><img src=\"/assets/img/editConf.png\" alt=\"编辑配置文件\"></p>\n<h6 id=\"4-本地部署\"><a href=\"#4-本地部署\" class=\"headerlink\" title=\"4.本地部署\"></a>4.本地部署</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/localPub.png\" alt=\"本地部署\"></p>\n<h6 id=\"5-本地启动测试\"><a href=\"#5-本地启动测试\" class=\"headerlink\" title=\"5.本地启动测试\"></a>5.本地启动测试</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/localStart.png\" alt=\"本地启动\"></p>\n<p>浏览器访问<a href=\"localhost:4000\" target=\"_blank\" rel=\"noopener\">localhost:4000</a><br><img src=\"/assets/img/hexoIndex.png\" alt=\"hexo首页\"></p>\n<p>如果无法打开首页，可能是端口被占用了，可以切换端口启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s -p 端口号</span><br></pre></td></tr></table></figure>\n<h6 id=\"6-切换主题\"><a href=\"#6-切换主题\" class=\"headerlink\" title=\"6.切换主题\"></a>6.切换主题</h6><p>如果默认主题不喜欢，可以去<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">官网</a>选择喜欢的主题进行修改<br>这里我自己选择的是<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"noopener\">hexo-theme-yilia</a>,所以已这个主题为例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/yiliaTheme.png\" alt=\"yilia主题\"></p>\n<p>克隆后的文件都放在themes文件夹下，结构如图<br><img src=\"/assets/img/yilia.png\" alt=\"yilia主题文件\"></p>\n<p>需要将根目录下的_config.yml修改主题，如果有中文语言应该修改为zh-CN<br><img src=\"/assets/img/editConf1.png\" alt=\"修改主题\"></p>\n<p><img src=\"/assets/img/editConf2.png\" alt=\"修改语言\"></p>\n<p>需要修改yilia文件夹下的配置文件，可以参照作者的<a href=\"https://github.com/litten/BlogBackup\" target=\"_blank\" rel=\"noopener\">示例</a>修改<br><img src=\"/assets/img/yiliaConf.png\" alt=\"yilia主题配置\"></p>\n<p>重新部署启动后的主页是这样的<br><img src=\"/assets/img/yiliaIndex.png\" alt=\"yilia主页\"></p>\n<h3 id=\"三、部署到github上\"><a href=\"#三、部署到github上\" class=\"headerlink\" title=\"三、部署到github上\"></a>三、部署到github上</h3><h6 id=\"1-新建仓库\"><a href=\"#1-新建仓库\" class=\"headerlink\" title=\"1.新建仓库\"></a>1.新建仓库</h6><p>登录github账号点击new repository，新建仓库</p>\n<p><img src=\"/assets/img/newRep.png\" alt=\"新建仓库\"></p>\n<h6 id=\"2-关联仓库\"><a href=\"#2-关联仓库\" class=\"headerlink\" title=\"2.关联仓库\"></a>2.关联仓库</h6><p>修改hexo根目录_config.yml配置文件，关联新建的仓库</p>\n<p><img src=\"/assets/img/linkRep.png\" alt=\"关联仓库\"></p>\n<h6 id=\"3-安装hexo发布插件\"><a href=\"#3-安装hexo发布插件\" class=\"headerlink\" title=\"3.安装hexo发布插件\"></a>3.安装hexo发布插件</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/img/hexoGit.png\" alt=\"安装hexo发布插件\"></p>\n<h6 id=\"4-配置生成SSH-key\"><a href=\"#4-配置生成SSH-key\" class=\"headerlink\" title=\"4.配置生成SSH key\"></a>4.配置生成SSH key</h6><p>ssh是本地仓库和你的远程仓库的管理密匙，右键打开git bash窗口输入命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"你的github注册邮件地址\"</span></span><br></pre></td></tr></table></figure></p>\n<p>连续3次回车，会在用户目录生成文件目录<br><img src=\"/assets/img/sshFile.png\" alt=\"ssh文件目录\"></p>\n<h6 id=\"4-github账号添加ssh\"><a href=\"#4-github账号添加ssh\" class=\"headerlink\" title=\"4.github账号添加ssh\"></a>4.github账号添加ssh</h6><p>登录github，选择setting-&gt;SSH and GPG keys -&gt; new SSH key<br><img src=\"/assets/img/setting.png\" alt=\"seeting\"></p>\n<p><img src=\"/assets/img/sshKeys.png\" alt=\"sshKeys\"></p>\n<p><img src=\"/assets/img/copySSH.png\" alt=\"拷贝ssh\"></p>\n<p>在git bash中验证是否添加成功<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>\n<p>如图提示则表示验证成功</p>\n<p><img src=\"/assets/img/sshSuccess.png\" alt=\"验证\"></p>\n<h6 id=\"5-设置用户名邮箱\"><a href=\"#5-设置用户名邮箱\" class=\"headerlink\" title=\"5.设置用户名邮箱\"></a>5.设置用户名邮箱</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"your name\"</span>  </span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"your_email@youremail.com\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"四、上传博客\"><a href=\"#四、上传博客\" class=\"headerlink\" title=\"四、上传博客\"></a>四、上传博客</h3><p>如果顺利到这一步，恭喜你马上就要成功了，只需要输入一下命令上传博客即可<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g </span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h1><p>完成上面的所有步骤，属于你自己的免费博客就搭建成功了，你可以直接使用自己的访问地址访问自己发布的博客了，<br>这是我的<a href=\"https://jordanhank.github.io/\" target=\"_blank\" rel=\"noopener\">博客</a>,欢迎你来访问，如果你觉得这篇博客对你有所帮助，可以点击下面的打赏，支持一下！</p>"},{"title":"java类的创建过程解析","date":"2018-10-11T14:26:50.000Z","toc":true,"_content":"### 类的构成\njava类由以下几种元素构成\n+ 属性\n + 静态属性：有关键字static修饰的属性\n + 常规属性：没有关键字static修饰\n+ 方法块\n + 静态方法块：有static修饰\n + 常规方法块：没有static修饰\n <!--more-->\n+ 构造函数\n + 默认无参构造函数\n + 有参构造函数\n+ 方法\n + 静态方法：有static修饰\n + 常规方法：没有static修饰\n\n### 类的初始化\n```\npublic class Test {\n\n    public static void main(String [] args) {\n        new TestClass();\n    }\n}\n\nclass TestClass {\n\n    //普通属性\n    private String field = getNormalField();\n\n    // 静态属性\n    private static String staticField = getStaticField();\n\n    // 普通方法块\n    {\n        System.out.println(field);\n        System.out.println(\"普通方法块初始化\");\n    }\n\n    //静态方法块\n    static {\n        System.out.println(staticField);\n        System.out.println(\"静态方法块初始化\");\n    }\n\n    //静态方法\n    public static String getStaticField() {\n        String staticField = \"Static\";\n        System.out.println(\"静态属性初始化\");\n        return staticField;\n    }\n\n    // 常规方法\n    public String getNormalField() {\n        String field = \"Normal\";\n        System.out.println(\"普通属性初始化\");\n        return field;\n    }\n\n    //无参默认构造函数\n    public TestClass() {\n        System.out.println(\"无参默认构造函数调用\");\n    }\n\n    //有参构造函数\n    public TestClass(String field) {\n        this.field = field;\n        System.out.println(\"有参构造函数调用\");\n    }\n}\n```\n执行结果为：\n![java类的初始化过程](/assets/img/classInit.png)\n\n所以java类的初始化加载顺序是：\n1.先加载静态属性和静态方法块\n2.加载常规属性和常规方法块\n3.加载静态方法和常规方法\n4.加载构造函数（构造函数使用哪个加载哪个）\n\n### 父子类加载\n子类可以继承父类的通用属性和行为，同时也可以添加自己的特有属性和行为\n```\npublic class ParentChild {\n\n    public static void main(String [] args) {\n        new Child();\n    }\n}\n\nclass Parent {\n\n    //普通属性\n    private String field = getNormalField();\n\n    // 静态属性\n    private static String staticField = getStaticField();\n\n    // 普通方法块\n    {\n        System.out.println(\"Parent==========\");\n        System.out.println(field);\n        System.out.println(\"Parent普通方法块初始化\");\n    }\n\n    //静态方法块\n    static {\n        System.out.println(\"Parent==========\");\n        System.out.println(staticField);\n        System.out.println(\"Parent静态方法块初始化\");\n    }\n\n    //静态方法\n    public static String getStaticField() {\n        String staticFiled = \"Static\";\n        System.out.println(\"Parent静态属性初始化\");\n        return staticFiled;\n    }\n\n    // 常规方法\n    public String getNormalField() {\n        String filed = \"Normal\";\n        System.out.println(\"Parent普通属性初始化\");\n        return filed;\n    }\n\n    //无参默认构造函数\n    public Parent() {\n        System.out.println(\"Parent无参默认构造函数调用\");\n    }\n\n    //有参构造函数\n    public Parent(String field) {\n        this.field = field;\n        System.out.println(\"Parent有参构造函数调用\");\n    }\n}\n\nclass Child extends Parent {\n\n    //普通属性\n    private String child_field = getChildNormalField();\n\n    // 静态属性\n    private static String child_staticField = getChildStaticField();\n\n    // 普通方法块\n    {\n        System.out.println(\"Child==========\");\n        System.out.println(child_field);\n        System.out.println(\"Child普通方法块初始化\");\n    }\n\n    //静态方法块\n    static {\n        System.out.println(\"Child==========\");\n        System.out.println(child_staticField);\n        System.out.println(\"Child静态方法块初始化\");\n    }\n\n    //静态方法\n    public static String getChildStaticField() {\n        String child_staticFiled = \"Static\";\n        System.out.println(\"Child静态属性初始化\");\n        return child_staticFiled;\n    }\n\n    // 常规方法\n    public String getChildNormalField() {\n        String child_field = \"Normal\";\n        System.out.println(\"Child普通属性初始化\");\n        return child_field;\n    }\n\n    //无参默认构造函数\n    public Child() {\n        super();\n        System.out.println(\"Child无参默认构造函数调用\");\n    }\n\n    //有参构造函数\n    public Child(String field, String child_field) {\n        super(field);\n        this.child_field = child_field;\n    }\n}\n```\n执行结果为：\n![java父子类的初始化过程](/assets/img/childClassInit.png)\n\n所以父子类的初始化加载顺序为：\n1.先初始化父类的静态属性和静态方法块\n2.再加载子类的静态属性和静态方法块\n3.加载父类的常规属性和常规方法块\n4.加载父类的静态方法和常规方法\n5.调用父类的构造函数\n6.加载子类的常规属性和常规方法块\n7.加载子类的静态方法和常规方法\n8.调用子类的构造函数\n\n### 总结\n*   加载类必先加载其属性，加载其属性必先加载静态属性和静态方法块\n*   加载子类必先加载其父类\n","source":"_posts/2018-10-11-java类的创建过程解析.md","raw":"---\ntitle: java类的创建过程解析\ndate: 2018-10-11 22:26:50\ntoc: true\ntags:\n  - java\n  - 创建过程\n---\n### 类的构成\njava类由以下几种元素构成\n+ 属性\n + 静态属性：有关键字static修饰的属性\n + 常规属性：没有关键字static修饰\n+ 方法块\n + 静态方法块：有static修饰\n + 常规方法块：没有static修饰\n <!--more-->\n+ 构造函数\n + 默认无参构造函数\n + 有参构造函数\n+ 方法\n + 静态方法：有static修饰\n + 常规方法：没有static修饰\n\n### 类的初始化\n```\npublic class Test {\n\n    public static void main(String [] args) {\n        new TestClass();\n    }\n}\n\nclass TestClass {\n\n    //普通属性\n    private String field = getNormalField();\n\n    // 静态属性\n    private static String staticField = getStaticField();\n\n    // 普通方法块\n    {\n        System.out.println(field);\n        System.out.println(\"普通方法块初始化\");\n    }\n\n    //静态方法块\n    static {\n        System.out.println(staticField);\n        System.out.println(\"静态方法块初始化\");\n    }\n\n    //静态方法\n    public static String getStaticField() {\n        String staticField = \"Static\";\n        System.out.println(\"静态属性初始化\");\n        return staticField;\n    }\n\n    // 常规方法\n    public String getNormalField() {\n        String field = \"Normal\";\n        System.out.println(\"普通属性初始化\");\n        return field;\n    }\n\n    //无参默认构造函数\n    public TestClass() {\n        System.out.println(\"无参默认构造函数调用\");\n    }\n\n    //有参构造函数\n    public TestClass(String field) {\n        this.field = field;\n        System.out.println(\"有参构造函数调用\");\n    }\n}\n```\n执行结果为：\n![java类的初始化过程](/assets/img/classInit.png)\n\n所以java类的初始化加载顺序是：\n1.先加载静态属性和静态方法块\n2.加载常规属性和常规方法块\n3.加载静态方法和常规方法\n4.加载构造函数（构造函数使用哪个加载哪个）\n\n### 父子类加载\n子类可以继承父类的通用属性和行为，同时也可以添加自己的特有属性和行为\n```\npublic class ParentChild {\n\n    public static void main(String [] args) {\n        new Child();\n    }\n}\n\nclass Parent {\n\n    //普通属性\n    private String field = getNormalField();\n\n    // 静态属性\n    private static String staticField = getStaticField();\n\n    // 普通方法块\n    {\n        System.out.println(\"Parent==========\");\n        System.out.println(field);\n        System.out.println(\"Parent普通方法块初始化\");\n    }\n\n    //静态方法块\n    static {\n        System.out.println(\"Parent==========\");\n        System.out.println(staticField);\n        System.out.println(\"Parent静态方法块初始化\");\n    }\n\n    //静态方法\n    public static String getStaticField() {\n        String staticFiled = \"Static\";\n        System.out.println(\"Parent静态属性初始化\");\n        return staticFiled;\n    }\n\n    // 常规方法\n    public String getNormalField() {\n        String filed = \"Normal\";\n        System.out.println(\"Parent普通属性初始化\");\n        return filed;\n    }\n\n    //无参默认构造函数\n    public Parent() {\n        System.out.println(\"Parent无参默认构造函数调用\");\n    }\n\n    //有参构造函数\n    public Parent(String field) {\n        this.field = field;\n        System.out.println(\"Parent有参构造函数调用\");\n    }\n}\n\nclass Child extends Parent {\n\n    //普通属性\n    private String child_field = getChildNormalField();\n\n    // 静态属性\n    private static String child_staticField = getChildStaticField();\n\n    // 普通方法块\n    {\n        System.out.println(\"Child==========\");\n        System.out.println(child_field);\n        System.out.println(\"Child普通方法块初始化\");\n    }\n\n    //静态方法块\n    static {\n        System.out.println(\"Child==========\");\n        System.out.println(child_staticField);\n        System.out.println(\"Child静态方法块初始化\");\n    }\n\n    //静态方法\n    public static String getChildStaticField() {\n        String child_staticFiled = \"Static\";\n        System.out.println(\"Child静态属性初始化\");\n        return child_staticFiled;\n    }\n\n    // 常规方法\n    public String getChildNormalField() {\n        String child_field = \"Normal\";\n        System.out.println(\"Child普通属性初始化\");\n        return child_field;\n    }\n\n    //无参默认构造函数\n    public Child() {\n        super();\n        System.out.println(\"Child无参默认构造函数调用\");\n    }\n\n    //有参构造函数\n    public Child(String field, String child_field) {\n        super(field);\n        this.child_field = child_field;\n    }\n}\n```\n执行结果为：\n![java父子类的初始化过程](/assets/img/childClassInit.png)\n\n所以父子类的初始化加载顺序为：\n1.先初始化父类的静态属性和静态方法块\n2.再加载子类的静态属性和静态方法块\n3.加载父类的常规属性和常规方法块\n4.加载父类的静态方法和常规方法\n5.调用父类的构造函数\n6.加载子类的常规属性和常规方法块\n7.加载子类的静态方法和常规方法\n8.调用子类的构造函数\n\n### 总结\n*   加载类必先加载其属性，加载其属性必先加载静态属性和静态方法块\n*   加载子类必先加载其父类\n","slug":"java类的创建过程解析","published":1,"updated":"2018-10-11T15:52:10.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvi90001ogre6po0nehb","content":"<h3 id=\"类的构成\"><a href=\"#类的构成\" class=\"headerlink\" title=\"类的构成\"></a>类的构成</h3><p>java类由以下几种元素构成</p>\n<ul>\n<li>属性<ul>\n<li>静态属性：有关键字static修饰的属性</li>\n<li>常规属性：没有关键字static修饰</li>\n</ul>\n</li>\n<li>方法块<ul>\n<li>静态方法块：有static修饰</li>\n<li>常规方法块：没有static修饰<a id=\"more\"></a></li>\n</ul>\n</li>\n<li>构造函数<ul>\n<li>默认无参构造函数</li>\n<li>有参构造函数</li>\n</ul>\n</li>\n<li>方法<ul>\n<li>静态方法：有static修饰</li>\n<li>常规方法：没有static修饰</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类的初始化\"><a href=\"#类的初始化\" class=\"headerlink\" title=\"类的初始化\"></a>类的初始化</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String [] args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestClass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String field = getNormalField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String staticField = getStaticField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通方法块</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(field);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"普通方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法块</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(staticField);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"静态方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getStaticField</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        String staticField = <span class=\"string\">\"Static\"</span>;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"静态属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> staticField;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 常规方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getNormalField</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        String field = <span class=\"string\">\"Normal\"</span>;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"普通属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> field;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无参默认构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"无参默认构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestClass</span>(<span class=\"params\">String field</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field = field;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"有参构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果为：<br><img src=\"/assets/img/classInit.png\" alt=\"java类的初始化过程\"></p>\n<p>所以java类的初始化加载顺序是：<br>1.先加载静态属性和静态方法块<br>2.加载常规属性和常规方法块<br>3.加载静态方法和常规方法<br>4.加载构造函数（构造函数使用哪个加载哪个）</p>\n<h3 id=\"父子类加载\"><a href=\"#父子类加载\" class=\"headerlink\" title=\"父子类加载\"></a>父子类加载</h3><p>子类可以继承父类的通用属性和行为，同时也可以添加自己的特有属性和行为<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class ParentChild &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span> [] args) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Parent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> field = getNormalField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> staticField = getStaticField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通方法块</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent==========\"</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(field);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent普通方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法块</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent==========\"</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(staticField);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent静态方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> getStaticField() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> staticFiled = <span class=\"string\">\"Static\"</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent静态属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> staticFiled;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 常规方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getNormalField() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> filed = <span class=\"string\">\"Normal\"</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent普通属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> filed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无参默认构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Parent() &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent无参默认构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Parent(<span class=\"keyword\">String</span> field) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field = field;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent有参构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Child extends Parent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> child_field = getChildNormalField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> child_staticField = getChildStaticField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通方法块</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child==========\"</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(child_field);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child普通方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法块</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child==========\"</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(child_staticField);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child静态方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> getChildStaticField() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> child_staticFiled = <span class=\"string\">\"Static\"</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child静态属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child_staticFiled;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 常规方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getChildNormalField() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> child_field = <span class=\"string\">\"Normal\"</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child普通属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child_field;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无参默认构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Child() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child无参默认构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Child(<span class=\"keyword\">String</span> field, <span class=\"keyword\">String</span> child_field) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(field);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.child_field = child_field;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果为：<br><img src=\"/assets/img/childClassInit.png\" alt=\"java父子类的初始化过程\"></p>\n<p>所以父子类的初始化加载顺序为：<br>1.先初始化父类的静态属性和静态方法块<br>2.再加载子类的静态属性和静态方法块<br>3.加载父类的常规属性和常规方法块<br>4.加载父类的静态方法和常规方法<br>5.调用父类的构造函数<br>6.加载子类的常规属性和常规方法块<br>7.加载子类的静态方法和常规方法<br>8.调用子类的构造函数</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>加载类必先加载其属性，加载其属性必先加载静态属性和静态方法块</li>\n<li>加载子类必先加载其父类</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"类的构成\"><a href=\"#类的构成\" class=\"headerlink\" title=\"类的构成\"></a>类的构成</h3><p>java类由以下几种元素构成</p>\n<ul>\n<li>属性<ul>\n<li>静态属性：有关键字static修饰的属性</li>\n<li>常规属性：没有关键字static修饰</li>\n</ul>\n</li>\n<li>方法块<ul>\n<li>静态方法块：有static修饰</li>\n<li>常规方法块：没有static修饰","more":"</li>\n</ul>\n</li>\n<li>构造函数<ul>\n<li>默认无参构造函数</li>\n<li>有参构造函数</li>\n</ul>\n</li>\n<li>方法<ul>\n<li>静态方法：有static修饰</li>\n<li>常规方法：没有static修饰</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类的初始化\"><a href=\"#类的初始化\" class=\"headerlink\" title=\"类的初始化\"></a>类的初始化</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String [] args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> TestClass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">TestClass</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String field = getNormalField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String staticField = getStaticField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通方法块</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(field);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"普通方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法块</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(staticField);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"静态方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getStaticField</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        String staticField = <span class=\"string\">\"Static\"</span>;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"静态属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> staticField;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 常规方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getNormalField</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        String field = <span class=\"string\">\"Normal\"</span>;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"普通属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> field;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无参默认构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestClass</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"无参默认构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TestClass</span>(<span class=\"params\">String field</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field = field;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"有参构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果为：<br><img src=\"/assets/img/classInit.png\" alt=\"java类的初始化过程\"></p>\n<p>所以java类的初始化加载顺序是：<br>1.先加载静态属性和静态方法块<br>2.加载常规属性和常规方法块<br>3.加载静态方法和常规方法<br>4.加载构造函数（构造函数使用哪个加载哪个）</p>\n<h3 id=\"父子类加载\"><a href=\"#父子类加载\" class=\"headerlink\" title=\"父子类加载\"></a>父子类加载</h3><p>子类可以继承父类的通用属性和行为，同时也可以添加自己的特有属性和行为<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class ParentChild &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span> [] args) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Parent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> field = getNormalField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> staticField = getStaticField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通方法块</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent==========\"</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(field);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent普通方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法块</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent==========\"</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(staticField);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent静态方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> getStaticField() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> staticFiled = <span class=\"string\">\"Static\"</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent静态属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> staticFiled;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 常规方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getNormalField() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> filed = <span class=\"string\">\"Normal\"</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent普通属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> filed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无参默认构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Parent() &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent无参默认构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Parent(<span class=\"keyword\">String</span> field) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field = field;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Parent有参构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Child extends Parent &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//普通属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> child_field = getChildNormalField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态属性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> child_staticField = getChildStaticField();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 普通方法块</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child==========\"</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(child_field);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child普通方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法块</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child==========\"</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(child_staticField);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child静态方法块初始化\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> getChildStaticField() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> child_staticFiled = <span class=\"string\">\"Static\"</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child静态属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child_staticFiled;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 常规方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getChildNormalField() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> child_field = <span class=\"string\">\"Normal\"</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child普通属性初始化\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child_field;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//无参默认构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Child() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"Child无参默认构造函数调用\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Child(<span class=\"keyword\">String</span> field, <span class=\"keyword\">String</span> child_field) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(field);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.child_field = child_field;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果为：<br><img src=\"/assets/img/childClassInit.png\" alt=\"java父子类的初始化过程\"></p>\n<p>所以父子类的初始化加载顺序为：<br>1.先初始化父类的静态属性和静态方法块<br>2.再加载子类的静态属性和静态方法块<br>3.加载父类的常规属性和常规方法块<br>4.加载父类的静态方法和常规方法<br>5.调用父类的构造函数<br>6.加载子类的常规属性和常规方法块<br>7.加载子类的静态方法和常规方法<br>8.调用子类的构造函数</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>加载类必先加载其属性，加载其属性必先加载静态属性和静态方法块</li>\n<li>加载子类必先加载其父类</li>\n</ul>"},{"title":"重载和重写的区别解析","date":"2018-10-12T14:05:48.000Z","toc":true,"_content":"java三大特性：封装、继承和多态。而多态就是通过重载和重写实现的，所以理解重载和重写的区别，更有利于对java多态的应用。\n\n### 重载Overloading\n重载是编译发生的多态性，同一个类中如果有多个同名方法，而返回类型或者参数列表不同叫做重载。在类编译加载时是通过参数列表的不同区分同名方法的，所以重载方法的参数列表必须不同，可以是参数个数不同，也可以是参数类型不同，返回值可以相同也可以不同，并不能以返回值的不同作为重载的判断标准。重载常用的地方是构造函数。\n\n <!--more-->\n重载的规则：\n + 同名方法必须参数列表不同（参数个数不同或者参数类型不同）\n + 同名的方法可以返回值相同，也可以返回值不同\n + 同名的方法的访问修饰符可以改变\n + 同名方法可以抛出不同异常，但只能抛出重载方法抛出异常的同类或者父类\n + 方法能够在同一个类中或者在一个子类中被重载。\n \n```\npublic class Overloading  {\n \n     public void test() {\n \n     }\n \n     protected void test(String a) {\n \n     }\n \n     public void test(int a) {\n         \n     }\n \n     public String test(String a, int b) throws NullPointerException {\n         return \"\";\n     }\n \n     public void test(int a, int b) throws Exception {\n \n     }\n }\n```\n\n### 重写Overriding\n方法重写又叫做方法覆盖，运行时的多态，子类具有父类完全相同的方法（方法名、参数列表和返回值都相同）但却有不同的表现这种多态就是重写。类对象创建时会将对象信息保存到方法表中，表中记录了类定义的方法的指针，每个表项指向了具体的方法执行代码，所以子类对象实例调用重写方法时会查找到对应的方法，而不会调用父类的同名方法这就是动态绑定机制，也就是重写的实现原理。\n\n重写的规则：\n + 重写方法名必须相同\n + 参数列表必须完全相同，包括个数以及参数类型和参数顺序\n + 返回类型必须兼容\n + 重写方法可以改变访问权限，但访问权限只能大不能小：父类方法为protect  子类重写方法不能为private  只能为public\n + 被关键字final、static修饰的方法不能被重写\n + 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。\n + 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。\n + 重写方法不能抛出新的强制性异常，可以不抛出异常或者少抛出异常\n + 构造方法不能被重写\n \n```\npublic class test {\n\n public static void main(String [] args) {\n     //向上造型\n     Parent son = new Child();\n     //son.dance()  静态绑定创建时Parent类型中没有dance方法所以编译不过\n\n     son.sing();\n     System.out.println(\"============\");\n     son.run();\n }\n}\n\nclass Parent {\n\n void sing() {\n     System.out.println(\"唱张学有的歌...\");\n }\n\n public void run() {\n     System.out.println(\"Parent Run...\");\n }\n}\n\nclass Child extends Parent{\n\n @Override\n public void sing() {\n     //可以通过关键字super调用父类的方法\n     super.sing();\n     System.out.println(\"也唱周杰伦的歌...\");\n }\n\n @Override\n public void run() {\n     System.out.println(\"Child Run...\");\n }\n\n public void dance() {\n     System.out.println(\"儿子会跳舞...\");\n }\n}\n```\n 代码执行结果：\n ![重写代码结果](/assets/img/overrideResult.png)\n \n ### 区别与联系\n| 区别   | 重载Overloading   | 重写Overriding   |\n| :------ | :------ | :------ |\n| 方法名 | 必须相同 | 必须相同 |\n| 参数列表 | 必须不同（个数或者类型不同） | 必须相同 |\n| 返回值 | 可以不同 | 可以不同，但必须兼容 |\n| 异常 | 只能大不能小，只能多不能少 | 只能小不能大，只能少不能多 |\n| 访问权限 | 可以修改 | 不能变的更小 |\n 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。\n\n","source":"_posts/2018-10-12-重载和重写的区别解析.md","raw":"---\ntitle: 重载和重写的区别解析\ndate: 2018-10-12 22:05:48\ntoc: true\ntags:\n  - java\n  - Overriding\n  - Overloading\n---\njava三大特性：封装、继承和多态。而多态就是通过重载和重写实现的，所以理解重载和重写的区别，更有利于对java多态的应用。\n\n### 重载Overloading\n重载是编译发生的多态性，同一个类中如果有多个同名方法，而返回类型或者参数列表不同叫做重载。在类编译加载时是通过参数列表的不同区分同名方法的，所以重载方法的参数列表必须不同，可以是参数个数不同，也可以是参数类型不同，返回值可以相同也可以不同，并不能以返回值的不同作为重载的判断标准。重载常用的地方是构造函数。\n\n <!--more-->\n重载的规则：\n + 同名方法必须参数列表不同（参数个数不同或者参数类型不同）\n + 同名的方法可以返回值相同，也可以返回值不同\n + 同名的方法的访问修饰符可以改变\n + 同名方法可以抛出不同异常，但只能抛出重载方法抛出异常的同类或者父类\n + 方法能够在同一个类中或者在一个子类中被重载。\n \n```\npublic class Overloading  {\n \n     public void test() {\n \n     }\n \n     protected void test(String a) {\n \n     }\n \n     public void test(int a) {\n         \n     }\n \n     public String test(String a, int b) throws NullPointerException {\n         return \"\";\n     }\n \n     public void test(int a, int b) throws Exception {\n \n     }\n }\n```\n\n### 重写Overriding\n方法重写又叫做方法覆盖，运行时的多态，子类具有父类完全相同的方法（方法名、参数列表和返回值都相同）但却有不同的表现这种多态就是重写。类对象创建时会将对象信息保存到方法表中，表中记录了类定义的方法的指针，每个表项指向了具体的方法执行代码，所以子类对象实例调用重写方法时会查找到对应的方法，而不会调用父类的同名方法这就是动态绑定机制，也就是重写的实现原理。\n\n重写的规则：\n + 重写方法名必须相同\n + 参数列表必须完全相同，包括个数以及参数类型和参数顺序\n + 返回类型必须兼容\n + 重写方法可以改变访问权限，但访问权限只能大不能小：父类方法为protect  子类重写方法不能为private  只能为public\n + 被关键字final、static修饰的方法不能被重写\n + 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。\n + 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。\n + 重写方法不能抛出新的强制性异常，可以不抛出异常或者少抛出异常\n + 构造方法不能被重写\n \n```\npublic class test {\n\n public static void main(String [] args) {\n     //向上造型\n     Parent son = new Child();\n     //son.dance()  静态绑定创建时Parent类型中没有dance方法所以编译不过\n\n     son.sing();\n     System.out.println(\"============\");\n     son.run();\n }\n}\n\nclass Parent {\n\n void sing() {\n     System.out.println(\"唱张学有的歌...\");\n }\n\n public void run() {\n     System.out.println(\"Parent Run...\");\n }\n}\n\nclass Child extends Parent{\n\n @Override\n public void sing() {\n     //可以通过关键字super调用父类的方法\n     super.sing();\n     System.out.println(\"也唱周杰伦的歌...\");\n }\n\n @Override\n public void run() {\n     System.out.println(\"Child Run...\");\n }\n\n public void dance() {\n     System.out.println(\"儿子会跳舞...\");\n }\n}\n```\n 代码执行结果：\n ![重写代码结果](/assets/img/overrideResult.png)\n \n ### 区别与联系\n| 区别   | 重载Overloading   | 重写Overriding   |\n| :------ | :------ | :------ |\n| 方法名 | 必须相同 | 必须相同 |\n| 参数列表 | 必须不同（个数或者类型不同） | 必须相同 |\n| 返回值 | 可以不同 | 可以不同，但必须兼容 |\n| 异常 | 只能大不能小，只能多不能少 | 只能小不能大，只能少不能多 |\n| 访问权限 | 可以修改 | 不能变的更小 |\n 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。\n\n","slug":"重载和重写的区别解析","published":1,"updated":"2018-10-12T15:39:42.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvig0003ogreqzl90vjm","content":"<p>java三大特性：封装、继承和多态。而多态就是通过重载和重写实现的，所以理解重载和重写的区别，更有利于对java多态的应用。</p>\n<h3 id=\"重载Overloading\"><a href=\"#重载Overloading\" class=\"headerlink\" title=\"重载Overloading\"></a>重载Overloading</h3><p>重载是编译发生的多态性，同一个类中如果有多个同名方法，而返回类型或者参数列表不同叫做重载。在类编译加载时是通过参数列表的不同区分同名方法的，所以重载方法的参数列表必须不同，可以是参数个数不同，也可以是参数类型不同，返回值可以相同也可以不同，并不能以返回值的不同作为重载的判断标准。重载常用的地方是构造函数。</p>\n <a id=\"more\"></a>\n<p>重载的规则：</p>\n<ul>\n<li>同名方法必须参数列表不同（参数个数不同或者参数类型不同）</li>\n<li>同名的方法可以返回值相同，也可以返回值不同</li>\n<li>同名的方法的访问修饰符可以改变</li>\n<li>同名方法可以抛出不同异常，但只能抛出重载方法抛出异常的同类或者父类</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Overloading</span>  </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String a)</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">(String a, <span class=\"keyword\">int</span> b)</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重写Overriding\"><a href=\"#重写Overriding\" class=\"headerlink\" title=\"重写Overriding\"></a>重写Overriding</h3><p>方法重写又叫做方法覆盖，运行时的多态，子类具有父类完全相同的方法（方法名、参数列表和返回值都相同）但却有不同的表现这种多态就是重写。类对象创建时会将对象信息保存到方法表中，表中记录了类定义的方法的指针，每个表项指向了具体的方法执行代码，所以子类对象实例调用重写方法时会查找到对应的方法，而不会调用父类的同名方法这就是动态绑定机制，也就是重写的实现原理。</p>\n<p>重写的规则：</p>\n<ul>\n<li>重写方法名必须相同</li>\n<li>参数列表必须完全相同，包括个数以及参数类型和参数顺序</li>\n<li>返回类型必须兼容</li>\n<li>重写方法可以改变访问权限，但访问权限只能大不能小：父类方法为protect  子类重写方法不能为private  只能为public</li>\n<li>被关键字final、static修饰的方法不能被重写</li>\n<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>\n<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>\n<li>重写方法不能抛出新的强制性异常，可以不抛出异常或者少抛出异常</li>\n<li>构造方法不能被重写</li>\n</ul>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String [] args</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//向上造型</span></span><br><span class=\"line\">     Parent son = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">     <span class=\"comment\">//son.dance()  静态绑定创建时Parent类型中没有dance方法所以编译不过</span></span><br><span class=\"line\"></span><br><span class=\"line\">     son.sing();</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"============\"</span>);</span><br><span class=\"line\">     son.run();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"唱张学有的歌...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Parent Run...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"title\">extends</span> <span class=\"title\">Parent</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> @Override</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//可以通过关键字super调用父类的方法</span></span><br><span class=\"line\">     super.sing();</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"也唱周杰伦的歌...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> @Override</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Child Run...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dance</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"儿子会跳舞...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 代码执行结果：<br> <img src=\"/assets/img/overrideResult.png\" alt=\"重写代码结果\"></p>\n<h3 id=\"区别与联系\"><a href=\"#区别与联系\" class=\"headerlink\" title=\"区别与联系\"></a>区别与联系</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">区别</th>\n<th style=\"text-align:left\">重载Overloading</th>\n<th style=\"text-align:left\">重写Overriding</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">方法名</td>\n<td style=\"text-align:left\">必须相同</td>\n<td style=\"text-align:left\">必须相同</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">参数列表</td>\n<td style=\"text-align:left\">必须不同（个数或者类型不同）</td>\n<td style=\"text-align:left\">必须相同</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">返回值</td>\n<td style=\"text-align:left\">可以不同</td>\n<td style=\"text-align:left\">可以不同，但必须兼容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">异常</td>\n<td style=\"text-align:left\">只能大不能小，只能多不能少</td>\n<td style=\"text-align:left\">只能小不能大，只能少不能多</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">访问权限</td>\n<td style=\"text-align:left\">可以修改</td>\n<td style=\"text-align:left\">不能变的更小</td>\n</tr>\n</tbody>\n</table>\n<p> 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p>\n","site":{"data":{}},"excerpt":"<p>java三大特性：封装、继承和多态。而多态就是通过重载和重写实现的，所以理解重载和重写的区别，更有利于对java多态的应用。</p>\n<h3 id=\"重载Overloading\"><a href=\"#重载Overloading\" class=\"headerlink\" title=\"重载Overloading\"></a>重载Overloading</h3><p>重载是编译发生的多态性，同一个类中如果有多个同名方法，而返回类型或者参数列表不同叫做重载。在类编译加载时是通过参数列表的不同区分同名方法的，所以重载方法的参数列表必须不同，可以是参数个数不同，也可以是参数类型不同，返回值可以相同也可以不同，并不能以返回值的不同作为重载的判断标准。重载常用的地方是构造函数。</p>","more":"<p>重载的规则：</p>\n<ul>\n<li>同名方法必须参数列表不同（参数个数不同或者参数类型不同）</li>\n<li>同名的方法可以返回值相同，也可以返回值不同</li>\n<li>同名的方法的访问修饰符可以改变</li>\n<li>同名方法可以抛出不同异常，但只能抛出重载方法抛出异常的同类或者父类</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Overloading</span>  </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String a)</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">(String a, <span class=\"keyword\">int</span> b)</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重写Overriding\"><a href=\"#重写Overriding\" class=\"headerlink\" title=\"重写Overriding\"></a>重写Overriding</h3><p>方法重写又叫做方法覆盖，运行时的多态，子类具有父类完全相同的方法（方法名、参数列表和返回值都相同）但却有不同的表现这种多态就是重写。类对象创建时会将对象信息保存到方法表中，表中记录了类定义的方法的指针，每个表项指向了具体的方法执行代码，所以子类对象实例调用重写方法时会查找到对应的方法，而不会调用父类的同名方法这就是动态绑定机制，也就是重写的实现原理。</p>\n<p>重写的规则：</p>\n<ul>\n<li>重写方法名必须相同</li>\n<li>参数列表必须完全相同，包括个数以及参数类型和参数顺序</li>\n<li>返回类型必须兼容</li>\n<li>重写方法可以改变访问权限，但访问权限只能大不能小：父类方法为protect  子类重写方法不能为private  只能为public</li>\n<li>被关键字final、static修饰的方法不能被重写</li>\n<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>\n<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>\n<li>重写方法不能抛出新的强制性异常，可以不抛出异常或者少抛出异常</li>\n<li>构造方法不能被重写</li>\n</ul>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String [] args</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//向上造型</span></span><br><span class=\"line\">     Parent son = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">     <span class=\"comment\">//son.dance()  静态绑定创建时Parent类型中没有dance方法所以编译不过</span></span><br><span class=\"line\"></span><br><span class=\"line\">     son.sing();</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"============\"</span>);</span><br><span class=\"line\">     son.run();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"唱张学有的歌...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Parent Run...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"title\">extends</span> <span class=\"title\">Parent</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> @Override</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//可以通过关键字super调用父类的方法</span></span><br><span class=\"line\">     super.sing();</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"也唱周杰伦的歌...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> @Override</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Child Run...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dance</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"儿子会跳舞...\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 代码执行结果：<br> <img src=\"/assets/img/overrideResult.png\" alt=\"重写代码结果\"></p>\n<h3 id=\"区别与联系\"><a href=\"#区别与联系\" class=\"headerlink\" title=\"区别与联系\"></a>区别与联系</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">区别</th>\n<th style=\"text-align:left\">重载Overloading</th>\n<th style=\"text-align:left\">重写Overriding</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">方法名</td>\n<td style=\"text-align:left\">必须相同</td>\n<td style=\"text-align:left\">必须相同</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">参数列表</td>\n<td style=\"text-align:left\">必须不同（个数或者类型不同）</td>\n<td style=\"text-align:left\">必须相同</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">返回值</td>\n<td style=\"text-align:left\">可以不同</td>\n<td style=\"text-align:left\">可以不同，但必须兼容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">异常</td>\n<td style=\"text-align:left\">只能大不能小，只能多不能少</td>\n<td style=\"text-align:left\">只能小不能大，只能少不能多</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">访问权限</td>\n<td style=\"text-align:left\">可以修改</td>\n<td style=\"text-align:left\">不能变的更小</td>\n</tr>\n</tbody>\n</table>\n<p> 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p>"},{"title":"markdown基本语法","date":"2018-10-15T07:00:44.000Z","toc":true,"_content":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。这篇博客将介绍markdown的相关基础语法，用于日常博客记录。\n\n<!--more-->\n\n# 标题\n标题的使用，一般通过不同数量的#号完成：\n<font style=\"font-size: 1.75rem; line-height: 1.25;margin-top: 2em;margin-bottom: 1em;font-weight: 900;\">一级标题</font>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.4375rem;line-height: 1.2173913043;margin-bottom: 1.2173913043em;\">二级标题</font></p>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.1875rem;line-height: 1.1052631579;margin-bottom: 1.4736842105em;\">三级标题</font></p>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;\">四级标题</font></p>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;\">五级标题</font></p>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;font-style: italic;\">六级标题</font></p>\n```\n   # 一级标题\n   ## 二级标题\n   ### 三级标题\n   #### 四级标题\n   ##### 五级标题\n   ###### 六级标题\n```\n\n等号及减号也可以进行标题的书写，不过只能书写二级标题，并且需要写在文字的下面，减号及等号的数量不会影响标题的基数，如下：\n<font style=\"font-size: 1.75rem; line-height: 1.25;margin-top: 2em;margin-bottom: 1em;font-weight: 900;\">一级标题</font>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.4375rem;line-height: 1.2173913043;margin-bottom: 1.2173913043em;\">二级标题</font></p>\n```\n二级标题\n=============\n\n二级标题\n------------\n```\n\n# 列表\n无序列表可以使用- + * 任何一种都可以，后面必须跟空格：\n+ 列表内容\n- 列表内容\n* 列表内容\n```\n+ 列表内容\n- 列表内容\n* 列表内容\n```\n有序列表直接使用数字：\n1.列表内容\n2.列表内容\n3.列表内容\n```\n1.列表内容\n2.列表内容\n3.列表内容\n```\n要区分上下级关系，只需要在下级列表前面添加空格即可：\n+ 列表内容\n + 列表内容\n   + 列表内容\n   \n```\n+ 列表内容\n + 列表内容\n   + 列表内容\n```\n1. 列表内容\n 1. 1.1 列表内容\n    1. 1.1.1 列表内容\n    2. 1.1.2 列表内容\n    3. 1.1.3 列表内容\n 2. 1.2 列表内容\n 3. 1.3 列表内容\n    \n```\n1. 列表内容\n 1. 1.1 列表内容\n    1. 1.1.1 列表内容\n    2. 1.1.2 列表内容\n    3. 1.1.3 列表内容\n 2. 1.2 列表内容\n 3. 1.3 列表内容\n```\n# 字体\n加粗斜体使用不同数量的*号，删除线使用~~：\n**粗体**\n\n    **粗体**\n\n*斜体*\n\n    *斜体*\n\n***加粗斜体***\n\n    ***加粗斜体***\n\n~~删除线~~\n\n    ~~删除线~~\n\n# 引用\n在引用的文字前加>即可。引用也可以嵌套，如加两个>>三个>>>：\n>引用内容\n>>二级引用内容\n>>>三级引用内容\n\n```\n>引用内容\n>>二级引用内容\n>>>三级引用内容\n```\n\n# 图片链接\n```\n![这里写图片描述](https://img-blog.csdn.net/xxx.png)\n![这里写图片描述][test-icon]\n[test-icon]: https://img-blog.csdn.net/xxx.png\n```\n图片的地址可以是网络的访问地址，也可以是本地的相对路径，下面以我的头像为例：\n![java类的初始化过程](/assets/blogImg/lufei.jpg)\n\n# 超链接\n在文中直接加链接，中括号中是需要添加链接的文字，圆括号中是需要添加的链接，如下：\n\n    [百度](http://www.baidu.com)\n    \n[百度](http://www.baidu.com)\n\n在文中直接引用链接，直接使用尖括号，把链接加入到尖括号中就可以实现，如下：\n\n    百度<http://www.baidu.com>\n    \n百度<http://www.baidu.com>\n\n# 分割线\n可以在一行中用三个以上的*号、-号、_号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：\n```\n\n-----\n\n********\n\n___________\n```\n\n\n-----\n\n********\n\n___________\n\n# 表格\n使用|进行分割，使用：设置对其方式，空格会自动省略\n```\n|左对齐表头  |  居中对齐表头  |  右对齐表头|\n|---|:--:|---:\n|左对齐内容  |  居中对齐内容  |  右对齐内容|\n|左对齐内容  |  居中对齐内容  |  右对齐内容|\n```\n\n|左对齐表头  |  居中对齐表头  |  右对齐表头|\n|---|:--:|---:|\n|左对齐内容  |  居中对齐内容  |  右对齐内容|\n|左对齐内容  |  居中对齐内容  |  右对齐内容|\n\n# 代码\n单行代码可以使用反引号包起来,也可以使用制表符（需要空一行）：\n```\n\n    代码内容\n        \n`代码内容`\n```\n\n    代码内容\n        \n`代码内容`\n\n代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行，为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。\n```\n(```)\n  代码...\n  代码...\n  代码...\n(```)\n```\n\n```\n    代码...\n    代码...\n    代码...\n```\n","source":"_posts/2018-10-15-markdown基本语法.md","raw":"---\ntitle: markdown基本语法\ndate: 2018-10-15 15:00:44\ntoc: true\ntags:\n    - markdown\n    - basic\n---\nMarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。这篇博客将介绍markdown的相关基础语法，用于日常博客记录。\n\n<!--more-->\n\n# 标题\n标题的使用，一般通过不同数量的#号完成：\n<font style=\"font-size: 1.75rem; line-height: 1.25;margin-top: 2em;margin-bottom: 1em;font-weight: 900;\">一级标题</font>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.4375rem;line-height: 1.2173913043;margin-bottom: 1.2173913043em;\">二级标题</font></p>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.1875rem;line-height: 1.1052631579;margin-bottom: 1.4736842105em;\">三级标题</font></p>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;\">四级标题</font></p>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;\">五级标题</font></p>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;font-style: italic;\">六级标题</font></p>\n```\n   # 一级标题\n   ## 二级标题\n   ### 三级标题\n   #### 四级标题\n   ##### 五级标题\n   ###### 六级标题\n```\n\n等号及减号也可以进行标题的书写，不过只能书写二级标题，并且需要写在文字的下面，减号及等号的数量不会影响标题的基数，如下：\n<font style=\"font-size: 1.75rem; line-height: 1.25;margin-top: 2em;margin-bottom: 1em;font-weight: 900;\">一级标题</font>\n<p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.4375rem;line-height: 1.2173913043;margin-bottom: 1.2173913043em;\">二级标题</font></p>\n```\n二级标题\n=============\n\n二级标题\n------------\n```\n\n# 列表\n无序列表可以使用- + * 任何一种都可以，后面必须跟空格：\n+ 列表内容\n- 列表内容\n* 列表内容\n```\n+ 列表内容\n- 列表内容\n* 列表内容\n```\n有序列表直接使用数字：\n1.列表内容\n2.列表内容\n3.列表内容\n```\n1.列表内容\n2.列表内容\n3.列表内容\n```\n要区分上下级关系，只需要在下级列表前面添加空格即可：\n+ 列表内容\n + 列表内容\n   + 列表内容\n   \n```\n+ 列表内容\n + 列表内容\n   + 列表内容\n```\n1. 列表内容\n 1. 1.1 列表内容\n    1. 1.1.1 列表内容\n    2. 1.1.2 列表内容\n    3. 1.1.3 列表内容\n 2. 1.2 列表内容\n 3. 1.3 列表内容\n    \n```\n1. 列表内容\n 1. 1.1 列表内容\n    1. 1.1.1 列表内容\n    2. 1.1.2 列表内容\n    3. 1.1.3 列表内容\n 2. 1.2 列表内容\n 3. 1.3 列表内容\n```\n# 字体\n加粗斜体使用不同数量的*号，删除线使用~~：\n**粗体**\n\n    **粗体**\n\n*斜体*\n\n    *斜体*\n\n***加粗斜体***\n\n    ***加粗斜体***\n\n~~删除线~~\n\n    ~~删除线~~\n\n# 引用\n在引用的文字前加>即可。引用也可以嵌套，如加两个>>三个>>>：\n>引用内容\n>>二级引用内容\n>>>三级引用内容\n\n```\n>引用内容\n>>二级引用内容\n>>>三级引用内容\n```\n\n# 图片链接\n```\n![这里写图片描述](https://img-blog.csdn.net/xxx.png)\n![这里写图片描述][test-icon]\n[test-icon]: https://img-blog.csdn.net/xxx.png\n```\n图片的地址可以是网络的访问地址，也可以是本地的相对路径，下面以我的头像为例：\n![java类的初始化过程](/assets/blogImg/lufei.jpg)\n\n# 超链接\n在文中直接加链接，中括号中是需要添加链接的文字，圆括号中是需要添加的链接，如下：\n\n    [百度](http://www.baidu.com)\n    \n[百度](http://www.baidu.com)\n\n在文中直接引用链接，直接使用尖括号，把链接加入到尖括号中就可以实现，如下：\n\n    百度<http://www.baidu.com>\n    \n百度<http://www.baidu.com>\n\n# 分割线\n可以在一行中用三个以上的*号、-号、_号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：\n```\n\n-----\n\n********\n\n___________\n```\n\n\n-----\n\n********\n\n___________\n\n# 表格\n使用|进行分割，使用：设置对其方式，空格会自动省略\n```\n|左对齐表头  |  居中对齐表头  |  右对齐表头|\n|---|:--:|---:\n|左对齐内容  |  居中对齐内容  |  右对齐内容|\n|左对齐内容  |  居中对齐内容  |  右对齐内容|\n```\n\n|左对齐表头  |  居中对齐表头  |  右对齐表头|\n|---|:--:|---:|\n|左对齐内容  |  居中对齐内容  |  右对齐内容|\n|左对齐内容  |  居中对齐内容  |  右对齐内容|\n\n# 代码\n单行代码可以使用反引号包起来,也可以使用制表符（需要空一行）：\n```\n\n    代码内容\n        \n`代码内容`\n```\n\n    代码内容\n        \n`代码内容`\n\n代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行，为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。\n```\n(```)\n  代码...\n  代码...\n  代码...\n(```)\n```\n\n```\n    代码...\n    代码...\n    代码...\n```\n","slug":"markdown基本语法","published":1,"updated":"2018-11-18T14:59:51.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvii0004ogrek8c5w31w","content":"<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。这篇博客将介绍markdown的相关基础语法，用于日常博客记录。</p>\n<a id=\"more\"></a>\n<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h1><p>标题的使用，一般通过不同数量的#号完成：</p>\n<p><font style=\"font-size: 1.75rem; line-height: 1.25;margin-top: 2em;margin-bottom: 1em;font-weight: 900;\">一级标题</font></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.4375rem;line-height: 1.2173913043;margin-bottom: 1.2173913043em;\">二级标题</font></p><p></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.1875rem;line-height: 1.1052631579;margin-bottom: 1.4736842105em;\">三级标题</font></p><p></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;\">四级标题</font></p><p></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;\">五级标题</font></p><p></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;font-style: italic;\">六级标题</font></p><br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br></pre></td></tr></table></figure><p></p>\n<p>等号及减号也可以进行标题的书写，不过只能书写二级标题，并且需要写在文字的下面，减号及等号的数量不会影响标题的基数，如下：</p>\n<p><font style=\"font-size: 1.75rem; line-height: 1.25;margin-top: 2em;margin-bottom: 1em;font-weight: 900;\">一级标题</font></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.4375rem;line-height: 1.2173913043;margin-bottom: 1.2173913043em;\">二级标题</font></p><br><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二级标题</span><br><span class=\"line\">=============</span><br><span class=\"line\"></span><br><span class=\"line\">二级标题</span><br><span class=\"line\">------------</span><br></pre></td></tr></table></figure><p></p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><p>无序列表可以使用- + * 任何一种都可以，后面必须跟空格：</p>\n<ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">+ </span>列表内容</span><br><span class=\"line\"><span class=\"bullet\">- </span>列表内容</span><br><span class=\"line\"><span class=\"bullet\">* </span>列表内容</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有序列表直接使用数字：<br>1.列表内容<br>2.列表内容<br>3.列表内容<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>列表内容</span><br><span class=\"line\"><span class=\"number\">2.</span>列表内容</span><br><span class=\"line\"><span class=\"number\">3.</span>列表内容</span><br></pre></td></tr></table></figure></p>\n<p>要区分上下级关系，只需要在下级列表前面添加空格即可：</p>\n<ul>\n<li>列表内容<ul>\n<li>列表内容<ul>\n<li>列表内容</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">+ </span>列表内容</span><br><span class=\"line\"> + 列表内容</span><br><span class=\"line\">   + 列表内容</span><br></pre></td></tr></table></figure>\n<ol>\n<li>列表内容<ol>\n<li>1.1 列表内容<ol>\n<li>1.1.1 列表内容</li>\n<li>1.1.2 列表内容</li>\n<li>1.1.3 列表内容</li>\n</ol>\n</li>\n<li>1.2 列表内容</li>\n<li>1.3 列表内容</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 列表内容</span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"number\">1.1</span> 列表内容</span><br><span class=\"line\">    <span class=\"number\">1.</span> <span class=\"number\">1.1</span><span class=\"number\">.1</span> 列表内容</span><br><span class=\"line\">    <span class=\"number\">2.</span> <span class=\"number\">1.1</span><span class=\"number\">.2</span> 列表内容</span><br><span class=\"line\">    <span class=\"number\">3.</span> <span class=\"number\">1.1</span><span class=\"number\">.3</span> 列表内容</span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"number\">1.2</span> 列表内容</span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"number\">1.3</span> 列表内容</span><br></pre></td></tr></table></figure>\n<h1 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h1><p>加粗斜体使用不同数量的*号，删除线使用~~：<br><strong>粗体</strong></p>\n<pre><code>**粗体**\n</code></pre><p><em>斜体</em></p>\n<pre><code>*斜体*\n</code></pre><p><strong><em>加粗斜体</em></strong></p>\n<pre><code>***加粗斜体***\n</code></pre><p><del>删除线</del></p>\n<pre><code>~~删除线~~\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;：</p>\n<blockquote>\n<p>引用内容</p>\n<blockquote>\n<p>二级引用内容</p>\n<blockquote>\n<p>三级引用内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">引用内容</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;二级引用内容</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt;三级引用内容</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"图片链接\"><a href=\"#图片链接\" class=\"headerlink\" title=\"图片链接\"></a>图片链接</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">这里写图片描述</span>](<span class=\"link\">https://img-blog.csdn.net/xxx.png</span>)</span><br><span class=\"line\">![<span class=\"string\">这里写图片描述</span>][<span class=\"symbol\">test-icon</span>]</span><br><span class=\"line\">[<span class=\"symbol\">test-icon</span>]: <span class=\"link\">https://img-blog.csdn.net/xxx.png</span></span><br></pre></td></tr></table></figure>\n<p>图片的地址可以是网络的访问地址，也可以是本地的相对路径，下面以我的头像为例：<br><img src=\"/assets/blogImg/lufei.jpg\" alt=\"java类的初始化过程\"></p>\n<h1 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h1><p>在文中直接加链接，中括号中是需要添加链接的文字，圆括号中是需要添加的链接，如下：</p>\n<pre><code>[百度](http://www.baidu.com)\n</code></pre><p><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">百度</a></p>\n<p>在文中直接引用链接，直接使用尖括号，把链接加入到尖括号中就可以实现，如下：</p>\n<pre><code>百度&lt;http://www.baidu.com&gt;\n</code></pre><p>百度<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a></p>\n<h1 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h1><p>可以在一行中用三个以上的*号、-号、_号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：<br><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">-----</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"strong\">*****</span><span class=\"emphasis\">***</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"strong\">_____</span><span class=\"strong\">_____</span>_</span><br></pre></td></tr></table></figure></p>\n<hr>\n<hr>\n<hr>\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><p>使用|进行分割，使用：设置对其方式，空格会自动省略<br><figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|<span class=\"string\">左对齐表头  </span>|<span class=\"string\">  居中对齐表头  </span>|<span class=\"string\">  右对齐表头</span>|</span><br><span class=\"line\">|<span class=\"string\">---</span>|<span class=\"string\">:--:</span>|<span class=\"string\">---:</span></span><br><span class=\"line\">|<span class=\"string\">左对齐内容  </span>|<span class=\"string\">  居中对齐内容  </span>|<span class=\"string\">  右对齐内容</span>|</span><br><span class=\"line\">|<span class=\"string\">左对齐内容  </span>|<span class=\"string\">  居中对齐内容  </span>|<span class=\"string\">  右对齐内容</span>|</span><br></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th>左对齐表头</th>\n<th style=\"text-align:center\">居中对齐表头</th>\n<th style=\"text-align:right\">右对齐表头</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左对齐内容</td>\n<td style=\"text-align:center\">居中对齐内容</td>\n<td style=\"text-align:right\">右对齐内容</td>\n</tr>\n<tr>\n<td>左对齐内容</td>\n<td style=\"text-align:center\">居中对齐内容</td>\n<td style=\"text-align:right\">右对齐内容</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><p>单行代码可以使用反引号包起来,也可以使用制表符（需要空一行）：<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    代码内容</span><br><span class=\"line\">        </span><br><span class=\"line\">`代码内容`</span><br></pre></td></tr></table></figure></p>\n<pre><code>代码内容\n</code></pre><p><code>代码内容</code></p>\n<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行，为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(```)</span><br><span class=\"line\">  代码...</span><br><span class=\"line\">  代码...</span><br><span class=\"line\">  代码...</span><br><span class=\"line\">(```)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">代码...</span><br><span class=\"line\">代码...</span><br><span class=\"line\">代码...</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。这篇博客将介绍markdown的相关基础语法，用于日常博客记录。</p>","more":"<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h1><p>标题的使用，一般通过不同数量的#号完成：</p>\n<p><font style=\"font-size: 1.75rem; line-height: 1.25;margin-top: 2em;margin-bottom: 1em;font-weight: 900;\">一级标题</font></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.4375rem;line-height: 1.2173913043;margin-bottom: 1.2173913043em;\">二级标题</font></p><p></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.1875rem;line-height: 1.1052631579;margin-bottom: 1.4736842105em;\">三级标题</font></p><p></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;\">四级标题</font></p><p></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;\">五级标题</font></p><p></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1rem;line-height: 1.3125;margin-bottom: 1.75em;font-style: italic;\">六级标题</font></p><br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一级标题</span><br><span class=\"line\">## 二级标题</span><br><span class=\"line\">### 三级标题</span><br><span class=\"line\">#### 四级标题</span><br><span class=\"line\">##### 五级标题</span><br><span class=\"line\">###### 六级标题</span><br></pre></td></tr></table></figure><p></p>\n<p>等号及减号也可以进行标题的书写，不过只能书写二级标题，并且需要写在文字的下面，减号及等号的数量不会影响标题的基数，如下：</p>\n<p><font style=\"font-size: 1.75rem; line-height: 1.25;margin-top: 2em;margin-bottom: 1em;font-weight: 900;\">一级标题</font></p>\n<p></p><p style=\"margin-top: 20px;font-weight: 700;color: #574c4c;padding-bottom: 5px;border-bottom: 1px solid #ddd;\"><font style=\"font-size: 1.4375rem;line-height: 1.2173913043;margin-bottom: 1.2173913043em;\">二级标题</font></p><br><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二级标题</span><br><span class=\"line\">=============</span><br><span class=\"line\"></span><br><span class=\"line\">二级标题</span><br><span class=\"line\">------------</span><br></pre></td></tr></table></figure><p></p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><p>无序列表可以使用- + * 任何一种都可以，后面必须跟空格：</p>\n<ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">+ </span>列表内容</span><br><span class=\"line\"><span class=\"bullet\">- </span>列表内容</span><br><span class=\"line\"><span class=\"bullet\">* </span>列表内容</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有序列表直接使用数字：<br>1.列表内容<br>2.列表内容<br>3.列表内容<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>列表内容</span><br><span class=\"line\"><span class=\"number\">2.</span>列表内容</span><br><span class=\"line\"><span class=\"number\">3.</span>列表内容</span><br></pre></td></tr></table></figure></p>\n<p>要区分上下级关系，只需要在下级列表前面添加空格即可：</p>\n<ul>\n<li>列表内容<ul>\n<li>列表内容<ul>\n<li>列表内容</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">+ </span>列表内容</span><br><span class=\"line\"> + 列表内容</span><br><span class=\"line\">   + 列表内容</span><br></pre></td></tr></table></figure>\n<ol>\n<li>列表内容<ol>\n<li>1.1 列表内容<ol>\n<li>1.1.1 列表内容</li>\n<li>1.1.2 列表内容</li>\n<li>1.1.3 列表内容</li>\n</ol>\n</li>\n<li>1.2 列表内容</li>\n<li>1.3 列表内容</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 列表内容</span><br><span class=\"line\"> <span class=\"number\">1.</span> <span class=\"number\">1.1</span> 列表内容</span><br><span class=\"line\">    <span class=\"number\">1.</span> <span class=\"number\">1.1</span><span class=\"number\">.1</span> 列表内容</span><br><span class=\"line\">    <span class=\"number\">2.</span> <span class=\"number\">1.1</span><span class=\"number\">.2</span> 列表内容</span><br><span class=\"line\">    <span class=\"number\">3.</span> <span class=\"number\">1.1</span><span class=\"number\">.3</span> 列表内容</span><br><span class=\"line\"> <span class=\"number\">2.</span> <span class=\"number\">1.2</span> 列表内容</span><br><span class=\"line\"> <span class=\"number\">3.</span> <span class=\"number\">1.3</span> 列表内容</span><br></pre></td></tr></table></figure>\n<h1 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h1><p>加粗斜体使用不同数量的*号，删除线使用~~：<br><strong>粗体</strong></p>\n<pre><code>**粗体**\n</code></pre><p><em>斜体</em></p>\n<pre><code>*斜体*\n</code></pre><p><strong><em>加粗斜体</em></strong></p>\n<pre><code>***加粗斜体***\n</code></pre><p><del>删除线</del></p>\n<pre><code>~~删除线~~\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;：</p>\n<blockquote>\n<p>引用内容</p>\n<blockquote>\n<p>二级引用内容</p>\n<blockquote>\n<p>三级引用内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">引用内容</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;二级引用内容</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt;三级引用内容</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"图片链接\"><a href=\"#图片链接\" class=\"headerlink\" title=\"图片链接\"></a>图片链接</h1><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">这里写图片描述</span>](<span class=\"link\">https://img-blog.csdn.net/xxx.png</span>)</span><br><span class=\"line\">![<span class=\"string\">这里写图片描述</span>][<span class=\"symbol\">test-icon</span>]</span><br><span class=\"line\">[<span class=\"symbol\">test-icon</span>]: <span class=\"link\">https://img-blog.csdn.net/xxx.png</span></span><br></pre></td></tr></table></figure>\n<p>图片的地址可以是网络的访问地址，也可以是本地的相对路径，下面以我的头像为例：<br><img src=\"/assets/blogImg/lufei.jpg\" alt=\"java类的初始化过程\"></p>\n<h1 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h1><p>在文中直接加链接，中括号中是需要添加链接的文字，圆括号中是需要添加的链接，如下：</p>\n<pre><code>[百度](http://www.baidu.com)\n</code></pre><p><a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">百度</a></p>\n<p>在文中直接引用链接，直接使用尖括号，把链接加入到尖括号中就可以实现，如下：</p>\n<pre><code>百度&lt;http://www.baidu.com&gt;\n</code></pre><p>百度<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com</a></p>\n<h1 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h1><p>可以在一行中用三个以上的*号、-号、_号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：<br><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">-----</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"strong\">*****</span><span class=\"emphasis\">***</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"strong\">_____</span><span class=\"strong\">_____</span>_</span><br></pre></td></tr></table></figure></p>\n<hr>\n<hr>\n<hr>\n<h1 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h1><p>使用|进行分割，使用：设置对其方式，空格会自动省略<br><figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|<span class=\"string\">左对齐表头  </span>|<span class=\"string\">  居中对齐表头  </span>|<span class=\"string\">  右对齐表头</span>|</span><br><span class=\"line\">|<span class=\"string\">---</span>|<span class=\"string\">:--:</span>|<span class=\"string\">---:</span></span><br><span class=\"line\">|<span class=\"string\">左对齐内容  </span>|<span class=\"string\">  居中对齐内容  </span>|<span class=\"string\">  右对齐内容</span>|</span><br><span class=\"line\">|<span class=\"string\">左对齐内容  </span>|<span class=\"string\">  居中对齐内容  </span>|<span class=\"string\">  右对齐内容</span>|</span><br></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th>左对齐表头</th>\n<th style=\"text-align:center\">居中对齐表头</th>\n<th style=\"text-align:right\">右对齐表头</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>左对齐内容</td>\n<td style=\"text-align:center\">居中对齐内容</td>\n<td style=\"text-align:right\">右对齐内容</td>\n</tr>\n<tr>\n<td>左对齐内容</td>\n<td style=\"text-align:center\">居中对齐内容</td>\n<td style=\"text-align:right\">右对齐内容</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><p>单行代码可以使用反引号包起来,也可以使用制表符（需要空一行）：<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    代码内容</span><br><span class=\"line\">        </span><br><span class=\"line\">`代码内容`</span><br></pre></td></tr></table></figure></p>\n<pre><code>代码内容\n</code></pre><p><code>代码内容</code></p>\n<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行，为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(```)</span><br><span class=\"line\">  代码...</span><br><span class=\"line\">  代码...</span><br><span class=\"line\">  代码...</span><br><span class=\"line\">(```)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">代码...</span><br><span class=\"line\">代码...</span><br><span class=\"line\">代码...</span><br></pre></td></tr></table></figure>"},{"title":"HashMap和Hashtable的区别比较","date":"2018-11-04T12:37:05.000Z","toc":true,"_content":"Java 集合框架中主要包含的容器类除了集合（Collection），另一种就是图（Map），主要用来存储键值对，其中最常用的就是HashMap,而HashMap和早期设计的Hashtable又有许多相似之处，所以经常将二者进行比较。\n\n### HashMap和Hashtable的继承关系\nHashMap 继承自AbstractMap类，实现了Map、Cloneable、java.io.Serializable接口；而Hashtable继承自 Dictionary,同样实现了Map、Cloneable、java.io.Serializable接口。Hashtable是java一开始发布时就提供的键值映射的数据结构，而HashMap产生于JDK1.2。虽然Hashtable比HashMap出现的早一些，但是现在Hashtable基本上已经被弃用了。\n\n<!--more-->\n\n![HashMap和Hashtable的继承关系](/assets/img/mapDifferent.png)\n\n### HashMap 介绍\n* HashMap 是一个散列表，用于储存键值对\n* HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口\n* 可以被克隆，支持序列化，能通过序列化去传输\n* HashMap 不是线程同步的，储存的键值对可以是null;但只能有一个键为null\n* HashMap 默认初始值为16，扩充因子默认为0.75，扩充容量翻倍：capacity * 2\n\n### HashMap 的构造函数\n\n```\n //默认构造函数 默认初始容量为16\n public HashMap() {\n     this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n  }\n\n //指定初始容量的构造函数 容量不足时会扩充为原来的2倍\n public HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n }\n \n //指定初始容量和扩充因子的构造函数\n public HashMap(int initialCapacity, float loadFactor) {\n     if (initialCapacity < 0)\n         throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                            initialCapacity);\n     if (initialCapacity > MAXIMUM_CAPACITY)\n         initialCapacity = MAXIMUM_CAPACITY;\n     if (loadFactor <= 0 || Float.isNaN(loadFactor))\n         throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                            loadFactor);\n     this.loadFactor = loadFactor;\n     this.threshold = tableSizeFor(initialCapacity);\n }\n \n //指定Map集合的构造函数\n public HashMap(Map<? extends K, ? extends V> m) {\n     this.loadFactor = DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);\n }\n```\n\n### HashMap 的几种遍历方法\n```\n//创建初始化\nHashMap hashMap = new HashMap();\n\n//添加元素\nhashMap.put(\"name\", \"Jordan Zhang\");\nhashMap.put(\"gender\", \"man\");\nhashMap.put(\"hobby\", \"sports\");\n\n//迭代器遍历键值对\nSystem.out.println(\"迭代器遍历键值对\");\nIterator iterator = hashMap.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry entry = (Map.Entry)iterator.next();\n    // 获取key\n    String key = (String)entry.getKey();\n    // 获取value\n    String value = (String)entry.getValue();\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过遍历键遍历 无法获取键key\nSystem.out.println(\"通过遍历键遍历\");\niterator = hashMap.keySet().iterator();\nwhile (iterator.hasNext()) {\n    // 获取key\n    String key = (String)iterator.next();\n    // 获取value\n    String value = (String)hashMap.get(key);\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过遍历值遍历\nSystem.out.println(\"通过遍历值遍历\");\nCollection collection = hashMap.values();\niterator = collection.iterator();\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}\n```\n\n### Hashtable 的介绍\n+ Hashtable 和 HashMap一样也是散列表，用来存储键值对\n+ Hashtable 继承自 Dictionary,实现了Map、Cloneable、java.io.Serializable接口\n+ 可以进行克隆，支持序列化，能通过序列化去传输\n+ Hashtable 是线程同步的，所以它是线程安全的，多线程也可以使用\n+ Hashtable 的键key 和 值value都不可以是null,存储的映射也不是有序的\n+ Hashtable 的初始容量为11，扩充因子为0.75，扩充容量为：capacity * 2 + 1\n\n### Hashtable 的构造函数\n```\n//默认构造函数 初始容量为11，扩充因子为0.75\npublic Hashtable() {\n    this(11, 0.75f);\n}\n\n//指定初始容量的构造函数 扩充容量为 capacity * 2 + 1\npublic Hashtable(int initialCapacity) {\n    this(initialCapacity, 0.75f);\n}\n\n//指定初始容量和扩充因子的构造函数\npublic Hashtable(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);\n\n    if (initialCapacity==0)\n        initialCapacity = 1;\n    this.loadFactor = loadFactor;\n    table = new Entry<?,?>[initialCapacity];\n    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);\n}\n\n//指定Map集合的构造函数\npublic Hashtable(Map<? extends K, ? extends V> t) {\n    this(Math.max(2*t.size(), 11), 0.75f);\n    putAll(t);\n}\n```\n\n### Hashtable 的遍历方法\n```\n//默认初始化\nHashtable hashTable = new Hashtable();\n\n//添加元素\nhashTable.put(\"name\", \"Jordan Zhang\");\nhashTable.put(\"gender\", \"man\");\nhashTable.put(\"hobby\", \"sports\");\n\n//迭代器遍历键值对\nSystem.out.println(\"迭代器遍历键值对\");\nIterator iterator = hashTable.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry entry = (Map.Entry) iterator.next();\n    // 获取key\n    String key = (String) entry.getKey();\n    // 获取value\n    String value = (String) entry.getValue();\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过遍历键遍历\nSystem.out.println(\"通过遍历键遍历\");\niterator = hashTable.keySet().iterator();\nwhile (iterator.hasNext()) {\n    // 获取key\n    String key = (String) iterator.next();\n    // 获取value\n    String value = (String) hashTable.get(key);\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过遍历值遍历 无法获取键key\nSystem.out.println(\"通过遍历值遍历\");\nCollection collection = hashTable.values();\niterator = collection.iterator();\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\nSystem.out.println();\nSystem.out.println();\n\n//通过Enumeration遍历Hashtable的键\nSystem.out.println(\"通过Enumeration遍历Hashtable的键\");\nEnumeration keys = hashTable.keys();\nwhile(keys.hasMoreElements()) {\n    String key = (String) keys.nextElement();\n    String value = (String) hashTable.get(key);\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过Enumeration遍历Hashtable的值 无法获取键key\nSystem.out.println(\"通过Enumeration遍历Hashtable的值\");\nEnumeration values = hashTable.elements();\nwhile (values.hasMoreElements()) {\n    System.out.println(values.nextElement());\n}\n\n```\n\n### HashMap和Hashtable的异同\nHashMap和Hashtable都是实现了Map、Cloneable、java.io.Serializable接口，可以被克隆，支持序列化，能通过序列化去传输；但是HashMap继承自AbstractMap,Hashtable继承自Dictionary,Hashtable是线程安全的，HashMap不是。HashMap允许键或值为null，而Hashtable不允许。\n\n|Map集合 |  HashMap |  Hashtable |\n| :------ | :------ | :------ |\n| 继承父类 | AbstractMap |  Dictionary |\n| 实现接口 | Cloneable,Serializable | Cloneable,Serializable |\n| 线程安全 | 非线程安全 | 线程安全 |\n| 键值是否支持Null |  键或值可以是Null | 键和值不允许是Null|\n| 提供contains方法 | 没有 | 有 | \n| 初始容量 | 默认16 | 默认11|\n| 扩充容量 | capacity * 2 | capacity * 2 + 1|\n| 遍历实现 | 使用了 Iterator | 使用了 Iterator、Enumeration|\n| hash值 | 直接使用对象的hashCode | 重新计算hash值|","source":"_posts/2018-11-04-HashMap和Hashtable的区别比较.md","raw":"---\ntitle: HashMap和Hashtable的区别比较\ndate: 2018-11-04 20:37:05\ntoc: true\ntags:\n    - 集合\n    - HashMap\n    - Hashtable\n---\nJava 集合框架中主要包含的容器类除了集合（Collection），另一种就是图（Map），主要用来存储键值对，其中最常用的就是HashMap,而HashMap和早期设计的Hashtable又有许多相似之处，所以经常将二者进行比较。\n\n### HashMap和Hashtable的继承关系\nHashMap 继承自AbstractMap类，实现了Map、Cloneable、java.io.Serializable接口；而Hashtable继承自 Dictionary,同样实现了Map、Cloneable、java.io.Serializable接口。Hashtable是java一开始发布时就提供的键值映射的数据结构，而HashMap产生于JDK1.2。虽然Hashtable比HashMap出现的早一些，但是现在Hashtable基本上已经被弃用了。\n\n<!--more-->\n\n![HashMap和Hashtable的继承关系](/assets/img/mapDifferent.png)\n\n### HashMap 介绍\n* HashMap 是一个散列表，用于储存键值对\n* HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口\n* 可以被克隆，支持序列化，能通过序列化去传输\n* HashMap 不是线程同步的，储存的键值对可以是null;但只能有一个键为null\n* HashMap 默认初始值为16，扩充因子默认为0.75，扩充容量翻倍：capacity * 2\n\n### HashMap 的构造函数\n\n```\n //默认构造函数 默认初始容量为16\n public HashMap() {\n     this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n  }\n\n //指定初始容量的构造函数 容量不足时会扩充为原来的2倍\n public HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n }\n \n //指定初始容量和扩充因子的构造函数\n public HashMap(int initialCapacity, float loadFactor) {\n     if (initialCapacity < 0)\n         throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                            initialCapacity);\n     if (initialCapacity > MAXIMUM_CAPACITY)\n         initialCapacity = MAXIMUM_CAPACITY;\n     if (loadFactor <= 0 || Float.isNaN(loadFactor))\n         throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                            loadFactor);\n     this.loadFactor = loadFactor;\n     this.threshold = tableSizeFor(initialCapacity);\n }\n \n //指定Map集合的构造函数\n public HashMap(Map<? extends K, ? extends V> m) {\n     this.loadFactor = DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);\n }\n```\n\n### HashMap 的几种遍历方法\n```\n//创建初始化\nHashMap hashMap = new HashMap();\n\n//添加元素\nhashMap.put(\"name\", \"Jordan Zhang\");\nhashMap.put(\"gender\", \"man\");\nhashMap.put(\"hobby\", \"sports\");\n\n//迭代器遍历键值对\nSystem.out.println(\"迭代器遍历键值对\");\nIterator iterator = hashMap.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry entry = (Map.Entry)iterator.next();\n    // 获取key\n    String key = (String)entry.getKey();\n    // 获取value\n    String value = (String)entry.getValue();\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过遍历键遍历 无法获取键key\nSystem.out.println(\"通过遍历键遍历\");\niterator = hashMap.keySet().iterator();\nwhile (iterator.hasNext()) {\n    // 获取key\n    String key = (String)iterator.next();\n    // 获取value\n    String value = (String)hashMap.get(key);\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过遍历值遍历\nSystem.out.println(\"通过遍历值遍历\");\nCollection collection = hashMap.values();\niterator = collection.iterator();\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}\n```\n\n### Hashtable 的介绍\n+ Hashtable 和 HashMap一样也是散列表，用来存储键值对\n+ Hashtable 继承自 Dictionary,实现了Map、Cloneable、java.io.Serializable接口\n+ 可以进行克隆，支持序列化，能通过序列化去传输\n+ Hashtable 是线程同步的，所以它是线程安全的，多线程也可以使用\n+ Hashtable 的键key 和 值value都不可以是null,存储的映射也不是有序的\n+ Hashtable 的初始容量为11，扩充因子为0.75，扩充容量为：capacity * 2 + 1\n\n### Hashtable 的构造函数\n```\n//默认构造函数 初始容量为11，扩充因子为0.75\npublic Hashtable() {\n    this(11, 0.75f);\n}\n\n//指定初始容量的构造函数 扩充容量为 capacity * 2 + 1\npublic Hashtable(int initialCapacity) {\n    this(initialCapacity, 0.75f);\n}\n\n//指定初始容量和扩充因子的构造函数\npublic Hashtable(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);\n\n    if (initialCapacity==0)\n        initialCapacity = 1;\n    this.loadFactor = loadFactor;\n    table = new Entry<?,?>[initialCapacity];\n    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);\n}\n\n//指定Map集合的构造函数\npublic Hashtable(Map<? extends K, ? extends V> t) {\n    this(Math.max(2*t.size(), 11), 0.75f);\n    putAll(t);\n}\n```\n\n### Hashtable 的遍历方法\n```\n//默认初始化\nHashtable hashTable = new Hashtable();\n\n//添加元素\nhashTable.put(\"name\", \"Jordan Zhang\");\nhashTable.put(\"gender\", \"man\");\nhashTable.put(\"hobby\", \"sports\");\n\n//迭代器遍历键值对\nSystem.out.println(\"迭代器遍历键值对\");\nIterator iterator = hashTable.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry entry = (Map.Entry) iterator.next();\n    // 获取key\n    String key = (String) entry.getKey();\n    // 获取value\n    String value = (String) entry.getValue();\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过遍历键遍历\nSystem.out.println(\"通过遍历键遍历\");\niterator = hashTable.keySet().iterator();\nwhile (iterator.hasNext()) {\n    // 获取key\n    String key = (String) iterator.next();\n    // 获取value\n    String value = (String) hashTable.get(key);\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过遍历值遍历 无法获取键key\nSystem.out.println(\"通过遍历值遍历\");\nCollection collection = hashTable.values();\niterator = collection.iterator();\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\nSystem.out.println();\nSystem.out.println();\n\n//通过Enumeration遍历Hashtable的键\nSystem.out.println(\"通过Enumeration遍历Hashtable的键\");\nEnumeration keys = hashTable.keys();\nwhile(keys.hasMoreElements()) {\n    String key = (String) keys.nextElement();\n    String value = (String) hashTable.get(key);\n    System.out.println(\"key: \" + key + \" value: \" + value);\n}\nSystem.out.println();\n\n//通过Enumeration遍历Hashtable的值 无法获取键key\nSystem.out.println(\"通过Enumeration遍历Hashtable的值\");\nEnumeration values = hashTable.elements();\nwhile (values.hasMoreElements()) {\n    System.out.println(values.nextElement());\n}\n\n```\n\n### HashMap和Hashtable的异同\nHashMap和Hashtable都是实现了Map、Cloneable、java.io.Serializable接口，可以被克隆，支持序列化，能通过序列化去传输；但是HashMap继承自AbstractMap,Hashtable继承自Dictionary,Hashtable是线程安全的，HashMap不是。HashMap允许键或值为null，而Hashtable不允许。\n\n|Map集合 |  HashMap |  Hashtable |\n| :------ | :------ | :------ |\n| 继承父类 | AbstractMap |  Dictionary |\n| 实现接口 | Cloneable,Serializable | Cloneable,Serializable |\n| 线程安全 | 非线程安全 | 线程安全 |\n| 键值是否支持Null |  键或值可以是Null | 键和值不允许是Null|\n| 提供contains方法 | 没有 | 有 | \n| 初始容量 | 默认16 | 默认11|\n| 扩充容量 | capacity * 2 | capacity * 2 + 1|\n| 遍历实现 | 使用了 Iterator | 使用了 Iterator、Enumeration|\n| hash值 | 直接使用对象的hashCode | 重新计算hash值|","slug":"HashMap和Hashtable的区别比较","published":1,"updated":"2018-11-04T14:40:47.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvik0005ogrehmufhgch","content":"<p>Java 集合框架中主要包含的容器类除了集合（Collection），另一种就是图（Map），主要用来存储键值对，其中最常用的就是HashMap,而HashMap和早期设计的Hashtable又有许多相似之处，所以经常将二者进行比较。</p>\n<h3 id=\"HashMap和Hashtable的继承关系\"><a href=\"#HashMap和Hashtable的继承关系\" class=\"headerlink\" title=\"HashMap和Hashtable的继承关系\"></a>HashMap和Hashtable的继承关系</h3><p>HashMap 继承自AbstractMap类，实现了Map、Cloneable、java.io.Serializable接口；而Hashtable继承自 Dictionary,同样实现了Map、Cloneable、java.io.Serializable接口。Hashtable是java一开始发布时就提供的键值映射的数据结构，而HashMap产生于JDK1.2。虽然Hashtable比HashMap出现的早一些，但是现在Hashtable基本上已经被弃用了。</p>\n<a id=\"more\"></a>\n<p><img src=\"/assets/img/mapDifferent.png\" alt=\"HashMap和Hashtable的继承关系\"></p>\n<h3 id=\"HashMap-介绍\"><a href=\"#HashMap-介绍\" class=\"headerlink\" title=\"HashMap 介绍\"></a>HashMap 介绍</h3><ul>\n<li>HashMap 是一个散列表，用于储存键值对</li>\n<li>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口</li>\n<li>可以被克隆，支持序列化，能通过序列化去传输</li>\n<li>HashMap 不是线程同步的，储存的键值对可以是null;但只能有一个键为null</li>\n<li>HashMap 默认初始值为16，扩充因子默认为0.75，扩充容量翻倍：capacity * 2</li>\n</ul>\n<h3 id=\"HashMap-的构造函数\"><a href=\"#HashMap-的构造函数\" class=\"headerlink\" title=\"HashMap 的构造函数\"></a>HashMap 的构造函数</h3><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造函数 默认初始容量为16</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all other fields defaulted</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定初始容量的构造函数 容量不足时会扩充为原来的2倍</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定初始容量和扩充因子的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定Map集合的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">    putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HashMap-的几种遍历方法\"><a href=\"#HashMap-的几种遍历方法\" class=\"headerlink\" title=\"HashMap 的几种遍历方法\"></a>HashMap 的几种遍历方法</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建初始化</span></span><br><span class=\"line\"><span class=\"keyword\">HashMap</span> hashMap = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加元素</span></span><br><span class=\"line\">hashMap.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Jordan Zhang\"</span>);</span><br><span class=\"line\">hashMap.put(<span class=\"string\">\"gender\"</span>, <span class=\"string\">\"man\"</span>);</span><br><span class=\"line\">hashMap.put(<span class=\"string\">\"hobby\"</span>, <span class=\"string\">\"sports\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代器遍历键值对</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"迭代器遍历键值对\"</span>);</span><br><span class=\"line\">Iterator iterator = hashMap.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry entry = (Map.Entry)iterator.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取key</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>)entry.getKey();</span><br><span class=\"line\">    <span class=\"comment\">// 获取value</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>)entry.getValue();</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过遍历键遍历 无法获取键key</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过遍历键遍历\"</span>);</span><br><span class=\"line\">iterator = hashMap.keySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取key</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>)iterator.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取value</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>)hashMap.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过遍历值遍历</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过遍历值遍历\"</span>);</span><br><span class=\"line\">Collection collection = hashMap.values();</span><br><span class=\"line\">iterator = collection.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(iterator.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Hashtable-的介绍\"><a href=\"#Hashtable-的介绍\" class=\"headerlink\" title=\"Hashtable 的介绍\"></a>Hashtable 的介绍</h3><ul>\n<li>Hashtable 和 HashMap一样也是散列表，用来存储键值对</li>\n<li>Hashtable 继承自 Dictionary,实现了Map、Cloneable、java.io.Serializable接口</li>\n<li>可以进行克隆，支持序列化，能通过序列化去传输</li>\n<li>Hashtable 是线程同步的，所以它是线程安全的，多线程也可以使用</li>\n<li>Hashtable 的键key 和 值value都不可以是null,存储的映射也不是有序的</li>\n<li>Hashtable 的初始容量为11，扩充因子为0.75，扩充容量为：capacity * 2 + 1</li>\n</ul>\n<h3 id=\"Hashtable-的构造函数\"><a href=\"#Hashtable-的构造函数\" class=\"headerlink\" title=\"Hashtable 的构造函数\"></a>Hashtable 的构造函数</h3><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造函数 初始容量为11，扩充因子为0.75</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"number\">11</span>, <span class=\"number\">0.75</span>f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定初始容量的构造函数 扩充容量为 capacity * 2 + 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, <span class=\"number\">0.75</span>f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定初始容量和扩充因子的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Load: \"</span>+loadFactor);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity==<span class=\"number\">0</span>)</span><br><span class=\"line\">        initialCapacity = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定Map集合的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(Map&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(Math.max(<span class=\"number\">2</span>*t.size(), <span class=\"number\">11</span>), <span class=\"number\">0.75</span>f);</span><br><span class=\"line\">    putAll(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Hashtable-的遍历方法\"><a href=\"#Hashtable-的遍历方法\" class=\"headerlink\" title=\"Hashtable 的遍历方法\"></a>Hashtable 的遍历方法</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认初始化</span></span><br><span class=\"line\">Hashtable hashTable = <span class=\"keyword\">new</span> Hashtable();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加元素</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Jordan Zhang\"</span>);</span><br><span class=\"line\">hashTable.put(<span class=\"string\">\"gender\"</span>, <span class=\"string\">\"man\"</span>);</span><br><span class=\"line\">hashTable.put(<span class=\"string\">\"hobby\"</span>, <span class=\"string\">\"sports\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代器遍历键值对</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"迭代器遍历键值对\"</span>);</span><br><span class=\"line\">Iterator iterator = hashTable.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取key</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>) entry.getKey();</span><br><span class=\"line\">    <span class=\"comment\">// 获取value</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>) entry.getValue();</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过遍历键遍历</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过遍历键遍历\"</span>);</span><br><span class=\"line\">iterator = hashTable.keySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取key</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>) iterator.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取value</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>) hashTable.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过遍历值遍历 无法获取键key</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过遍历值遍历\"</span>);</span><br><span class=\"line\">Collection collection = hashTable.values();</span><br><span class=\"line\">iterator = collection.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(iterator.next());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过Enumeration遍历Hashtable的键</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过Enumeration遍历Hashtable的键\"</span>);</span><br><span class=\"line\">Enumeration keys = hashTable.keys();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(keys.hasMoreElements()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>) keys.nextElement();</span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>) hashTable.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过Enumeration遍历Hashtable的值 无法获取键key</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过Enumeration遍历Hashtable的值\"</span>);</span><br><span class=\"line\">Enumeration values = hashTable.elements();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (values.hasMoreElements()) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(values.nextElement());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HashMap和Hashtable的异同\"><a href=\"#HashMap和Hashtable的异同\" class=\"headerlink\" title=\"HashMap和Hashtable的异同\"></a>HashMap和Hashtable的异同</h3><p>HashMap和Hashtable都是实现了Map、Cloneable、java.io.Serializable接口，可以被克隆，支持序列化，能通过序列化去传输；但是HashMap继承自AbstractMap,Hashtable继承自Dictionary,Hashtable是线程安全的，HashMap不是。HashMap允许键或值为null，而Hashtable不允许。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Map集合</th>\n<th style=\"text-align:left\">HashMap</th>\n<th style=\"text-align:left\">Hashtable</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">继承父类</td>\n<td style=\"text-align:left\">AbstractMap</td>\n<td style=\"text-align:left\">Dictionary</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">实现接口</td>\n<td style=\"text-align:left\">Cloneable,Serializable</td>\n<td style=\"text-align:left\">Cloneable,Serializable</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">线程安全</td>\n<td style=\"text-align:left\">非线程安全</td>\n<td style=\"text-align:left\">线程安全</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">键值是否支持Null</td>\n<td style=\"text-align:left\">键或值可以是Null</td>\n<td style=\"text-align:left\">键和值不允许是Null</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提供contains方法</td>\n<td style=\"text-align:left\">没有</td>\n<td style=\"text-align:left\">有</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">初始容量</td>\n<td style=\"text-align:left\">默认16</td>\n<td style=\"text-align:left\">默认11</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">扩充容量</td>\n<td style=\"text-align:left\">capacity * 2</td>\n<td style=\"text-align:left\">capacity * 2 + 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">遍历实现</td>\n<td style=\"text-align:left\">使用了 Iterator</td>\n<td style=\"text-align:left\">使用了 Iterator、Enumeration</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">hash值</td>\n<td style=\"text-align:left\">直接使用对象的hashCode</td>\n<td style=\"text-align:left\">重新计算hash值</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>Java 集合框架中主要包含的容器类除了集合（Collection），另一种就是图（Map），主要用来存储键值对，其中最常用的就是HashMap,而HashMap和早期设计的Hashtable又有许多相似之处，所以经常将二者进行比较。</p>\n<h3 id=\"HashMap和Hashtable的继承关系\"><a href=\"#HashMap和Hashtable的继承关系\" class=\"headerlink\" title=\"HashMap和Hashtable的继承关系\"></a>HashMap和Hashtable的继承关系</h3><p>HashMap 继承自AbstractMap类，实现了Map、Cloneable、java.io.Serializable接口；而Hashtable继承自 Dictionary,同样实现了Map、Cloneable、java.io.Serializable接口。Hashtable是java一开始发布时就提供的键值映射的数据结构，而HashMap产生于JDK1.2。虽然Hashtable比HashMap出现的早一些，但是现在Hashtable基本上已经被弃用了。</p>","more":"<p><img src=\"/assets/img/mapDifferent.png\" alt=\"HashMap和Hashtable的继承关系\"></p>\n<h3 id=\"HashMap-介绍\"><a href=\"#HashMap-介绍\" class=\"headerlink\" title=\"HashMap 介绍\"></a>HashMap 介绍</h3><ul>\n<li>HashMap 是一个散列表，用于储存键值对</li>\n<li>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口</li>\n<li>可以被克隆，支持序列化，能通过序列化去传输</li>\n<li>HashMap 不是线程同步的，储存的键值对可以是null;但只能有一个键为null</li>\n<li>HashMap 默认初始值为16，扩充因子默认为0.75，扩充容量翻倍：capacity * 2</li>\n</ul>\n<h3 id=\"HashMap-的构造函数\"><a href=\"#HashMap-的构造函数\" class=\"headerlink\" title=\"HashMap 的构造函数\"></a>HashMap 的构造函数</h3><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造函数 默认初始容量为16</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all other fields defaulted</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定初始容量的构造函数 容量不足时会扩充为原来的2倍</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定初始容量和扩充因子的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定Map集合的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">    putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HashMap-的几种遍历方法\"><a href=\"#HashMap-的几种遍历方法\" class=\"headerlink\" title=\"HashMap 的几种遍历方法\"></a>HashMap 的几种遍历方法</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建初始化</span></span><br><span class=\"line\"><span class=\"keyword\">HashMap</span> hashMap = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加元素</span></span><br><span class=\"line\">hashMap.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Jordan Zhang\"</span>);</span><br><span class=\"line\">hashMap.put(<span class=\"string\">\"gender\"</span>, <span class=\"string\">\"man\"</span>);</span><br><span class=\"line\">hashMap.put(<span class=\"string\">\"hobby\"</span>, <span class=\"string\">\"sports\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代器遍历键值对</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"迭代器遍历键值对\"</span>);</span><br><span class=\"line\">Iterator iterator = hashMap.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry entry = (Map.Entry)iterator.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取key</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>)entry.getKey();</span><br><span class=\"line\">    <span class=\"comment\">// 获取value</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>)entry.getValue();</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过遍历键遍历 无法获取键key</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过遍历键遍历\"</span>);</span><br><span class=\"line\">iterator = hashMap.keySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取key</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>)iterator.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取value</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>)hashMap.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过遍历值遍历</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过遍历值遍历\"</span>);</span><br><span class=\"line\">Collection collection = hashMap.values();</span><br><span class=\"line\">iterator = collection.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(iterator.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Hashtable-的介绍\"><a href=\"#Hashtable-的介绍\" class=\"headerlink\" title=\"Hashtable 的介绍\"></a>Hashtable 的介绍</h3><ul>\n<li>Hashtable 和 HashMap一样也是散列表，用来存储键值对</li>\n<li>Hashtable 继承自 Dictionary,实现了Map、Cloneable、java.io.Serializable接口</li>\n<li>可以进行克隆，支持序列化，能通过序列化去传输</li>\n<li>Hashtable 是线程同步的，所以它是线程安全的，多线程也可以使用</li>\n<li>Hashtable 的键key 和 值value都不可以是null,存储的映射也不是有序的</li>\n<li>Hashtable 的初始容量为11，扩充因子为0.75，扩充容量为：capacity * 2 + 1</li>\n</ul>\n<h3 id=\"Hashtable-的构造函数\"><a href=\"#Hashtable-的构造函数\" class=\"headerlink\" title=\"Hashtable 的构造函数\"></a>Hashtable 的构造函数</h3><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造函数 初始容量为11，扩充因子为0.75</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"number\">11</span>, <span class=\"number\">0.75</span>f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定初始容量的构造函数 扩充容量为 capacity * 2 + 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, <span class=\"number\">0.75</span>f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定初始容量和扩充因子的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Load: \"</span>+loadFactor);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity==<span class=\"number\">0</span>)</span><br><span class=\"line\">        initialCapacity = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定Map集合的构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(Map&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(Math.max(<span class=\"number\">2</span>*t.size(), <span class=\"number\">11</span>), <span class=\"number\">0.75</span>f);</span><br><span class=\"line\">    putAll(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Hashtable-的遍历方法\"><a href=\"#Hashtable-的遍历方法\" class=\"headerlink\" title=\"Hashtable 的遍历方法\"></a>Hashtable 的遍历方法</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认初始化</span></span><br><span class=\"line\">Hashtable hashTable = <span class=\"keyword\">new</span> Hashtable();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加元素</span></span><br><span class=\"line\">hashTable.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Jordan Zhang\"</span>);</span><br><span class=\"line\">hashTable.put(<span class=\"string\">\"gender\"</span>, <span class=\"string\">\"man\"</span>);</span><br><span class=\"line\">hashTable.put(<span class=\"string\">\"hobby\"</span>, <span class=\"string\">\"sports\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代器遍历键值对</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"迭代器遍历键值对\"</span>);</span><br><span class=\"line\">Iterator iterator = hashTable.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取key</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>) entry.getKey();</span><br><span class=\"line\">    <span class=\"comment\">// 获取value</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>) entry.getValue();</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过遍历键遍历</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过遍历键遍历\"</span>);</span><br><span class=\"line\">iterator = hashTable.keySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取key</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>) iterator.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取value</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>) hashTable.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过遍历值遍历 无法获取键key</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过遍历值遍历\"</span>);</span><br><span class=\"line\">Collection collection = hashTable.values();</span><br><span class=\"line\">iterator = collection.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(iterator.next());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过Enumeration遍历Hashtable的键</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过Enumeration遍历Hashtable的键\"</span>);</span><br><span class=\"line\">Enumeration keys = hashTable.keys();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(keys.hasMoreElements()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> <span class=\"built_in\">key</span> = (<span class=\"keyword\">String</span>) keys.nextElement();</span><br><span class=\"line\">    <span class=\"keyword\">String</span> value = (<span class=\"keyword\">String</span>) hashTable.<span class=\"built_in\">get</span>(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"key: \"</span> + <span class=\"built_in\">key</span> + <span class=\"string\">\" value: \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过Enumeration遍历Hashtable的值 无法获取键key</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过Enumeration遍历Hashtable的值\"</span>);</span><br><span class=\"line\">Enumeration values = hashTable.elements();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (values.hasMoreElements()) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(values.nextElement());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HashMap和Hashtable的异同\"><a href=\"#HashMap和Hashtable的异同\" class=\"headerlink\" title=\"HashMap和Hashtable的异同\"></a>HashMap和Hashtable的异同</h3><p>HashMap和Hashtable都是实现了Map、Cloneable、java.io.Serializable接口，可以被克隆，支持序列化，能通过序列化去传输；但是HashMap继承自AbstractMap,Hashtable继承自Dictionary,Hashtable是线程安全的，HashMap不是。HashMap允许键或值为null，而Hashtable不允许。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Map集合</th>\n<th style=\"text-align:left\">HashMap</th>\n<th style=\"text-align:left\">Hashtable</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">继承父类</td>\n<td style=\"text-align:left\">AbstractMap</td>\n<td style=\"text-align:left\">Dictionary</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">实现接口</td>\n<td style=\"text-align:left\">Cloneable,Serializable</td>\n<td style=\"text-align:left\">Cloneable,Serializable</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">线程安全</td>\n<td style=\"text-align:left\">非线程安全</td>\n<td style=\"text-align:left\">线程安全</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">键值是否支持Null</td>\n<td style=\"text-align:left\">键或值可以是Null</td>\n<td style=\"text-align:left\">键和值不允许是Null</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提供contains方法</td>\n<td style=\"text-align:left\">没有</td>\n<td style=\"text-align:left\">有</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">初始容量</td>\n<td style=\"text-align:left\">默认16</td>\n<td style=\"text-align:left\">默认11</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">扩充容量</td>\n<td style=\"text-align:left\">capacity * 2</td>\n<td style=\"text-align:left\">capacity * 2 + 1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">遍历实现</td>\n<td style=\"text-align:left\">使用了 Iterator</td>\n<td style=\"text-align:left\">使用了 Iterator、Enumeration</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">hash值</td>\n<td style=\"text-align:left\">直接使用对象的hashCode</td>\n<td style=\"text-align:left\">重新计算hash值</td>\n</tr>\n</tbody>\n</table>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n<!--more-->\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: blog\ntags: [demo]\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\n<!--more-->\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-09-17T06:47:35.416Z","updated":"2018-09-18T10:10:17.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvim0007ogre1c01u6sd","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>","more":"<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"String类的底层实现和内存存储","date":"2018-09-24T14:01:17.000Z","toc":true,"_content":"### String 类的底层实现\n查看源码可以知道，String类的底层是使用数组实现的\n``` bash\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = -6849794470754667710L;\n\n```\n\n<!--more-->\n\n由于属于变量value是用final修饰的，所以String 类的值是不可变的，每次重新赋值其实只是将新的值得引用重新赋给了变量，也就是变量指向了新值得引用。\n```\nString str = \"java\";\nSystem.out.println(\"str改变前：\" + str.hashCode()); //str改变前：3254818\nstr = \"JAVA\";\nSystem.out.println(\"str改变后：\" + str.hashCode()); //str改变后：2269730\n```\n由于String 类的不可变性，所以String 类的相关方法并不是改变了原来对象的值，而是重新创建了一个新的对象返回，以substring方法为类：\n```\n/**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * <p>\n     * Examples:\n     * <blockquote><pre>\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * </pre></blockquote>\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @exception  IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        if (endIndex > value.length) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        int subLen = endIndex - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        return ((beginIndex == 0) && (endIndex == value.length)) ? this\n                : new String(value, beginIndex, subLen);\n    }\n```\nString 类对象值真的不可以改变吗？其实可以通过反射机制改变String 类对象的值\n```\nString test = \"changeValueTest\";\n\nSystem.out.println(\"test的值为： \" + test);//test的值为： changeValueTest\nSystem.out.println(\"test的hashcode为：\" + test.hashCode()); //test的hashcode为：-1027974189\n\n//获取String类声明的value字段\nField valueField = String.class.getDeclaredField(\"value\"); \n\n//修改value字段的访问权限\nvalueField.setAccessible(true);\n\n//获取test变量对应的value字段引用保存的数组\nchar [] val = (char []) valueField.get(test);\n\n//修改val数组的值，改为newValue\nString t = \"newValue\";\nchar [] n = t.toCharArray();\nfor (int i = 0; i < val.length; i++) {\n    if (i < n.length) {\n        val[i] = n[i];\n    } else {\n        val[i] = '\\n';\n    }\n}\n//test变量始终应用的是同一个String对象\n//但是对象已经发生了改变，说明可以通过反射实现修改String的值，但是我们一般不这样放\nSystem.out.println(\"test改变后的值为：\" + test); //test改变后的值为：newValue\nSystem.out.println(\"test的hashcode为：\" + test.hashCode()); //test的hashcode为：-1027974189\n```\n一般使用StringBuffer和StringBuilder做字符串的改变，它们的底层也是用数组实现的，但是并没有final修饰，所以可以改变字符串的值。\n```\nStringBuffer buffer = new StringBuffer(\"StringBuffer的特点：\");\nsb.append(\"线程安全\");\nSystem.out.println(buffer); //StringBuffer的特点：线程安全\nStringBuilder builder = new StringBuilder(\"StringBuilder的特点：\");\nsbu.append(\"速度快\");\nSystem.out.println(builder); //StringBuilder的特点：速度快\n```\nStringBuffer是线程安全的，因为它有Synchronized修饰的同步方法，StringBuilder不是线程安全的，但是StringBuilder速度更快，一般使用StringBuilder，强调线程安全时使用StringBuffer。\n```\n public final class StringBuffer\n    extends AbstractStringBuilder\n    implements java.io.Serializable, CharSequence\n{\n\n    /**\n     * A cache of the last value returned by toString. Cleared\n     * whenever the StringBuffer is modified.\n     */\n    private transient char[] toStringCache;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    static final long serialVersionUID = 3388685877147921107L;\n```\nStringBuffer的replace同步方法源码\n```\n  /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     * @since      1.2\n     */\n    @Override\n    public synchronized StringBuffer replace(int start, int end, String str) {\n        toStringCache = null;\n        super.replace(start, end, str);\n        return this;\n    }\n\n```\n### String内存存储\n\nString 类常用的两种赋值方法比较\n```\n    /**\n     * str1 = \"java\",jvm首先检查常量池中是否存在java字符串对象，不存在创建字符串，返回创建对象的内存地址\n     * str2 = \"java\",常量池中已经存在java字符串对象，直接返回对象的内存地址\n     */\n    String str1 = \"java\";\n    String str2 = \"java\";\n    /**\n     * str3 = new String(\"java\"),关键字new首先在堆内存创建java字符串对象，检查常量池中\n     * 是否已经存在java字符串对象，不存在则先创建然后把常量池中的对象内存地址赋值给对对象的引用，\n     * 存在就直接把常量池中的对象内存地址直接给堆内存对象引用，然后返回堆内存对象的内存地址。\n     * str3 -> 在常量池中找到了java对象 -> 堆内存保存常量池对象的内存地址 -> 返回堆内存地址\n     *\n     * str4 = new String(\"java\"),返回新的堆内存地址，只是堆内存中保存的还是常量池中的java对象的内存地址\n     */\n    String str3 = new String(\"java\");\n    String str4 = new String(\"java\");\n    \n    System.out.println(str1 == str2);\t\t//true\n    System.out.println(str1 == str3);\t\t//false\n    System.out.println(str3 == str4);\t\t//false\n    System.out.println(str3.equals(str4));\t//true\n    \n    //intern 方法可以返回该字符串在常量池中的对象的引用\n    String str5 = str3.intern();\n    String str6 = str4.intern();\n    System.out.println(\"str5 == str6: \" + (str5 == str6));\n```\n![String内存存储](/assets/img/string.png)\n为什么System.out.println(str3.equals(str4));这个返回的是true，是因为String类对equals方法进行了重写，新比较对象的内存地址，如果对象的内存地址不一致，在比较对象的值，str3和str4的值都是java所以相等返回true\n```\n /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\n","source":"_posts/2018-09-24-String类的底层实现和内存存储.md","raw":"---\ntitle: String类的底层实现和内存存储\ndate: 2018-09-24 22:01:17\ntoc: true\ntags:\n  - String\n  - blog\n---\n### String 类的底层实现\n查看源码可以知道，String类的底层是使用数组实现的\n``` bash\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = -6849794470754667710L;\n\n```\n\n<!--more-->\n\n由于属于变量value是用final修饰的，所以String 类的值是不可变的，每次重新赋值其实只是将新的值得引用重新赋给了变量，也就是变量指向了新值得引用。\n```\nString str = \"java\";\nSystem.out.println(\"str改变前：\" + str.hashCode()); //str改变前：3254818\nstr = \"JAVA\";\nSystem.out.println(\"str改变后：\" + str.hashCode()); //str改变后：2269730\n```\n由于String 类的不可变性，所以String 类的相关方法并不是改变了原来对象的值，而是重新创建了一个新的对象返回，以substring方法为类：\n```\n/**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * <p>\n     * Examples:\n     * <blockquote><pre>\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * </pre></blockquote>\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @exception  IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        if (beginIndex < 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        if (endIndex > value.length) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        int subLen = endIndex - beginIndex;\n        if (subLen < 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        return ((beginIndex == 0) && (endIndex == value.length)) ? this\n                : new String(value, beginIndex, subLen);\n    }\n```\nString 类对象值真的不可以改变吗？其实可以通过反射机制改变String 类对象的值\n```\nString test = \"changeValueTest\";\n\nSystem.out.println(\"test的值为： \" + test);//test的值为： changeValueTest\nSystem.out.println(\"test的hashcode为：\" + test.hashCode()); //test的hashcode为：-1027974189\n\n//获取String类声明的value字段\nField valueField = String.class.getDeclaredField(\"value\"); \n\n//修改value字段的访问权限\nvalueField.setAccessible(true);\n\n//获取test变量对应的value字段引用保存的数组\nchar [] val = (char []) valueField.get(test);\n\n//修改val数组的值，改为newValue\nString t = \"newValue\";\nchar [] n = t.toCharArray();\nfor (int i = 0; i < val.length; i++) {\n    if (i < n.length) {\n        val[i] = n[i];\n    } else {\n        val[i] = '\\n';\n    }\n}\n//test变量始终应用的是同一个String对象\n//但是对象已经发生了改变，说明可以通过反射实现修改String的值，但是我们一般不这样放\nSystem.out.println(\"test改变后的值为：\" + test); //test改变后的值为：newValue\nSystem.out.println(\"test的hashcode为：\" + test.hashCode()); //test的hashcode为：-1027974189\n```\n一般使用StringBuffer和StringBuilder做字符串的改变，它们的底层也是用数组实现的，但是并没有final修饰，所以可以改变字符串的值。\n```\nStringBuffer buffer = new StringBuffer(\"StringBuffer的特点：\");\nsb.append(\"线程安全\");\nSystem.out.println(buffer); //StringBuffer的特点：线程安全\nStringBuilder builder = new StringBuilder(\"StringBuilder的特点：\");\nsbu.append(\"速度快\");\nSystem.out.println(builder); //StringBuilder的特点：速度快\n```\nStringBuffer是线程安全的，因为它有Synchronized修饰的同步方法，StringBuilder不是线程安全的，但是StringBuilder速度更快，一般使用StringBuilder，强调线程安全时使用StringBuffer。\n```\n public final class StringBuffer\n    extends AbstractStringBuilder\n    implements java.io.Serializable, CharSequence\n{\n\n    /**\n     * A cache of the last value returned by toString. Cleared\n     * whenever the StringBuffer is modified.\n     */\n    private transient char[] toStringCache;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    static final long serialVersionUID = 3388685877147921107L;\n```\nStringBuffer的replace同步方法源码\n```\n  /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     * @since      1.2\n     */\n    @Override\n    public synchronized StringBuffer replace(int start, int end, String str) {\n        toStringCache = null;\n        super.replace(start, end, str);\n        return this;\n    }\n\n```\n### String内存存储\n\nString 类常用的两种赋值方法比较\n```\n    /**\n     * str1 = \"java\",jvm首先检查常量池中是否存在java字符串对象，不存在创建字符串，返回创建对象的内存地址\n     * str2 = \"java\",常量池中已经存在java字符串对象，直接返回对象的内存地址\n     */\n    String str1 = \"java\";\n    String str2 = \"java\";\n    /**\n     * str3 = new String(\"java\"),关键字new首先在堆内存创建java字符串对象，检查常量池中\n     * 是否已经存在java字符串对象，不存在则先创建然后把常量池中的对象内存地址赋值给对对象的引用，\n     * 存在就直接把常量池中的对象内存地址直接给堆内存对象引用，然后返回堆内存对象的内存地址。\n     * str3 -> 在常量池中找到了java对象 -> 堆内存保存常量池对象的内存地址 -> 返回堆内存地址\n     *\n     * str4 = new String(\"java\"),返回新的堆内存地址，只是堆内存中保存的还是常量池中的java对象的内存地址\n     */\n    String str3 = new String(\"java\");\n    String str4 = new String(\"java\");\n    \n    System.out.println(str1 == str2);\t\t//true\n    System.out.println(str1 == str3);\t\t//false\n    System.out.println(str3 == str4);\t\t//false\n    System.out.println(str3.equals(str4));\t//true\n    \n    //intern 方法可以返回该字符串在常量池中的对象的引用\n    String str5 = str3.intern();\n    String str6 = str4.intern();\n    System.out.println(\"str5 == str6: \" + (str5 == str6));\n```\n![String内存存储](/assets/img/string.png)\n为什么System.out.println(str3.equals(str4));这个返回的是true，是因为String类对equals方法进行了重写，新比较对象的内存地址，如果对象的内存地址不一致，在比较对象的值，str3和str4的值都是java所以相等返回true\n```\n /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\n","slug":"String类的底层实现和内存存储","published":1,"updated":"2018-09-24T15:28:49.593Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvj80010ogre6s296zuw","content":"<h3 id=\"String-类的底层实现\"><a href=\"#String-类的底层实现\" class=\"headerlink\" title=\"String 类的底层实现\"></a>String 类的底层实现</h3><p>查看源码可以知道，String类的底层是使用数组实现的<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\">    /** The value is used <span class=\"keyword\">for</span> character storage. */</span><br><span class=\"line\">    private final char value[];</span><br><span class=\"line\"></span><br><span class=\"line\">    /** Cache the <span class=\"built_in\">hash</span> code <span class=\"keyword\">for</span> the string */</span><br><span class=\"line\">    private int <span class=\"built_in\">hash</span>; // Default to 0</span><br><span class=\"line\"></span><br><span class=\"line\">    /** use serialVersionUID from JDK 1.0.2 <span class=\"keyword\">for</span> interoperability */</span><br><span class=\"line\">    private static final long serialVersionUID = -6849794470754667710L;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>由于属于变量value是用final修饰的，所以String 类的值是不可变的，每次重新赋值其实只是将新的值得引用重新赋给了变量，也就是变量指向了新值得引用。<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> <span class=\"built_in\">str</span> = <span class=\"string\">\"java\"</span>;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"str改变前：\"</span> + <span class=\"built_in\">str</span>.hashCode()); <span class=\"comment\">//str改变前：3254818</span></span><br><span class=\"line\"><span class=\"built_in\">str</span> = <span class=\"string\">\"JAVA\"</span>;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"str改变后：\"</span> + <span class=\"built_in\">str</span>.hashCode()); <span class=\"comment\">//str改变后：2269730</span></span><br></pre></td></tr></table></figure></p>\n<p>由于String 类的不可变性，所以String 类的相关方法并不是改变了原来对象的值，而是重新创建了一个新的对象返回，以substring方法为类：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a string that is a substring of this string. The</span></span><br><span class=\"line\"><span class=\"comment\">     * substring begins at the specified &#123;<span class=\"doctag\">@code</span> beginIndex&#125; and</span></span><br><span class=\"line\"><span class=\"comment\">     * extends to the character at index &#123;<span class=\"doctag\">@code</span> endIndex - 1&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * Thus the length of the substring is &#123;<span class=\"doctag\">@code</span> endIndex-beginIndex&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * Examples:</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * \"hamburger\".substring(4, 8) returns \"urge\"</span></span><br><span class=\"line\"><span class=\"comment\">     * \"smiles\".substring(1, 5) returns \"mile\"</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>      beginIndex   the beginning index, inclusive.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>      endIndex     the ending index, exclusive.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>     the specified substring.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@exception</span>  IndexOutOfBoundsException  if the</span></span><br><span class=\"line\"><span class=\"comment\">     *             &#123;<span class=\"doctag\">@code</span> beginIndex&#125; is negative, or</span></span><br><span class=\"line\"><span class=\"comment\">     *             &#123;<span class=\"doctag\">@code</span> endIndex&#125; is larger than the length of</span></span><br><span class=\"line\"><span class=\"comment\">     *             this &#123;<span class=\"doctag\">@code</span> String&#125; object, or</span></span><br><span class=\"line\"><span class=\"comment\">     *             &#123;<span class=\"doctag\">@code</span> beginIndex&#125; is larger than</span></span><br><span class=\"line\"><span class=\"comment\">     *             &#123;<span class=\"doctag\">@code</span> endIndex&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">String <span class=\"title\">substring</span><span class=\"params\">(<span class=\"keyword\">int</span> beginIndex, <span class=\"keyword\">int</span> endIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (beginIndex &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (endIndex &gt; value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> subLen = endIndex - beginIndex;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subLen &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((beginIndex == <span class=\"number\">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class=\"keyword\">this</span></span><br><span class=\"line\">                : <span class=\"keyword\">new</span> String(value, beginIndex, subLen);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>String 类对象值真的不可以改变吗？其实可以通过反射机制改变String 类对象的值<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String <span class=\"keyword\">test</span> = <span class=\"string\">\"changeValueTest\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"test的值为： \"</span> + <span class=\"keyword\">test</span>);<span class=\"comment\">//test的值为： changeValueTest</span></span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"test的hashcode为：\"</span> + <span class=\"keyword\">test</span>.hashCode()); <span class=\"comment\">//test的hashcode为：-1027974189</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取String类声明的value字段</span></span><br><span class=\"line\">Field valueField = String.<span class=\"keyword\">class</span>.getDeclaredField(<span class=\"string\">\"value\"</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改value字段的访问权限</span></span><br><span class=\"line\">valueField.setAccessible(true);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取test变量对应的value字段引用保存的数组</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> [] val = (<span class=\"keyword\">char</span> []) valueField.<span class=\"built_in\">get</span>(<span class=\"keyword\">test</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改val数组的值，改为newValue</span></span><br><span class=\"line\">String t = <span class=\"string\">\"newValue\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> [] <span class=\"keyword\">n</span> = t.toCharArray();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (int i = 0; i &lt; val.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"keyword\">n</span>.length) &#123;</span><br><span class=\"line\">        val[i] = <span class=\"keyword\">n</span>[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        val[i] = '\\<span class=\"keyword\">n</span>';</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//test变量始终应用的是同一个String对象</span></span><br><span class=\"line\"><span class=\"comment\">//但是对象已经发生了改变，说明可以通过反射实现修改String的值，但是我们一般不这样放</span></span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"test改变后的值为：\"</span> + <span class=\"keyword\">test</span>); <span class=\"comment\">//test改变后的值为：newValue</span></span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"test的hashcode为：\"</span> + <span class=\"keyword\">test</span>.hashCode()); <span class=\"comment\">//test的hashcode为：-1027974189</span></span><br></pre></td></tr></table></figure></p>\n<p>一般使用StringBuffer和StringBuilder做字符串的改变，它们的底层也是用数组实现的，但是并没有final修饰，所以可以改变字符串的值。<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuffer <span class=\"built_in\">buffer</span> = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"StringBuffer的特点：\"</span>);</span><br><span class=\"line\">sb.append(<span class=\"string\">\"线程安全\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"built_in\">buffer</span>); <span class=\"comment\">//StringBuffer的特点：线程安全</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"StringBuilder的特点：\"</span>);</span><br><span class=\"line\">sbu.append(<span class=\"string\">\"速度快\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(builder); <span class=\"comment\">//StringBuilder的特点：速度快</span></span><br></pre></td></tr></table></figure></p>\n<p>StringBuffer是线程安全的，因为它有Synchronized修饰的同步方法，StringBuilder不是线程安全的，但是StringBuilder速度更快，一般使用StringBuilder，强调线程安全时使用StringBuffer。<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringBuffer</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractStringBuilder</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">CharSequence</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * A cache of the last value returned by toString. Cleared</span></span><br><span class=\"line\"><span class=\"comment\">     * whenever the StringBuffer is modified.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> transient <span class=\"keyword\">char</span>[] toStringCache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">3388685877147921107</span>L;</span><br></pre></td></tr></table></figure></p>\n<p>StringBuffer的replace同步方法源码<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@throws</span> StringIndexOutOfBoundsException &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@since</span>      1.2</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"function\">StringBuffer <span class=\"title\">replace</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, String str)</span> </span>&#123;</span><br><span class=\"line\">      toStringCache = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.replace(start, end, str);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"String内存存储\"><a href=\"#String内存存储\" class=\"headerlink\" title=\"String内存存储\"></a>String内存存储</h3><p>String 类常用的两种赋值方法比较<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * str1 = \"java\",jvm首先检查常量池中是否存在java字符串对象，不存在创建字符串，返回创建对象的内存地址</span></span><br><span class=\"line\"><span class=\"comment\"> * str2 = \"java\",常量池中已经存在java字符串对象，直接返回对象的内存地址</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str1 </span>= <span class=\"string\">\"java\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str2 </span>= <span class=\"string\">\"java\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * str3 = new String(\"java\"),关键字new首先在堆内存创建java字符串对象，检查常量池中</span></span><br><span class=\"line\"><span class=\"comment\"> * 是否已经存在java字符串对象，不存在则先创建然后把常量池中的对象内存地址赋值给对对象的引用，</span></span><br><span class=\"line\"><span class=\"comment\"> * 存在就直接把常量池中的对象内存地址直接给堆内存对象引用，然后返回堆内存对象的内存地址。</span></span><br><span class=\"line\"><span class=\"comment\"> * str3 -&gt; 在常量池中找到了java对象 -&gt; 堆内存保存常量池对象的内存地址 -&gt; 返回堆内存地址</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * str4 = new String(\"java\"),返回新的堆内存地址，只是堆内存中保存的还是常量池中的java对象的内存地址</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str3 </span>= new <span class=\"keyword\">String(\"java\");</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str4 </span>= new <span class=\"keyword\">String(\"java\");</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">System.out.println(str1 </span>== <span class=\"keyword\">str2);\t</span>\t//true</span><br><span class=\"line\"><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str1 </span>== <span class=\"keyword\">str3);\t</span>\t//false</span><br><span class=\"line\"><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str3 </span>== <span class=\"keyword\">str4);\t</span>\t//false</span><br><span class=\"line\"><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str3.equals(str4));\t</span>//true</span><br><span class=\"line\"></span><br><span class=\"line\">//intern 方法可以返回该字符串在常量池中的对象的引用</span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str5 </span>= <span class=\"keyword\">str3.intern();</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str6 </span>= <span class=\"keyword\">str4.intern();</span></span><br><span class=\"line\"><span class=\"keyword\">System.out.println(\"str5 </span>== <span class=\"keyword\">str6: </span><span class=\"string\">\" + (str5 == str6));</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/assets/img/string.png\" alt=\"String内存存储\"><br>为什么System.out.println(str3.equals(str4));这个返回的是true，是因为String类对equals方法进行了重写，新比较对象的内存地址，如果对象的内存地址不一致，在比较对象的值，str3和str4的值都是java所以相等返回true<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * Compares this <span class=\"built_in\">string</span> <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> specified object.  The <span class=\"literal\">result</span> <span class=\"keyword\">is</span> &#123;@code</span><br><span class=\"line\">    * <span class=\"literal\">true</span>&#125; <span class=\"keyword\">if</span> <span class=\"keyword\">and</span> only <span class=\"keyword\">if</span> <span class=\"keyword\">the</span> argument <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> &#123;@code null&#125; <span class=\"keyword\">and</span> <span class=\"keyword\">is</span> a &#123;@code</span><br><span class=\"line\">    * String&#125; object <span class=\"keyword\">that</span> represents <span class=\"keyword\">the</span> same sequence <span class=\"keyword\">of</span> <span class=\"built_in\">characters</span> <span class=\"keyword\">as</span> this</span><br><span class=\"line\">    * object.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param  anObject</span><br><span class=\"line\">    *         The object <span class=\"keyword\">to</span> compare this &#123;@code String&#125; <span class=\"keyword\">against</span></span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @<span class=\"literal\">return</span>  &#123;@code <span class=\"literal\">true</span>&#125; <span class=\"keyword\">if</span> <span class=\"keyword\">the</span> <span class=\"keyword\">given</span> object represents a &#123;@code String&#125;</span><br><span class=\"line\">    *          equivalent <span class=\"keyword\">to</span> this <span class=\"built_in\">string</span>, &#123;@code <span class=\"literal\">false</span>&#125; otherwise</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @see  <span class=\"comment\">#compareTo(String)</span></span><br><span class=\"line\">    * @see  <span class=\"comment\">#equalsIgnoreCase(String)</span></span><br><span class=\"line\">    */</span><br><span class=\"line\">   public <span class=\"built_in\">boolean</span> <span class=\"keyword\">equals</span>(Object anObject) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (this == anObject) &#123;</span><br><span class=\"line\"><span class=\"built_in\">           return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (anObject instanceof String) &#123;</span><br><span class=\"line\">           String anotherString = (String)anObject;</span><br><span class=\"line\">           int n = value.<span class=\"built_in\">length</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (n == anotherString.value.<span class=\"built_in\">length</span>) &#123;</span><br><span class=\"line\">               char v1[] = value;</span><br><span class=\"line\">               char v2[] = anotherString.value;</span><br><span class=\"line\">               int i = <span class=\"number\">0</span>;</span><br><span class=\"line\">               <span class=\"keyword\">while</span> (n<span class=\"comment\">-- != 0) &#123;</span></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\"><span class=\"built_in\">                       return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                   i++;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"><span class=\"built_in\">               return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"><span class=\"built_in\">       return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"String-类的底层实现\"><a href=\"#String-类的底层实现\" class=\"headerlink\" title=\"String 类的底层实现\"></a>String 类的底层实现</h3><p>查看源码可以知道，String类的底层是使用数组实现的<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class String</span><br><span class=\"line\">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\">    /** The value is used <span class=\"keyword\">for</span> character storage. */</span><br><span class=\"line\">    private final char value[];</span><br><span class=\"line\"></span><br><span class=\"line\">    /** Cache the <span class=\"built_in\">hash</span> code <span class=\"keyword\">for</span> the string */</span><br><span class=\"line\">    private int <span class=\"built_in\">hash</span>; // Default to 0</span><br><span class=\"line\"></span><br><span class=\"line\">    /** use serialVersionUID from JDK 1.0.2 <span class=\"keyword\">for</span> interoperability */</span><br><span class=\"line\">    private static final long serialVersionUID = -6849794470754667710L;</span><br></pre></td></tr></table></figure></p>","more":"<p>由于属于变量value是用final修饰的，所以String 类的值是不可变的，每次重新赋值其实只是将新的值得引用重新赋给了变量，也就是变量指向了新值得引用。<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> <span class=\"built_in\">str</span> = <span class=\"string\">\"java\"</span>;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"str改变前：\"</span> + <span class=\"built_in\">str</span>.hashCode()); <span class=\"comment\">//str改变前：3254818</span></span><br><span class=\"line\"><span class=\"built_in\">str</span> = <span class=\"string\">\"JAVA\"</span>;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"str改变后：\"</span> + <span class=\"built_in\">str</span>.hashCode()); <span class=\"comment\">//str改变后：2269730</span></span><br></pre></td></tr></table></figure></p>\n<p>由于String 类的不可变性，所以String 类的相关方法并不是改变了原来对象的值，而是重新创建了一个新的对象返回，以substring方法为类：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a string that is a substring of this string. The</span></span><br><span class=\"line\"><span class=\"comment\">     * substring begins at the specified &#123;<span class=\"doctag\">@code</span> beginIndex&#125; and</span></span><br><span class=\"line\"><span class=\"comment\">     * extends to the character at index &#123;<span class=\"doctag\">@code</span> endIndex - 1&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * Thus the length of the substring is &#123;<span class=\"doctag\">@code</span> endIndex-beginIndex&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * Examples:</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * \"hamburger\".substring(4, 8) returns \"urge\"</span></span><br><span class=\"line\"><span class=\"comment\">     * \"smiles\".substring(1, 5) returns \"mile\"</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>      beginIndex   the beginning index, inclusive.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>      endIndex     the ending index, exclusive.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>     the specified substring.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@exception</span>  IndexOutOfBoundsException  if the</span></span><br><span class=\"line\"><span class=\"comment\">     *             &#123;<span class=\"doctag\">@code</span> beginIndex&#125; is negative, or</span></span><br><span class=\"line\"><span class=\"comment\">     *             &#123;<span class=\"doctag\">@code</span> endIndex&#125; is larger than the length of</span></span><br><span class=\"line\"><span class=\"comment\">     *             this &#123;<span class=\"doctag\">@code</span> String&#125; object, or</span></span><br><span class=\"line\"><span class=\"comment\">     *             &#123;<span class=\"doctag\">@code</span> beginIndex&#125; is larger than</span></span><br><span class=\"line\"><span class=\"comment\">     *             &#123;<span class=\"doctag\">@code</span> endIndex&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">String <span class=\"title\">substring</span><span class=\"params\">(<span class=\"keyword\">int</span> beginIndex, <span class=\"keyword\">int</span> endIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (beginIndex &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (endIndex &gt; value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> subLen = endIndex - beginIndex;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subLen &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((beginIndex == <span class=\"number\">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class=\"keyword\">this</span></span><br><span class=\"line\">                : <span class=\"keyword\">new</span> String(value, beginIndex, subLen);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>String 类对象值真的不可以改变吗？其实可以通过反射机制改变String 类对象的值<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String <span class=\"keyword\">test</span> = <span class=\"string\">\"changeValueTest\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"test的值为： \"</span> + <span class=\"keyword\">test</span>);<span class=\"comment\">//test的值为： changeValueTest</span></span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"test的hashcode为：\"</span> + <span class=\"keyword\">test</span>.hashCode()); <span class=\"comment\">//test的hashcode为：-1027974189</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取String类声明的value字段</span></span><br><span class=\"line\">Field valueField = String.<span class=\"keyword\">class</span>.getDeclaredField(<span class=\"string\">\"value\"</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改value字段的访问权限</span></span><br><span class=\"line\">valueField.setAccessible(true);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取test变量对应的value字段引用保存的数组</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> [] val = (<span class=\"keyword\">char</span> []) valueField.<span class=\"built_in\">get</span>(<span class=\"keyword\">test</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改val数组的值，改为newValue</span></span><br><span class=\"line\">String t = <span class=\"string\">\"newValue\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> [] <span class=\"keyword\">n</span> = t.toCharArray();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (int i = 0; i &lt; val.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"keyword\">n</span>.length) &#123;</span><br><span class=\"line\">        val[i] = <span class=\"keyword\">n</span>[i];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        val[i] = '\\<span class=\"keyword\">n</span>';</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//test变量始终应用的是同一个String对象</span></span><br><span class=\"line\"><span class=\"comment\">//但是对象已经发生了改变，说明可以通过反射实现修改String的值，但是我们一般不这样放</span></span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"test改变后的值为：\"</span> + <span class=\"keyword\">test</span>); <span class=\"comment\">//test改变后的值为：newValue</span></span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"test的hashcode为：\"</span> + <span class=\"keyword\">test</span>.hashCode()); <span class=\"comment\">//test的hashcode为：-1027974189</span></span><br></pre></td></tr></table></figure></p>\n<p>一般使用StringBuffer和StringBuilder做字符串的改变，它们的底层也是用数组实现的，但是并没有final修饰，所以可以改变字符串的值。<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuffer <span class=\"built_in\">buffer</span> = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"StringBuffer的特点：\"</span>);</span><br><span class=\"line\">sb.append(<span class=\"string\">\"线程安全\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"built_in\">buffer</span>); <span class=\"comment\">//StringBuffer的特点：线程安全</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"StringBuilder的特点：\"</span>);</span><br><span class=\"line\">sbu.append(<span class=\"string\">\"速度快\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(builder); <span class=\"comment\">//StringBuilder的特点：速度快</span></span><br></pre></td></tr></table></figure></p>\n<p>StringBuffer是线程安全的，因为它有Synchronized修饰的同步方法，StringBuilder不是线程安全的，但是StringBuilder速度更快，一般使用StringBuilder，强调线程安全时使用StringBuffer。<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringBuffer</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractStringBuilder</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">CharSequence</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * A cache of the last value returned by toString. Cleared</span></span><br><span class=\"line\"><span class=\"comment\">     * whenever the StringBuffer is modified.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> transient <span class=\"keyword\">char</span>[] toStringCache;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">3388685877147921107</span>L;</span><br></pre></td></tr></table></figure></p>\n<p>StringBuffer的replace同步方法源码<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@throws</span> StringIndexOutOfBoundsException &#123;<span class=\"doctag\">@inheritDoc</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@since</span>      1.2</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"function\">StringBuffer <span class=\"title\">replace</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, String str)</span> </span>&#123;</span><br><span class=\"line\">      toStringCache = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>.replace(start, end, str);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"String内存存储\"><a href=\"#String内存存储\" class=\"headerlink\" title=\"String内存存储\"></a>String内存存储</h3><p>String 类常用的两种赋值方法比较<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * str1 = \"java\",jvm首先检查常量池中是否存在java字符串对象，不存在创建字符串，返回创建对象的内存地址</span></span><br><span class=\"line\"><span class=\"comment\"> * str2 = \"java\",常量池中已经存在java字符串对象，直接返回对象的内存地址</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str1 </span>= <span class=\"string\">\"java\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str2 </span>= <span class=\"string\">\"java\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * str3 = new String(\"java\"),关键字new首先在堆内存创建java字符串对象，检查常量池中</span></span><br><span class=\"line\"><span class=\"comment\"> * 是否已经存在java字符串对象，不存在则先创建然后把常量池中的对象内存地址赋值给对对象的引用，</span></span><br><span class=\"line\"><span class=\"comment\"> * 存在就直接把常量池中的对象内存地址直接给堆内存对象引用，然后返回堆内存对象的内存地址。</span></span><br><span class=\"line\"><span class=\"comment\"> * str3 -&gt; 在常量池中找到了java对象 -&gt; 堆内存保存常量池对象的内存地址 -&gt; 返回堆内存地址</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * str4 = new String(\"java\"),返回新的堆内存地址，只是堆内存中保存的还是常量池中的java对象的内存地址</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str3 </span>= new <span class=\"keyword\">String(\"java\");</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str4 </span>= new <span class=\"keyword\">String(\"java\");</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">System.out.println(str1 </span>== <span class=\"keyword\">str2);\t</span>\t//true</span><br><span class=\"line\"><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str1 </span>== <span class=\"keyword\">str3);\t</span>\t//false</span><br><span class=\"line\"><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str3 </span>== <span class=\"keyword\">str4);\t</span>\t//false</span><br><span class=\"line\"><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str3.equals(str4));\t</span>//true</span><br><span class=\"line\"></span><br><span class=\"line\">//intern 方法可以返回该字符串在常量池中的对象的引用</span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str5 </span>= <span class=\"keyword\">str3.intern();</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str6 </span>= <span class=\"keyword\">str4.intern();</span></span><br><span class=\"line\"><span class=\"keyword\">System.out.println(\"str5 </span>== <span class=\"keyword\">str6: </span><span class=\"string\">\" + (str5 == str6));</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/assets/img/string.png\" alt=\"String内存存储\"><br>为什么System.out.println(str3.equals(str4));这个返回的是true，是因为String类对equals方法进行了重写，新比较对象的内存地址，如果对象的内存地址不一致，在比较对象的值，str3和str4的值都是java所以相等返回true<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    * Compares this <span class=\"built_in\">string</span> <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> specified object.  The <span class=\"literal\">result</span> <span class=\"keyword\">is</span> &#123;@code</span><br><span class=\"line\">    * <span class=\"literal\">true</span>&#125; <span class=\"keyword\">if</span> <span class=\"keyword\">and</span> only <span class=\"keyword\">if</span> <span class=\"keyword\">the</span> argument <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> &#123;@code null&#125; <span class=\"keyword\">and</span> <span class=\"keyword\">is</span> a &#123;@code</span><br><span class=\"line\">    * String&#125; object <span class=\"keyword\">that</span> represents <span class=\"keyword\">the</span> same sequence <span class=\"keyword\">of</span> <span class=\"built_in\">characters</span> <span class=\"keyword\">as</span> this</span><br><span class=\"line\">    * object.</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @param  anObject</span><br><span class=\"line\">    *         The object <span class=\"keyword\">to</span> compare this &#123;@code String&#125; <span class=\"keyword\">against</span></span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @<span class=\"literal\">return</span>  &#123;@code <span class=\"literal\">true</span>&#125; <span class=\"keyword\">if</span> <span class=\"keyword\">the</span> <span class=\"keyword\">given</span> object represents a &#123;@code String&#125;</span><br><span class=\"line\">    *          equivalent <span class=\"keyword\">to</span> this <span class=\"built_in\">string</span>, &#123;@code <span class=\"literal\">false</span>&#125; otherwise</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * @see  <span class=\"comment\">#compareTo(String)</span></span><br><span class=\"line\">    * @see  <span class=\"comment\">#equalsIgnoreCase(String)</span></span><br><span class=\"line\">    */</span><br><span class=\"line\">   public <span class=\"built_in\">boolean</span> <span class=\"keyword\">equals</span>(Object anObject) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (this == anObject) &#123;</span><br><span class=\"line\"><span class=\"built_in\">           return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (anObject instanceof String) &#123;</span><br><span class=\"line\">           String anotherString = (String)anObject;</span><br><span class=\"line\">           int n = value.<span class=\"built_in\">length</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (n == anotherString.value.<span class=\"built_in\">length</span>) &#123;</span><br><span class=\"line\">               char v1[] = value;</span><br><span class=\"line\">               char v2[] = anotherString.value;</span><br><span class=\"line\">               int i = <span class=\"number\">0</span>;</span><br><span class=\"line\">               <span class=\"keyword\">while</span> (n<span class=\"comment\">-- != 0) &#123;</span></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\"><span class=\"built_in\">                       return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                   i++;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"><span class=\"built_in\">               return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"><span class=\"built_in\">       return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"java内存分配解析","date":"2018-09-26T08:33:59.000Z","toc":true,"_content":"想要更好的开发java应用程序，必须清楚的了解java类的加载过程，以及内存分配机制，只有充分理解了这些知识点才能够开发高效可用的java程序。\n\n### java编译执行过程\n\n一个java程序编译执行过程，首先将java源文件（.java结尾）通过java编译器编译为字节码文件（.class结尾），然后由java虚拟机JVM中的类加载器加载各个类的字节码文件，加载完成后，再由JVM执行引擎将字节码文件转换为机器码执行，执行字节码转换时会对class文件进行检查，包括类型检查，数组越界检查，空指针检查等。整个执行过程中，JVM会占用一段内存空间用于存储执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存\n\n![java文件编译执行过程](/assets/img/javaCompiler.png)\n\n<!--more-->\n\n### 类加载器分类\n类加载器分为启动类加载器(不继承classLoader，属于虚拟机的一部分；负责加载原生代码实现的Java核心库,包括加载JAVA_HOME中jre/lib/rt.jar里所有的 class)；扩展类加载器(负责在JVM中扩展库目录中去寻找加载Java扩展库,包括JAVA_HOME中jre/lib/ext/xx.jar或-Djava.ext.dirs指定目录下的 jar 包)；应用程序类加载器(ClassLoader.getSystemClassLoader()负责加载Java类路径classpath中的类)\n\n![classLoader类加载器分类](/assets/img/classLoader.png)\n\n类的加载过程分为以下几个阶段：\n+ 加载：通过类的全限定名获取类的字节码文件，将静态数据加载进方法区的运行时数据区，在堆生成java.lang.Class对象，作为数据访问入口\n+ 验证：验证字节码字节流中的信息是否符合虚拟机要求，包括文件格式的验证、元数据的验证、字节码验证和符号引用验证。\n+ 准备：在方法区内给类成员变量分配空间，并进行初始化\n+ 解析：虚拟机将常量池中的符号引用转化为直接引用的过程\n+ 初始化：类的构造方法执行过程，主动进行类的初始化\n\n### java内存分区\n根据存储数据的不同，java内存分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。 \n\n![java内存分配区域图](/assets/img/cpuArea.png)\n\n#### 程序计数器\n 程序计数器是一块较小的区域，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码指示器就是通过改变程序计数器的值来指定下一条需要执行的指令。分支，循环等基础功能就是依赖程序计数器来完成的。由于java虚拟机的多线程是通过轮流切换并分配处理器执行时间来完成，一个处理器同一时间只会执行一条线程中的指令。为了线程恢复后能够恢复正确的执行位置，每条线程都需要一个独立的程序计数器，以确保线程之间互不影响。所以程序计数器是“线程私有”的内存。如果虚拟机正在执行的是一个Java方法，则计数器指定的是字节码指令对应的地址，如果正在执行的是一个本地方法，则计数器指定为空undefined。程序计数器区域是Java虚拟机中唯一没有定义OutOfMemory异常的区域。\n                                                                                                                                                                                                                                       \n#### 虚拟机栈\n和程序计数器一样也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。虚拟机栈是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。\n\n#### 本地方法栈\n存储本地方方法的调用状态，本地方法栈执行本地方法的服务，会抛出StackOverflowError和OutOfMemory异常。\n\n#### 堆内存\njava虚拟机管理的最大内存区域，用于存储对象实例，是所有线程共享的区域，Java堆可以是物理上不连续的空间，只要逻辑上连续即可，主流的虚拟机都是按照可扩展的方式来实现的。如果当前对中没有内存完成对象实例的创建，并且不能在进行内存扩展，则会抛出OutOfMemory异常，是GC垃圾回收器管理最主要的区域。\n\n#### 方法区\n当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，相对而言，垃圾收集行为在这个区域是比较少出现的（所以常量和静态变量的定义要多注意）。方法区的内存收集还是会出现，不过这个区域的内存收集主要是针对常量池的回收和对类型的卸载。\n\n常量池：运行时产量池，作为方法区中的一个特殊区域，用于存储编译器生成的各种字面量、符号引用和字符串常量，也是我们常说的常量池。\n\n### java对象创建及初始化\njava对象通过new关键字创建后会在堆内存中开辟一块内存空间用于存储对象实例，然后通过构造函数进行初始化，如果没有给出构造函数，系统会默认生成无参的构造函数调用，然后对类成员变量进行初始化，如果没有给值系统会根据类型给与默认初始值。\njava对象的初始化过程：初始化子类必先初始化其父类，初始化属性、方法必先初始化静态属性、方法，同类初始化顺序从上到下。\n1.先执行父类静态变量和静态代码块，再执行子类静态变量和静态代码块\n2.先执行父类普通变量和代码块，再执行父类构造器(static方法) \n3.先执行子类普通变量和代码块，再执行子类构造器(static方法) \n4.static方法初始化先于普通方法，静态初始化只有在必要时刻才进行且只初始化一次。\n\n### java对象访问\n```\nclass Car {\n\n    private String color;\n    \n    private String brand;\n    \n    private float price;\n    \n    public Car(String branch, String color, float price) {\n            this.branch = branch;\n            this.color = color;\n            this.price = price;\n    }\n    \n    public String getBranch() {\n            return branch;\n    }\n    \n    public void setBranch(String branch) {\n        this.branch = branch;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n}\n\npublic class Demo {\n\n    public static void main(String [] args) {\n        \n        Car myCar = new Car(\"bmw\", \"黑色的\", 540303.32f)\n        System.out.println(\"我的车是\" + myCar.getColor() + \"的，\" + \"品牌是\" + myCar.getBranch() + \"，花了\" + myCar.getPrice());\n    \n    }\n}\n```\n 由于reference类型在Java虚拟机中之规定了指向对象的引用，并没有规定这个引用要通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此虚拟机实现的对象访问方式会有所不同。主流的访问方式有两种：句柄访问方式和直接指针。\n \n 1.如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。\n![句柄访问](/assets/img/visit1.png)\n\n2.如果通过直接指针方式访问，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象的地址。\n![句柄访问](/assets/img/visit2.png)","source":"_posts/2018-09-26-java内存分配解析.md","raw":"---\ntitle: java内存分配解析\ndate: 2018-09-26 16:33:59\ntoc: true\ntags:\n  - java\n  - blog\n  - 内存分配\n---\n想要更好的开发java应用程序，必须清楚的了解java类的加载过程，以及内存分配机制，只有充分理解了这些知识点才能够开发高效可用的java程序。\n\n### java编译执行过程\n\n一个java程序编译执行过程，首先将java源文件（.java结尾）通过java编译器编译为字节码文件（.class结尾），然后由java虚拟机JVM中的类加载器加载各个类的字节码文件，加载完成后，再由JVM执行引擎将字节码文件转换为机器码执行，执行字节码转换时会对class文件进行检查，包括类型检查，数组越界检查，空指针检查等。整个执行过程中，JVM会占用一段内存空间用于存储执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存\n\n![java文件编译执行过程](/assets/img/javaCompiler.png)\n\n<!--more-->\n\n### 类加载器分类\n类加载器分为启动类加载器(不继承classLoader，属于虚拟机的一部分；负责加载原生代码实现的Java核心库,包括加载JAVA_HOME中jre/lib/rt.jar里所有的 class)；扩展类加载器(负责在JVM中扩展库目录中去寻找加载Java扩展库,包括JAVA_HOME中jre/lib/ext/xx.jar或-Djava.ext.dirs指定目录下的 jar 包)；应用程序类加载器(ClassLoader.getSystemClassLoader()负责加载Java类路径classpath中的类)\n\n![classLoader类加载器分类](/assets/img/classLoader.png)\n\n类的加载过程分为以下几个阶段：\n+ 加载：通过类的全限定名获取类的字节码文件，将静态数据加载进方法区的运行时数据区，在堆生成java.lang.Class对象，作为数据访问入口\n+ 验证：验证字节码字节流中的信息是否符合虚拟机要求，包括文件格式的验证、元数据的验证、字节码验证和符号引用验证。\n+ 准备：在方法区内给类成员变量分配空间，并进行初始化\n+ 解析：虚拟机将常量池中的符号引用转化为直接引用的过程\n+ 初始化：类的构造方法执行过程，主动进行类的初始化\n\n### java内存分区\n根据存储数据的不同，java内存分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。 \n\n![java内存分配区域图](/assets/img/cpuArea.png)\n\n#### 程序计数器\n 程序计数器是一块较小的区域，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码指示器就是通过改变程序计数器的值来指定下一条需要执行的指令。分支，循环等基础功能就是依赖程序计数器来完成的。由于java虚拟机的多线程是通过轮流切换并分配处理器执行时间来完成，一个处理器同一时间只会执行一条线程中的指令。为了线程恢复后能够恢复正确的执行位置，每条线程都需要一个独立的程序计数器，以确保线程之间互不影响。所以程序计数器是“线程私有”的内存。如果虚拟机正在执行的是一个Java方法，则计数器指定的是字节码指令对应的地址，如果正在执行的是一个本地方法，则计数器指定为空undefined。程序计数器区域是Java虚拟机中唯一没有定义OutOfMemory异常的区域。\n                                                                                                                                                                                                                                       \n#### 虚拟机栈\n和程序计数器一样也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。虚拟机栈是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。\n\n#### 本地方法栈\n存储本地方方法的调用状态，本地方法栈执行本地方法的服务，会抛出StackOverflowError和OutOfMemory异常。\n\n#### 堆内存\njava虚拟机管理的最大内存区域，用于存储对象实例，是所有线程共享的区域，Java堆可以是物理上不连续的空间，只要逻辑上连续即可，主流的虚拟机都是按照可扩展的方式来实现的。如果当前对中没有内存完成对象实例的创建，并且不能在进行内存扩展，则会抛出OutOfMemory异常，是GC垃圾回收器管理最主要的区域。\n\n#### 方法区\n当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，相对而言，垃圾收集行为在这个区域是比较少出现的（所以常量和静态变量的定义要多注意）。方法区的内存收集还是会出现，不过这个区域的内存收集主要是针对常量池的回收和对类型的卸载。\n\n常量池：运行时产量池，作为方法区中的一个特殊区域，用于存储编译器生成的各种字面量、符号引用和字符串常量，也是我们常说的常量池。\n\n### java对象创建及初始化\njava对象通过new关键字创建后会在堆内存中开辟一块内存空间用于存储对象实例，然后通过构造函数进行初始化，如果没有给出构造函数，系统会默认生成无参的构造函数调用，然后对类成员变量进行初始化，如果没有给值系统会根据类型给与默认初始值。\njava对象的初始化过程：初始化子类必先初始化其父类，初始化属性、方法必先初始化静态属性、方法，同类初始化顺序从上到下。\n1.先执行父类静态变量和静态代码块，再执行子类静态变量和静态代码块\n2.先执行父类普通变量和代码块，再执行父类构造器(static方法) \n3.先执行子类普通变量和代码块，再执行子类构造器(static方法) \n4.static方法初始化先于普通方法，静态初始化只有在必要时刻才进行且只初始化一次。\n\n### java对象访问\n```\nclass Car {\n\n    private String color;\n    \n    private String brand;\n    \n    private float price;\n    \n    public Car(String branch, String color, float price) {\n            this.branch = branch;\n            this.color = color;\n            this.price = price;\n    }\n    \n    public String getBranch() {\n            return branch;\n    }\n    \n    public void setBranch(String branch) {\n        this.branch = branch;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n}\n\npublic class Demo {\n\n    public static void main(String [] args) {\n        \n        Car myCar = new Car(\"bmw\", \"黑色的\", 540303.32f)\n        System.out.println(\"我的车是\" + myCar.getColor() + \"的，\" + \"品牌是\" + myCar.getBranch() + \"，花了\" + myCar.getPrice());\n    \n    }\n}\n```\n 由于reference类型在Java虚拟机中之规定了指向对象的引用，并没有规定这个引用要通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此虚拟机实现的对象访问方式会有所不同。主流的访问方式有两种：句柄访问方式和直接指针。\n \n 1.如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。\n![句柄访问](/assets/img/visit1.png)\n\n2.如果通过直接指针方式访问，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象的地址。\n![句柄访问](/assets/img/visit2.png)","slug":"java内存分配解析","published":1,"updated":"2018-09-26T15:52:05.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvjb0011ogreeucqqosy","content":"<p>想要更好的开发java应用程序，必须清楚的了解java类的加载过程，以及内存分配机制，只有充分理解了这些知识点才能够开发高效可用的java程序。</p>\n<h3 id=\"java编译执行过程\"><a href=\"#java编译执行过程\" class=\"headerlink\" title=\"java编译执行过程\"></a>java编译执行过程</h3><p>一个java程序编译执行过程，首先将java源文件（.java结尾）通过java编译器编译为字节码文件（.class结尾），然后由java虚拟机JVM中的类加载器加载各个类的字节码文件，加载完成后，再由JVM执行引擎将字节码文件转换为机器码执行，执行字节码转换时会对class文件进行检查，包括类型检查，数组越界检查，空指针检查等。整个执行过程中，JVM会占用一段内存空间用于存储执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存</p>\n<p><img src=\"/assets/img/javaCompiler.png\" alt=\"java文件编译执行过程\"></p>\n<a id=\"more\"></a>\n<h3 id=\"类加载器分类\"><a href=\"#类加载器分类\" class=\"headerlink\" title=\"类加载器分类\"></a>类加载器分类</h3><p>类加载器分为启动类加载器(不继承classLoader，属于虚拟机的一部分；负责加载原生代码实现的Java核心库,包括加载JAVA_HOME中jre/lib/rt.jar里所有的 class)；扩展类加载器(负责在JVM中扩展库目录中去寻找加载Java扩展库,包括JAVA_HOME中jre/lib/ext/xx.jar或-Djava.ext.dirs指定目录下的 jar 包)；应用程序类加载器(ClassLoader.getSystemClassLoader()负责加载Java类路径classpath中的类)</p>\n<p><img src=\"/assets/img/classLoader.png\" alt=\"classLoader类加载器分类\"></p>\n<p>类的加载过程分为以下几个阶段：</p>\n<ul>\n<li>加载：通过类的全限定名获取类的字节码文件，将静态数据加载进方法区的运行时数据区，在堆生成java.lang.Class对象，作为数据访问入口</li>\n<li>验证：验证字节码字节流中的信息是否符合虚拟机要求，包括文件格式的验证、元数据的验证、字节码验证和符号引用验证。</li>\n<li>准备：在方法区内给类成员变量分配空间，并进行初始化</li>\n<li>解析：虚拟机将常量池中的符号引用转化为直接引用的过程</li>\n<li>初始化：类的构造方法执行过程，主动进行类的初始化</li>\n</ul>\n<h3 id=\"java内存分区\"><a href=\"#java内存分区\" class=\"headerlink\" title=\"java内存分区\"></a>java内存分区</h3><p>根据存储数据的不同，java内存分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。 </p>\n<p><img src=\"/assets/img/cpuArea.png\" alt=\"java内存分配区域图\"></p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p> 程序计数器是一块较小的区域，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码指示器就是通过改变程序计数器的值来指定下一条需要执行的指令。分支，循环等基础功能就是依赖程序计数器来完成的。由于java虚拟机的多线程是通过轮流切换并分配处理器执行时间来完成，一个处理器同一时间只会执行一条线程中的指令。为了线程恢复后能够恢复正确的执行位置，每条线程都需要一个独立的程序计数器，以确保线程之间互不影响。所以程序计数器是“线程私有”的内存。如果虚拟机正在执行的是一个Java方法，则计数器指定的是字节码指令对应的地址，如果正在执行的是一个本地方法，则计数器指定为空undefined。程序计数器区域是Java虚拟机中唯一没有定义OutOfMemory异常的区域。</p>\n<h4 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h4><p>和程序计数器一样也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。虚拟机栈是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>存储本地方方法的调用状态，本地方法栈执行本地方法的服务，会抛出StackOverflowError和OutOfMemory异常。</p>\n<h4 id=\"堆内存\"><a href=\"#堆内存\" class=\"headerlink\" title=\"堆内存\"></a>堆内存</h4><p>java虚拟机管理的最大内存区域，用于存储对象实例，是所有线程共享的区域，Java堆可以是物理上不连续的空间，只要逻辑上连续即可，主流的虚拟机都是按照可扩展的方式来实现的。如果当前对中没有内存完成对象实例的创建，并且不能在进行内存扩展，则会抛出OutOfMemory异常，是GC垃圾回收器管理最主要的区域。</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><p>当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，相对而言，垃圾收集行为在这个区域是比较少出现的（所以常量和静态变量的定义要多注意）。方法区的内存收集还是会出现，不过这个区域的内存收集主要是针对常量池的回收和对类型的卸载。</p>\n<p>常量池：运行时产量池，作为方法区中的一个特殊区域，用于存储编译器生成的各种字面量、符号引用和字符串常量，也是我们常说的常量池。</p>\n<h3 id=\"java对象创建及初始化\"><a href=\"#java对象创建及初始化\" class=\"headerlink\" title=\"java对象创建及初始化\"></a>java对象创建及初始化</h3><p>java对象通过new关键字创建后会在堆内存中开辟一块内存空间用于存储对象实例，然后通过构造函数进行初始化，如果没有给出构造函数，系统会默认生成无参的构造函数调用，然后对类成员变量进行初始化，如果没有给值系统会根据类型给与默认初始值。<br>java对象的初始化过程：初始化子类必先初始化其父类，初始化属性、方法必先初始化静态属性、方法，同类初始化顺序从上到下。<br>1.先执行父类静态变量和静态代码块，再执行子类静态变量和静态代码块<br>2.先执行父类普通变量和代码块，再执行父类构造器(static方法)<br>3.先执行子类普通变量和代码块，再执行子类构造器(static方法)<br>4.static方法初始化先于普通方法，静态初始化只有在必要时刻才进行且只初始化一次。</p>\n<h3 id=\"java对象访问\"><a href=\"#java对象访问\" class=\"headerlink\" title=\"java对象访问\"></a>java对象访问</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Car &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> <span class=\"built_in\">color</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> brand;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> price;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Car(<span class=\"keyword\">String</span> branch, <span class=\"keyword\">String</span> <span class=\"built_in\">color</span>, <span class=\"built_in\">float</span> price) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.branch = branch;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.<span class=\"built_in\">color</span> = <span class=\"built_in\">color</span>;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getBranch() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> branch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setBranch(<span class=\"keyword\">String</span> branch) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.branch = branch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getColor() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">color</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setColor(<span class=\"keyword\">String</span> <span class=\"built_in\">color</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"built_in\">color</span> = <span class=\"built_in\">color</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> getPrice() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setPrice(<span class=\"built_in\">float</span> price) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> class Demo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span> [] args) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Car myCar = <span class=\"keyword\">new</span> Car(<span class=\"string\">\"bmw\"</span>, <span class=\"string\">\"黑色的\"</span>, <span class=\"number\">540303.32</span>f)</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"我的车是\"</span> + myCar.getColor() + <span class=\"string\">\"的，\"</span> + <span class=\"string\">\"品牌是\"</span> + myCar.getBranch() + <span class=\"string\">\"，花了\"</span> + myCar.getPrice());</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 由于reference类型在Java虚拟机中之规定了指向对象的引用，并没有规定这个引用要通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此虚拟机实现的对象访问方式会有所不同。主流的访问方式有两种：句柄访问方式和直接指针。</p>\n<p> 1.如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。<br><img src=\"/assets/img/visit1.png\" alt=\"句柄访问\"></p>\n<p>2.如果通过直接指针方式访问，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象的地址。<br><img src=\"/assets/img/visit2.png\" alt=\"句柄访问\"></p>\n","site":{"data":{}},"excerpt":"<p>想要更好的开发java应用程序，必须清楚的了解java类的加载过程，以及内存分配机制，只有充分理解了这些知识点才能够开发高效可用的java程序。</p>\n<h3 id=\"java编译执行过程\"><a href=\"#java编译执行过程\" class=\"headerlink\" title=\"java编译执行过程\"></a>java编译执行过程</h3><p>一个java程序编译执行过程，首先将java源文件（.java结尾）通过java编译器编译为字节码文件（.class结尾），然后由java虚拟机JVM中的类加载器加载各个类的字节码文件，加载完成后，再由JVM执行引擎将字节码文件转换为机器码执行，执行字节码转换时会对class文件进行检查，包括类型检查，数组越界检查，空指针检查等。整个执行过程中，JVM会占用一段内存空间用于存储执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存</p>\n<p><img src=\"/assets/img/javaCompiler.png\" alt=\"java文件编译执行过程\"></p>","more":"<h3 id=\"类加载器分类\"><a href=\"#类加载器分类\" class=\"headerlink\" title=\"类加载器分类\"></a>类加载器分类</h3><p>类加载器分为启动类加载器(不继承classLoader，属于虚拟机的一部分；负责加载原生代码实现的Java核心库,包括加载JAVA_HOME中jre/lib/rt.jar里所有的 class)；扩展类加载器(负责在JVM中扩展库目录中去寻找加载Java扩展库,包括JAVA_HOME中jre/lib/ext/xx.jar或-Djava.ext.dirs指定目录下的 jar 包)；应用程序类加载器(ClassLoader.getSystemClassLoader()负责加载Java类路径classpath中的类)</p>\n<p><img src=\"/assets/img/classLoader.png\" alt=\"classLoader类加载器分类\"></p>\n<p>类的加载过程分为以下几个阶段：</p>\n<ul>\n<li>加载：通过类的全限定名获取类的字节码文件，将静态数据加载进方法区的运行时数据区，在堆生成java.lang.Class对象，作为数据访问入口</li>\n<li>验证：验证字节码字节流中的信息是否符合虚拟机要求，包括文件格式的验证、元数据的验证、字节码验证和符号引用验证。</li>\n<li>准备：在方法区内给类成员变量分配空间，并进行初始化</li>\n<li>解析：虚拟机将常量池中的符号引用转化为直接引用的过程</li>\n<li>初始化：类的构造方法执行过程，主动进行类的初始化</li>\n</ul>\n<h3 id=\"java内存分区\"><a href=\"#java内存分区\" class=\"headerlink\" title=\"java内存分区\"></a>java内存分区</h3><p>根据存储数据的不同，java内存分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。 </p>\n<p><img src=\"/assets/img/cpuArea.png\" alt=\"java内存分配区域图\"></p>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p> 程序计数器是一块较小的区域，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码指示器就是通过改变程序计数器的值来指定下一条需要执行的指令。分支，循环等基础功能就是依赖程序计数器来完成的。由于java虚拟机的多线程是通过轮流切换并分配处理器执行时间来完成，一个处理器同一时间只会执行一条线程中的指令。为了线程恢复后能够恢复正确的执行位置，每条线程都需要一个独立的程序计数器，以确保线程之间互不影响。所以程序计数器是“线程私有”的内存。如果虚拟机正在执行的是一个Java方法，则计数器指定的是字节码指令对应的地址，如果正在执行的是一个本地方法，则计数器指定为空undefined。程序计数器区域是Java虚拟机中唯一没有定义OutOfMemory异常的区域。</p>\n<h4 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h4><p>和程序计数器一样也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。虚拟机栈是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>存储本地方方法的调用状态，本地方法栈执行本地方法的服务，会抛出StackOverflowError和OutOfMemory异常。</p>\n<h4 id=\"堆内存\"><a href=\"#堆内存\" class=\"headerlink\" title=\"堆内存\"></a>堆内存</h4><p>java虚拟机管理的最大内存区域，用于存储对象实例，是所有线程共享的区域，Java堆可以是物理上不连续的空间，只要逻辑上连续即可，主流的虚拟机都是按照可扩展的方式来实现的。如果当前对中没有内存完成对象实例的创建，并且不能在进行内存扩展，则会抛出OutOfMemory异常，是GC垃圾回收器管理最主要的区域。</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><p>当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，相对而言，垃圾收集行为在这个区域是比较少出现的（所以常量和静态变量的定义要多注意）。方法区的内存收集还是会出现，不过这个区域的内存收集主要是针对常量池的回收和对类型的卸载。</p>\n<p>常量池：运行时产量池，作为方法区中的一个特殊区域，用于存储编译器生成的各种字面量、符号引用和字符串常量，也是我们常说的常量池。</p>\n<h3 id=\"java对象创建及初始化\"><a href=\"#java对象创建及初始化\" class=\"headerlink\" title=\"java对象创建及初始化\"></a>java对象创建及初始化</h3><p>java对象通过new关键字创建后会在堆内存中开辟一块内存空间用于存储对象实例，然后通过构造函数进行初始化，如果没有给出构造函数，系统会默认生成无参的构造函数调用，然后对类成员变量进行初始化，如果没有给值系统会根据类型给与默认初始值。<br>java对象的初始化过程：初始化子类必先初始化其父类，初始化属性、方法必先初始化静态属性、方法，同类初始化顺序从上到下。<br>1.先执行父类静态变量和静态代码块，再执行子类静态变量和静态代码块<br>2.先执行父类普通变量和代码块，再执行父类构造器(static方法)<br>3.先执行子类普通变量和代码块，再执行子类构造器(static方法)<br>4.static方法初始化先于普通方法，静态初始化只有在必要时刻才进行且只初始化一次。</p>\n<h3 id=\"java对象访问\"><a href=\"#java对象访问\" class=\"headerlink\" title=\"java对象访问\"></a>java对象访问</h3><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Car &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> <span class=\"built_in\">color</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> brand;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> price;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Car(<span class=\"keyword\">String</span> branch, <span class=\"keyword\">String</span> <span class=\"built_in\">color</span>, <span class=\"built_in\">float</span> price) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.branch = branch;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.<span class=\"built_in\">color</span> = <span class=\"built_in\">color</span>;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getBranch() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> branch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setBranch(<span class=\"keyword\">String</span> branch) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.branch = branch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getColor() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">color</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setColor(<span class=\"keyword\">String</span> <span class=\"built_in\">color</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"built_in\">color</span> = <span class=\"built_in\">color</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> getPrice() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setPrice(<span class=\"built_in\">float</span> price) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> class Demo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span> [] args) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Car myCar = <span class=\"keyword\">new</span> Car(<span class=\"string\">\"bmw\"</span>, <span class=\"string\">\"黑色的\"</span>, <span class=\"number\">540303.32</span>f)</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"我的车是\"</span> + myCar.getColor() + <span class=\"string\">\"的，\"</span> + <span class=\"string\">\"品牌是\"</span> + myCar.getBranch() + <span class=\"string\">\"，花了\"</span> + myCar.getPrice());</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 由于reference类型在Java虚拟机中之规定了指向对象的引用，并没有规定这个引用要通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此虚拟机实现的对象访问方式会有所不同。主流的访问方式有两种：句柄访问方式和直接指针。</p>\n<p> 1.如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。<br><img src=\"/assets/img/visit1.png\" alt=\"句柄访问\"></p>\n<p>2.如果通过直接指针方式访问，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象的地址。<br><img src=\"/assets/img/visit2.png\" alt=\"句柄访问\"></p>"},{"title":"java GC垃圾回收机制浅析","date":"2018-09-28T07:38:55.000Z","toc":true,"_content":"java GC(Garbage Collection 垃圾回收)机制是java语言与C、C++语言的区别之一，java程序员不用主动管理内存，而完全交给了GC去处理，至于到底什么时候执行GC也不是由程序员控制的，而是由java的GC线程去处理，虽然无法控制GC，但是了解GC的机制和工作原理，对于开发健壮可用的应用程序很有帮助。\n\n### 分代内存\njava GC主要是发生在堆内存中，而堆内存往往是new对象发生的地方，根据对象实例存货时间将堆内存主要划分成了两个区域，新生代（Young Generation）和老年代（Old Generation）。\n\n![GC分代图](/assets/img/GC.png)\n\n<!--more-->\n\n#### 年轻代 Young Generation\n对象被创建时，内存分配首先发生在年轻代（大对象直接进入老年代），大部分对象很快变得不可用，于是会被年轻代的GC机制清理掉。年轻代分为三个区域，按照8:1:1的比例划分，其中伊甸园Eden区域最大，对象创建时首先会被分配到这个区域，当发生GC时会将还在引用的对象依次移动到Survivor区域，没有引用的对象内存则被回收。\n\n![年轻代GC](/assets/img/young.png)\n\n1.绝大多数对象实例创建时分配在Eden伊甸园，其中大多数对象实例会很快消失，不在被引用。Eden内存是连续的所以分配速度很快。\n\n2.最初依次，当Eden伊甸园的内存空间被占满时，年轻代的会执行GC机制Minor GC，清理掉不被引用的对象实例，释放内存，而还在引用的存活实例会被复制到Survivor 1的内存空间，此时Survivor 2的内存空间还是空的。\n\n3.下次Eden伊甸园空间占满时，再次执行Minor GC,将存活的复制移动到Survivor 2中，清空Eden伊甸园的内存空间。\n\n4.将Survivor 1中不被引用的对象实例清理掉，还存活的实例复制到Survivor 2中，清空Survivor 1的内存空间。\n\n5.当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。\n\n#### 老年代 Old Generation\n对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）.\n\n#### 永久代 Permanent Generation\n永久代也就是我们常说的方法区，方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。方法区也是物理连续的内存空间，这里的垃圾回收发生的很少，主要是针对常量池的内存回收和对已加载类的卸载。由于方法区回收垃圾条件苛刻困难，效果也不尽人意，所以JDK1.8版本已经取消了永久代。\n\n### 对象引用判断\n所有垃圾回收都面临这样的问题，就是如何判断对象不再被引用，只有对象不再被引用，才能释放它所占用的内存空间，达到清理垃圾整理内存的目的。\n\n#### 引用计数法\n引用计数法是最直接简单的方法计算对象是否还在被引用，简单来说就是为每个对象增加一个引用计数，当对象增加一个引用的时候引用计数加1，相反的当这个对象的一个引用被释放时减1，如果当对象的引用计数变为0时，表示这个对象已经没有被引用。\n\n+ 优点：简单，直接，不需要暂停整个应用。\n+ 缺点：需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作；存在循环引用的问题。\n\n#### 可达性算法\n在Java中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。\n\n在java中，可以作为GC Root的对象有：\n+ 虚拟机栈（栈帧中的本地变量表）中的引用对象\n+ 方法区中静态属性引用的对象\n+ 方法区中常量引用的对象\n+ 本地方法栈中JNI本地方法的引用对象。\n \n### 垃圾回收算法\n#### 标记清理法 Mark-Sweep\n标记清理法是最简单也是最容易实现的，分为两个阶段，标记阶段从根集合开始扫描，标记所有存活对象，清理阶段再次扫描整个内存空间，清理没有标记的内存空间。这个算法容易实现，但是也容易产生内存碎片，而内存碎片过多会导致后续给大对象分配空间时没有可用的空间导致提前出发新的垃圾回收动作。\n \n![标记清理法](/assets/img/markSweep.png)\n \n#### 复制算法 Copying\n为了解决标记清理算法产生的内存碎片问题，复制算法被提出使用，使用原理是将可用内存空间分成大小相等的两份，每次只使用一份，当一份的空间被使用完之后，将所有存活的对象复制到另一份没有使用的内存中，然后清理之前使用过的内存空间，这样就不会产生内存碎片。\n \n![复制算法](/assets/img/copying.png)\n\n#### 标记整理法 Mark-Compact\n标记整理法是解决标记清理法产生内存碎片的另一个算法，和标记清理法一样分为两个阶段，首先标记存活对象，然后将存活对象向一段移动，然后清理掉没有被标记的内存。\n\n![标记整理法](/assets/img/markCompact.png)\n  \n### 垃圾回收器\n根据年轻代和老年代的垃圾回收算法不同，垃圾回收器也分为年轻代收集器和老年代收集器。其中新生代收集器主要有Serial收集器、ParNew收集器和Parallel Scavenge收集器。老年代收集器主要有Serial Old收集器、Parallel Old收集器和CMS收集器。当然还包括了一款全新的、新生代老年代通用的G1收集器。各款收集器的搭配使用如下图所示，其中有连线的代表收集器可以搭配使用，没有连线的收集器表示不能搭配使用。\n\n![垃圾收集器示意图](/assets/img/collector.png)\n\n#### 串行收集器（Serial Collector）\n作用于年轻代，单线程进行GC，需要先停止其他线程，也就是常说的stop the world，当年轻代的Eden伊甸园内存空间不足时发生。\n\n#### ParNew（Serial 收集器的多线程版本）\n是 Serial 的多线程版，是 Server 模式下的虚拟机中首选的新生代收集器，不是默认收集器。同样需要停止其他线程。\n\n#### 并行收集器（Parallel Scavenge）\n并行线程，自适应调整策略，如果把该策略打开，则虚拟机会自动调整新生代的大小比例和晋升老年代的对象大小、年龄等细节参数，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算。\n\n#### Serial Old\n是 Serial 收集器的老年代版本，依旧是单线程收集器，采用标记-整理算法，在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。\n\n#### Parallel Old\n多线程并行，作用于老年代，与Parallel Scavenge类似，使用标记整理算法，不过不同之处在于会将幸存的对象复制到预先准备好的区域，而不是向内存一段移动。\n\n#### CMS（并发-标记-清除）\nCMS(Concurrent Mark Sweep)是并发收集的老年代收集器。以获取最短回收停顿时间为目标，采用多线程并发以及标记-清除算法来实现垃圾回收。CMS只在初始化标记和重新标记阶段需要挂起用户线程,造成一定的应用停顿(STW)，而其他阶段收集线程都可以与用户线程并发交替进行，不必挂起用户线程，所以并不会造成应用的停顿。CMS收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。\n\n#### G1\nG1收集器把 Heap 分为多个大小相等的 Region，G1可以有计划的避免进行全区域的垃圾收集。G1跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值大的 Regin，保证 G1收集器在有限时间内获取最大的收集效率。\n\n","source":"_posts/2018-09-28-java-GC垃圾回收机制浅析.md","raw":"---\ntitle: java GC垃圾回收机制浅析\ndate: 2018-09-28 15:38:55\ntoc: true\ntags:\n  - java\n  - blog\n  - GC\n---\njava GC(Garbage Collection 垃圾回收)机制是java语言与C、C++语言的区别之一，java程序员不用主动管理内存，而完全交给了GC去处理，至于到底什么时候执行GC也不是由程序员控制的，而是由java的GC线程去处理，虽然无法控制GC，但是了解GC的机制和工作原理，对于开发健壮可用的应用程序很有帮助。\n\n### 分代内存\njava GC主要是发生在堆内存中，而堆内存往往是new对象发生的地方，根据对象实例存货时间将堆内存主要划分成了两个区域，新生代（Young Generation）和老年代（Old Generation）。\n\n![GC分代图](/assets/img/GC.png)\n\n<!--more-->\n\n#### 年轻代 Young Generation\n对象被创建时，内存分配首先发生在年轻代（大对象直接进入老年代），大部分对象很快变得不可用，于是会被年轻代的GC机制清理掉。年轻代分为三个区域，按照8:1:1的比例划分，其中伊甸园Eden区域最大，对象创建时首先会被分配到这个区域，当发生GC时会将还在引用的对象依次移动到Survivor区域，没有引用的对象内存则被回收。\n\n![年轻代GC](/assets/img/young.png)\n\n1.绝大多数对象实例创建时分配在Eden伊甸园，其中大多数对象实例会很快消失，不在被引用。Eden内存是连续的所以分配速度很快。\n\n2.最初依次，当Eden伊甸园的内存空间被占满时，年轻代的会执行GC机制Minor GC，清理掉不被引用的对象实例，释放内存，而还在引用的存活实例会被复制到Survivor 1的内存空间，此时Survivor 2的内存空间还是空的。\n\n3.下次Eden伊甸园空间占满时，再次执行Minor GC,将存活的复制移动到Survivor 2中，清空Eden伊甸园的内存空间。\n\n4.将Survivor 1中不被引用的对象实例清理掉，还存活的实例复制到Survivor 2中，清空Survivor 1的内存空间。\n\n5.当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。\n\n#### 老年代 Old Generation\n对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）.\n\n#### 永久代 Permanent Generation\n永久代也就是我们常说的方法区，方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。方法区也是物理连续的内存空间，这里的垃圾回收发生的很少，主要是针对常量池的内存回收和对已加载类的卸载。由于方法区回收垃圾条件苛刻困难，效果也不尽人意，所以JDK1.8版本已经取消了永久代。\n\n### 对象引用判断\n所有垃圾回收都面临这样的问题，就是如何判断对象不再被引用，只有对象不再被引用，才能释放它所占用的内存空间，达到清理垃圾整理内存的目的。\n\n#### 引用计数法\n引用计数法是最直接简单的方法计算对象是否还在被引用，简单来说就是为每个对象增加一个引用计数，当对象增加一个引用的时候引用计数加1，相反的当这个对象的一个引用被释放时减1，如果当对象的引用计数变为0时，表示这个对象已经没有被引用。\n\n+ 优点：简单，直接，不需要暂停整个应用。\n+ 缺点：需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作；存在循环引用的问题。\n\n#### 可达性算法\n在Java中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。\n\n在java中，可以作为GC Root的对象有：\n+ 虚拟机栈（栈帧中的本地变量表）中的引用对象\n+ 方法区中静态属性引用的对象\n+ 方法区中常量引用的对象\n+ 本地方法栈中JNI本地方法的引用对象。\n \n### 垃圾回收算法\n#### 标记清理法 Mark-Sweep\n标记清理法是最简单也是最容易实现的，分为两个阶段，标记阶段从根集合开始扫描，标记所有存活对象，清理阶段再次扫描整个内存空间，清理没有标记的内存空间。这个算法容易实现，但是也容易产生内存碎片，而内存碎片过多会导致后续给大对象分配空间时没有可用的空间导致提前出发新的垃圾回收动作。\n \n![标记清理法](/assets/img/markSweep.png)\n \n#### 复制算法 Copying\n为了解决标记清理算法产生的内存碎片问题，复制算法被提出使用，使用原理是将可用内存空间分成大小相等的两份，每次只使用一份，当一份的空间被使用完之后，将所有存活的对象复制到另一份没有使用的内存中，然后清理之前使用过的内存空间，这样就不会产生内存碎片。\n \n![复制算法](/assets/img/copying.png)\n\n#### 标记整理法 Mark-Compact\n标记整理法是解决标记清理法产生内存碎片的另一个算法，和标记清理法一样分为两个阶段，首先标记存活对象，然后将存活对象向一段移动，然后清理掉没有被标记的内存。\n\n![标记整理法](/assets/img/markCompact.png)\n  \n### 垃圾回收器\n根据年轻代和老年代的垃圾回收算法不同，垃圾回收器也分为年轻代收集器和老年代收集器。其中新生代收集器主要有Serial收集器、ParNew收集器和Parallel Scavenge收集器。老年代收集器主要有Serial Old收集器、Parallel Old收集器和CMS收集器。当然还包括了一款全新的、新生代老年代通用的G1收集器。各款收集器的搭配使用如下图所示，其中有连线的代表收集器可以搭配使用，没有连线的收集器表示不能搭配使用。\n\n![垃圾收集器示意图](/assets/img/collector.png)\n\n#### 串行收集器（Serial Collector）\n作用于年轻代，单线程进行GC，需要先停止其他线程，也就是常说的stop the world，当年轻代的Eden伊甸园内存空间不足时发生。\n\n#### ParNew（Serial 收集器的多线程版本）\n是 Serial 的多线程版，是 Server 模式下的虚拟机中首选的新生代收集器，不是默认收集器。同样需要停止其他线程。\n\n#### 并行收集器（Parallel Scavenge）\n并行线程，自适应调整策略，如果把该策略打开，则虚拟机会自动调整新生代的大小比例和晋升老年代的对象大小、年龄等细节参数，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算。\n\n#### Serial Old\n是 Serial 收集器的老年代版本，依旧是单线程收集器，采用标记-整理算法，在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。\n\n#### Parallel Old\n多线程并行，作用于老年代，与Parallel Scavenge类似，使用标记整理算法，不过不同之处在于会将幸存的对象复制到预先准备好的区域，而不是向内存一段移动。\n\n#### CMS（并发-标记-清除）\nCMS(Concurrent Mark Sweep)是并发收集的老年代收集器。以获取最短回收停顿时间为目标，采用多线程并发以及标记-清除算法来实现垃圾回收。CMS只在初始化标记和重新标记阶段需要挂起用户线程,造成一定的应用停顿(STW)，而其他阶段收集线程都可以与用户线程并发交替进行，不必挂起用户线程，所以并不会造成应用的停顿。CMS收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。\n\n#### G1\nG1收集器把 Heap 分为多个大小相等的 Region，G1可以有计划的避免进行全区域的垃圾收集。G1跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值大的 Regin，保证 G1收集器在有限时间内获取最大的收集效率。\n\n","slug":"java-GC垃圾回收机制浅析","published":1,"updated":"2018-09-28T15:54:33.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvje0013ogreyzsuu8v5","content":"<p>java GC(Garbage Collection 垃圾回收)机制是java语言与C、C++语言的区别之一，java程序员不用主动管理内存，而完全交给了GC去处理，至于到底什么时候执行GC也不是由程序员控制的，而是由java的GC线程去处理，虽然无法控制GC，但是了解GC的机制和工作原理，对于开发健壮可用的应用程序很有帮助。</p>\n<h3 id=\"分代内存\"><a href=\"#分代内存\" class=\"headerlink\" title=\"分代内存\"></a>分代内存</h3><p>java GC主要是发生在堆内存中，而堆内存往往是new对象发生的地方，根据对象实例存货时间将堆内存主要划分成了两个区域，新生代（Young Generation）和老年代（Old Generation）。</p>\n<p><img src=\"/assets/img/GC.png\" alt=\"GC分代图\"></p>\n<a id=\"more\"></a>\n<h4 id=\"年轻代-Young-Generation\"><a href=\"#年轻代-Young-Generation\" class=\"headerlink\" title=\"年轻代 Young Generation\"></a>年轻代 Young Generation</h4><p>对象被创建时，内存分配首先发生在年轻代（大对象直接进入老年代），大部分对象很快变得不可用，于是会被年轻代的GC机制清理掉。年轻代分为三个区域，按照8:1:1的比例划分，其中伊甸园Eden区域最大，对象创建时首先会被分配到这个区域，当发生GC时会将还在引用的对象依次移动到Survivor区域，没有引用的对象内存则被回收。</p>\n<p><img src=\"/assets/img/young.png\" alt=\"年轻代GC\"></p>\n<p>1.绝大多数对象实例创建时分配在Eden伊甸园，其中大多数对象实例会很快消失，不在被引用。Eden内存是连续的所以分配速度很快。</p>\n<p>2.最初依次，当Eden伊甸园的内存空间被占满时，年轻代的会执行GC机制Minor GC，清理掉不被引用的对象实例，释放内存，而还在引用的存活实例会被复制到Survivor 1的内存空间，此时Survivor 2的内存空间还是空的。</p>\n<p>3.下次Eden伊甸园空间占满时，再次执行Minor GC,将存活的复制移动到Survivor 2中，清空Eden伊甸园的内存空间。</p>\n<p>4.将Survivor 1中不被引用的对象实例清理掉，还存活的实例复制到Survivor 2中，清空Survivor 1的内存空间。</p>\n<p>5.当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</p>\n<h4 id=\"老年代-Old-Generation\"><a href=\"#老年代-Old-Generation\" class=\"headerlink\" title=\"老年代 Old Generation\"></a>老年代 Old Generation</h4><p>对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）.</p>\n<h4 id=\"永久代-Permanent-Generation\"><a href=\"#永久代-Permanent-Generation\" class=\"headerlink\" title=\"永久代 Permanent Generation\"></a>永久代 Permanent Generation</h4><p>永久代也就是我们常说的方法区，方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。方法区也是物理连续的内存空间，这里的垃圾回收发生的很少，主要是针对常量池的内存回收和对已加载类的卸载。由于方法区回收垃圾条件苛刻困难，效果也不尽人意，所以JDK1.8版本已经取消了永久代。</p>\n<h3 id=\"对象引用判断\"><a href=\"#对象引用判断\" class=\"headerlink\" title=\"对象引用判断\"></a>对象引用判断</h3><p>所有垃圾回收都面临这样的问题，就是如何判断对象不再被引用，只有对象不再被引用，才能释放它所占用的内存空间，达到清理垃圾整理内存的目的。</p>\n<h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>引用计数法是最直接简单的方法计算对象是否还在被引用，简单来说就是为每个对象增加一个引用计数，当对象增加一个引用的时候引用计数加1，相反的当这个对象的一个引用被释放时减1，如果当对象的引用计数变为0时，表示这个对象已经没有被引用。</p>\n<ul>\n<li>优点：简单，直接，不需要暂停整个应用。</li>\n<li>缺点：需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作；存在循环引用的问题。</li>\n</ul>\n<h4 id=\"可达性算法\"><a href=\"#可达性算法\" class=\"headerlink\" title=\"可达性算法\"></a>可达性算法</h4><p>在Java中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。</p>\n<p>在java中，可以作为GC Root的对象有：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li>\n<li>方法区中静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI本地方法的引用对象。</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><h4 id=\"标记清理法-Mark-Sweep\"><a href=\"#标记清理法-Mark-Sweep\" class=\"headerlink\" title=\"标记清理法 Mark-Sweep\"></a>标记清理法 Mark-Sweep</h4><p>标记清理法是最简单也是最容易实现的，分为两个阶段，标记阶段从根集合开始扫描，标记所有存活对象，清理阶段再次扫描整个内存空间，清理没有标记的内存空间。这个算法容易实现，但是也容易产生内存碎片，而内存碎片过多会导致后续给大对象分配空间时没有可用的空间导致提前出发新的垃圾回收动作。</p>\n<p><img src=\"/assets/img/markSweep.png\" alt=\"标记清理法\"></p>\n<h4 id=\"复制算法-Copying\"><a href=\"#复制算法-Copying\" class=\"headerlink\" title=\"复制算法 Copying\"></a>复制算法 Copying</h4><p>为了解决标记清理算法产生的内存碎片问题，复制算法被提出使用，使用原理是将可用内存空间分成大小相等的两份，每次只使用一份，当一份的空间被使用完之后，将所有存活的对象复制到另一份没有使用的内存中，然后清理之前使用过的内存空间，这样就不会产生内存碎片。</p>\n<p><img src=\"/assets/img/copying.png\" alt=\"复制算法\"></p>\n<h4 id=\"标记整理法-Mark-Compact\"><a href=\"#标记整理法-Mark-Compact\" class=\"headerlink\" title=\"标记整理法 Mark-Compact\"></a>标记整理法 Mark-Compact</h4><p>标记整理法是解决标记清理法产生内存碎片的另一个算法，和标记清理法一样分为两个阶段，首先标记存活对象，然后将存活对象向一段移动，然后清理掉没有被标记的内存。</p>\n<p><img src=\"/assets/img/markCompact.png\" alt=\"标记整理法\"></p>\n<h3 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h3><p>根据年轻代和老年代的垃圾回收算法不同，垃圾回收器也分为年轻代收集器和老年代收集器。其中新生代收集器主要有Serial收集器、ParNew收集器和Parallel Scavenge收集器。老年代收集器主要有Serial Old收集器、Parallel Old收集器和CMS收集器。当然还包括了一款全新的、新生代老年代通用的G1收集器。各款收集器的搭配使用如下图所示，其中有连线的代表收集器可以搭配使用，没有连线的收集器表示不能搭配使用。</p>\n<p><img src=\"/assets/img/collector.png\" alt=\"垃圾收集器示意图\"></p>\n<h4 id=\"串行收集器（Serial-Collector）\"><a href=\"#串行收集器（Serial-Collector）\" class=\"headerlink\" title=\"串行收集器（Serial Collector）\"></a>串行收集器（Serial Collector）</h4><p>作用于年轻代，单线程进行GC，需要先停止其他线程，也就是常说的stop the world，当年轻代的Eden伊甸园内存空间不足时发生。</p>\n<h4 id=\"ParNew（Serial-收集器的多线程版本）\"><a href=\"#ParNew（Serial-收集器的多线程版本）\" class=\"headerlink\" title=\"ParNew（Serial 收集器的多线程版本）\"></a>ParNew（Serial 收集器的多线程版本）</h4><p>是 Serial 的多线程版，是 Server 模式下的虚拟机中首选的新生代收集器，不是默认收集器。同样需要停止其他线程。</p>\n<h4 id=\"并行收集器（Parallel-Scavenge）\"><a href=\"#并行收集器（Parallel-Scavenge）\" class=\"headerlink\" title=\"并行收集器（Parallel Scavenge）\"></a>并行收集器（Parallel Scavenge）</h4><p>并行线程，自适应调整策略，如果把该策略打开，则虚拟机会自动调整新生代的大小比例和晋升老年代的对象大小、年龄等细节参数，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算。</p>\n<h4 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h4><p>是 Serial 收集器的老年代版本，依旧是单线程收集器，采用标记-整理算法，在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。</p>\n<h4 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h4><p>多线程并行，作用于老年代，与Parallel Scavenge类似，使用标记整理算法，不过不同之处在于会将幸存的对象复制到预先准备好的区域，而不是向内存一段移动。</p>\n<h4 id=\"CMS（并发-标记-清除）\"><a href=\"#CMS（并发-标记-清除）\" class=\"headerlink\" title=\"CMS（并发-标记-清除）\"></a>CMS（并发-标记-清除）</h4><p>CMS(Concurrent Mark Sweep)是并发收集的老年代收集器。以获取最短回收停顿时间为目标，采用多线程并发以及标记-清除算法来实现垃圾回收。CMS只在初始化标记和重新标记阶段需要挂起用户线程,造成一定的应用停顿(STW)，而其他阶段收集线程都可以与用户线程并发交替进行，不必挂起用户线程，所以并不会造成应用的停顿。CMS收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。</p>\n<h4 id=\"G1\"><a href=\"#G1\" class=\"headerlink\" title=\"G1\"></a>G1</h4><p>G1收集器把 Heap 分为多个大小相等的 Region，G1可以有计划的避免进行全区域的垃圾收集。G1跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值大的 Regin，保证 G1收集器在有限时间内获取最大的收集效率。</p>\n","site":{"data":{}},"excerpt":"<p>java GC(Garbage Collection 垃圾回收)机制是java语言与C、C++语言的区别之一，java程序员不用主动管理内存，而完全交给了GC去处理，至于到底什么时候执行GC也不是由程序员控制的，而是由java的GC线程去处理，虽然无法控制GC，但是了解GC的机制和工作原理，对于开发健壮可用的应用程序很有帮助。</p>\n<h3 id=\"分代内存\"><a href=\"#分代内存\" class=\"headerlink\" title=\"分代内存\"></a>分代内存</h3><p>java GC主要是发生在堆内存中，而堆内存往往是new对象发生的地方，根据对象实例存货时间将堆内存主要划分成了两个区域，新生代（Young Generation）和老年代（Old Generation）。</p>\n<p><img src=\"/assets/img/GC.png\" alt=\"GC分代图\"></p>","more":"<h4 id=\"年轻代-Young-Generation\"><a href=\"#年轻代-Young-Generation\" class=\"headerlink\" title=\"年轻代 Young Generation\"></a>年轻代 Young Generation</h4><p>对象被创建时，内存分配首先发生在年轻代（大对象直接进入老年代），大部分对象很快变得不可用，于是会被年轻代的GC机制清理掉。年轻代分为三个区域，按照8:1:1的比例划分，其中伊甸园Eden区域最大，对象创建时首先会被分配到这个区域，当发生GC时会将还在引用的对象依次移动到Survivor区域，没有引用的对象内存则被回收。</p>\n<p><img src=\"/assets/img/young.png\" alt=\"年轻代GC\"></p>\n<p>1.绝大多数对象实例创建时分配在Eden伊甸园，其中大多数对象实例会很快消失，不在被引用。Eden内存是连续的所以分配速度很快。</p>\n<p>2.最初依次，当Eden伊甸园的内存空间被占满时，年轻代的会执行GC机制Minor GC，清理掉不被引用的对象实例，释放内存，而还在引用的存活实例会被复制到Survivor 1的内存空间，此时Survivor 2的内存空间还是空的。</p>\n<p>3.下次Eden伊甸园空间占满时，再次执行Minor GC,将存活的复制移动到Survivor 2中，清空Eden伊甸园的内存空间。</p>\n<p>4.将Survivor 1中不被引用的对象实例清理掉，还存活的实例复制到Survivor 2中，清空Survivor 1的内存空间。</p>\n<p>5.当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</p>\n<h4 id=\"老年代-Old-Generation\"><a href=\"#老年代-Old-Generation\" class=\"headerlink\" title=\"老年代 Old Generation\"></a>老年代 Old Generation</h4><p>对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）.</p>\n<h4 id=\"永久代-Permanent-Generation\"><a href=\"#永久代-Permanent-Generation\" class=\"headerlink\" title=\"永久代 Permanent Generation\"></a>永久代 Permanent Generation</h4><p>永久代也就是我们常说的方法区，方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。方法区也是物理连续的内存空间，这里的垃圾回收发生的很少，主要是针对常量池的内存回收和对已加载类的卸载。由于方法区回收垃圾条件苛刻困难，效果也不尽人意，所以JDK1.8版本已经取消了永久代。</p>\n<h3 id=\"对象引用判断\"><a href=\"#对象引用判断\" class=\"headerlink\" title=\"对象引用判断\"></a>对象引用判断</h3><p>所有垃圾回收都面临这样的问题，就是如何判断对象不再被引用，只有对象不再被引用，才能释放它所占用的内存空间，达到清理垃圾整理内存的目的。</p>\n<h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>引用计数法是最直接简单的方法计算对象是否还在被引用，简单来说就是为每个对象增加一个引用计数，当对象增加一个引用的时候引用计数加1，相反的当这个对象的一个引用被释放时减1，如果当对象的引用计数变为0时，表示这个对象已经没有被引用。</p>\n<ul>\n<li>优点：简单，直接，不需要暂停整个应用。</li>\n<li>缺点：需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作；存在循环引用的问题。</li>\n</ul>\n<h4 id=\"可达性算法\"><a href=\"#可达性算法\" class=\"headerlink\" title=\"可达性算法\"></a>可达性算法</h4><p>在Java中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。</p>\n<p>在java中，可以作为GC Root的对象有：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li>\n<li>方法区中静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI本地方法的引用对象。</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><h4 id=\"标记清理法-Mark-Sweep\"><a href=\"#标记清理法-Mark-Sweep\" class=\"headerlink\" title=\"标记清理法 Mark-Sweep\"></a>标记清理法 Mark-Sweep</h4><p>标记清理法是最简单也是最容易实现的，分为两个阶段，标记阶段从根集合开始扫描，标记所有存活对象，清理阶段再次扫描整个内存空间，清理没有标记的内存空间。这个算法容易实现，但是也容易产生内存碎片，而内存碎片过多会导致后续给大对象分配空间时没有可用的空间导致提前出发新的垃圾回收动作。</p>\n<p><img src=\"/assets/img/markSweep.png\" alt=\"标记清理法\"></p>\n<h4 id=\"复制算法-Copying\"><a href=\"#复制算法-Copying\" class=\"headerlink\" title=\"复制算法 Copying\"></a>复制算法 Copying</h4><p>为了解决标记清理算法产生的内存碎片问题，复制算法被提出使用，使用原理是将可用内存空间分成大小相等的两份，每次只使用一份，当一份的空间被使用完之后，将所有存活的对象复制到另一份没有使用的内存中，然后清理之前使用过的内存空间，这样就不会产生内存碎片。</p>\n<p><img src=\"/assets/img/copying.png\" alt=\"复制算法\"></p>\n<h4 id=\"标记整理法-Mark-Compact\"><a href=\"#标记整理法-Mark-Compact\" class=\"headerlink\" title=\"标记整理法 Mark-Compact\"></a>标记整理法 Mark-Compact</h4><p>标记整理法是解决标记清理法产生内存碎片的另一个算法，和标记清理法一样分为两个阶段，首先标记存活对象，然后将存活对象向一段移动，然后清理掉没有被标记的内存。</p>\n<p><img src=\"/assets/img/markCompact.png\" alt=\"标记整理法\"></p>\n<h3 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h3><p>根据年轻代和老年代的垃圾回收算法不同，垃圾回收器也分为年轻代收集器和老年代收集器。其中新生代收集器主要有Serial收集器、ParNew收集器和Parallel Scavenge收集器。老年代收集器主要有Serial Old收集器、Parallel Old收集器和CMS收集器。当然还包括了一款全新的、新生代老年代通用的G1收集器。各款收集器的搭配使用如下图所示，其中有连线的代表收集器可以搭配使用，没有连线的收集器表示不能搭配使用。</p>\n<p><img src=\"/assets/img/collector.png\" alt=\"垃圾收集器示意图\"></p>\n<h4 id=\"串行收集器（Serial-Collector）\"><a href=\"#串行收集器（Serial-Collector）\" class=\"headerlink\" title=\"串行收集器（Serial Collector）\"></a>串行收集器（Serial Collector）</h4><p>作用于年轻代，单线程进行GC，需要先停止其他线程，也就是常说的stop the world，当年轻代的Eden伊甸园内存空间不足时发生。</p>\n<h4 id=\"ParNew（Serial-收集器的多线程版本）\"><a href=\"#ParNew（Serial-收集器的多线程版本）\" class=\"headerlink\" title=\"ParNew（Serial 收集器的多线程版本）\"></a>ParNew（Serial 收集器的多线程版本）</h4><p>是 Serial 的多线程版，是 Server 模式下的虚拟机中首选的新生代收集器，不是默认收集器。同样需要停止其他线程。</p>\n<h4 id=\"并行收集器（Parallel-Scavenge）\"><a href=\"#并行收集器（Parallel-Scavenge）\" class=\"headerlink\" title=\"并行收集器（Parallel Scavenge）\"></a>并行收集器（Parallel Scavenge）</h4><p>并行线程，自适应调整策略，如果把该策略打开，则虚拟机会自动调整新生代的大小比例和晋升老年代的对象大小、年龄等细节参数，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算。</p>\n<h4 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h4><p>是 Serial 收集器的老年代版本，依旧是单线程收集器，采用标记-整理算法，在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。</p>\n<h4 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h4><p>多线程并行，作用于老年代，与Parallel Scavenge类似，使用标记整理算法，不过不同之处在于会将幸存的对象复制到预先准备好的区域，而不是向内存一段移动。</p>\n<h4 id=\"CMS（并发-标记-清除）\"><a href=\"#CMS（并发-标记-清除）\" class=\"headerlink\" title=\"CMS（并发-标记-清除）\"></a>CMS（并发-标记-清除）</h4><p>CMS(Concurrent Mark Sweep)是并发收集的老年代收集器。以获取最短回收停顿时间为目标，采用多线程并发以及标记-清除算法来实现垃圾回收。CMS只在初始化标记和重新标记阶段需要挂起用户线程,造成一定的应用停顿(STW)，而其他阶段收集线程都可以与用户线程并发交替进行，不必挂起用户线程，所以并不会造成应用的停顿。CMS收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。</p>\n<h4 id=\"G1\"><a href=\"#G1\" class=\"headerlink\" title=\"G1\"></a>G1</h4><p>G1收集器把 Heap 分为多个大小相等的 Region，G1可以有计划的避免进行全区域的垃圾收集。G1跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值大的 Regin，保证 G1收集器在有限时间内获取最大的收集效率。</p>"},{"title":"ArrayList和LinkedList的区别比较","date":"2018-10-30T14:46:27.000Z","toc":true,"_content":"Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。而在集合类型中最常用的就是ArrayList和LinkedList这个集合类，所以了解这个的区别对于使用集合类很有帮助。\n\n### ArrayList与LinkedList的继承关系\nArrayList与LinkedList都是List接口的实现类,因此都实现了List的所有未实现的方法,只是实现的方式有所不同。ArrayList实现了List接口,它是以数组的方式来实现的,数组的特性是可以使用索引的方式来快速定位对象的位置,因此对于快速的随机取得对象的需求,使用ArrayList实现执行效率上会比较好.。LinkedList是采用链表的方式来实现List接口的,它本身有自己特定的方法，如: addFirst(),addLast(),getFirst(),removeFirst()等. 由于是采用链表实现的,因此在进行insert和remove动作时在效率上要比ArrayList要好得多!适合用来实现Stack(堆栈)与Queue(队列),前者先进后出，后者是先进先出。\n\n<!--more-->\n\n![ArrayList与LinkedList的继承关系](/assets/img/listDifferent.png)\n\n### ArrayList 介绍\n* ArrayList 是一个数组队列，和数组不同的是能够动态扩容，也就是我们说的动态数组;\n* 继承自AbstractLis，有实现了List接口，可以使用添加、修改、删除遍历等功能\n* 实现了RandomAccess接口，提供随机访问功能，即通过数组下标访问元素\n* 实现了Cloneable接口，覆盖了函数clone()，能被克隆\n* 实现了java.io.Serializable接口，支持序列化，能通过序列化去传输\n* 和Vector不同的是ArrayList不是线程安全的，所以涉及多线程的时候不建议使用\n\nArrayList的构造函数：\n```\n    //默认构造函数，底层数组大小默认为10，空间不如时新的容量=“(原始容量x3)/2 + 1”\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    //指定数组大小的构造函数，空间不足时容量会添加上次容量的一般\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n        \n    //指定Collection的创建   \n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\nArrayList的三种遍历方法，使用随机访问(即，通过索引序号访问)效率最高；使用迭代器进行遍历 效率最低！\n\n```\n    //默认方式创建初始化\n    ArrayList<Integer> array = new ArrayList<Integer>();\n    //添加元素\n    for (int i = 0; i < 10; i++) {\n        array.add(i);\n    }\n    \n     System.out.println(\"随机访问遍历数组array：\");\n     for (int i = 0; i < array.size(); i++) {\n        //获取元素\n        System.out.print(array.get(i) + \" \");\n     }\n     System.out.println();\n     \n     System.out.println(\"随机访问遍历数组array：\");\n     for (Integer i: array) {\n        System.out.print(i + \" \");\n     }\n     System.out.println();\n    \n    //迭代器进行遍历 效率最低！\n    Iterator iterator = array.iterator();\n    System.out.println(\"迭代器遍历数组array中包含元素：\");\n    while (iterator.hasNext()) {\n        System.out.print(iterator.next() + \" \");\n    }\n```\n\n### LinkedList 介绍\n+ LinkedList 是一个继承于AbstractSequentialList的双向链表,可以被当作堆栈、队列或双端队列进行操作\n+ 实现了List接口，可以使用添加、修改、删除遍历等功能\n+ 实现 Deque 接口，即能将LinkedList当作双端队列使用\n+ 实现了Cloneable接口，覆盖了函数clone()，能被克隆\n+ 实现了java.io.Serializable接口，支持序列化，能通过序列化去传输\n+ LinkedList是非线程同步的，所以多线程的场景不建议使用\n\nLinkedList的构造函数：\n```\n //默认构造函数\n public LinkedList() {\n }\n \n //指定Collection的创建   \n public LinkedList(Collection<? extends E> c) {\n     this();\n     addAll(c);\n }\n\n```\n\nLinkedList的简单使用：\n```\n/**\n * LinkedList 实际上是通过双向链表去实现的\n * 内部类Node是双向链表节点所对应的数据结构：当前节点所包含的值，上一个节点，下一个节点\n */\nLinkedList linkedList = new LinkedList();\n\n//添加元素\nfor (int i = 0; i < 10; i++) {\n    //属于Collection接口的方法 会抛出异常\n    linkedList.add(i);\n}\n\n//向头部添加元素 属于Collection接口的方法 会抛出异常\nlinkedList.addFirst(-1);\n\n//获取第一个元素 属于Collection接口的方法 会抛出异常\nObject first = linkedList.getFirst();\nSystem.out.println(\"linkedList数组的第一个元素是：\"+ first);\nSystem.out.println();\n\n//向尾部添加元素 属于Collection接口的方法 会抛出异常\nlinkedList.addLast(100);\n\n//获取最后一个元素 属于Collection接口的方法 会抛出异常\nObject last = linkedList.getLast();\nSystem.out.println(\"linkedList数组的最后一个元素是：\" + last);\nSystem.out.println();\n\n//移除第一个元素 属于Collection接口的方法 会抛出异常\nObject removeF = linkedList.removeFirst();\nSystem.out.println(\"linkedList数组移除第一个元素：\" + removeF);\nfirst = linkedList.getFirst();\nSystem.out.println(\"linkedList数组移除第一个元素后第一元素为：\" + first);\nSystem.out.println();\n\n//移除最后一个元素 属于Collection接口的方法 会抛出异常\nObject removeL = linkedList.removeLast();\nSystem.out.println(\"linkedList数组移除最后一个元素：\" + removeL);\nlast = linkedList.getLast();\nSystem.out.println(\"linkedList数组移除最后一个元素后最后一元素为：\" + last);\nSystem.out.println();\n\n//通过迭代器遍历\nSystem.out.println(\"通过迭代器遍历:\");\nfor (Iterator iterator = linkedList.listIterator(); iterator.hasNext();) {\n    System.out.print(iterator.next() + \" \");\n}\nSystem.out.println();\n\n//Deque队列时使用的添加方法 返回boolean值不会抛出异常\nboolean offer = linkedList.offer(\"offer\");\nSystem.out.println(\"linkedList当做队列时添加元素offer返回：\" + offer);\nSystem.out.println();\n\n//向队列添加到头部\nboolean offerF = linkedList.offerFirst(\"first\");\nSystem.out.println(\"linkedList当做队列时添加头部元素first返回：\" + offerF);\n//获取队列头部元素\nfirst = linkedList.peekFirst();\nSystem.out.println(\"peek linkedList第一个元素：\" + first);\nSystem.out.println();\n\n//向队列尾部添加元素\nboolean offerL = linkedList.offerLast(\"last\");\nSystem.out.println(\"linkedList当做队列时添加尾部元素last返回：\" + offerL);\n//获取队列尾部元素\nlast = linkedList.peekLast();\nSystem.out.println(\"peek linkedList最后一个元素：\" + last);\nSystem.out.println();\n\n//移除头部元素\nObject pollF = linkedList.pollFirst();\nSystem.out.println(\"linkedList数组移除第一个元素：\" + pollF);\n//获取第一元素\nfirst = linkedList.element();\nSystem.out.println(\"linkedList数组移除第一个元素后第一元素为：\" + first);\nSystem.out.println();\n\n//移除尾部元素\nObject pollL = linkedList.pollLast();\nSystem.out.println(\"linkedList数组移除最后一个元素：\" + pollL);\nlast = linkedList.getLast();\nSystem.out.println(\"linkedList数组移除最后一个元素后最后一元素为：\" + last);\nSystem.out.println();\n\n//通过for循环遍历 不推荐使用 速度很慢\nSystem.out.println(\"通过for循环遍历:\");\nfor (int i = 0; i < linkedList.size(); i++) {\n    System.out.print(linkedList.get(i) + \" \");\n}\nSystem.out.println();\n\n//LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时\n//添加到头部\nlinkedList.push(\"push\");\nSystem.out.println(\"linkedList数组的第一元素为：\" + linkedList.peekFirst());\nSystem.out.println();\n\n//移除头部元素\nObject pop = linkedList.pop();\nSystem.out.println(\"linkedList数组移除第一个元素：\" + pop);\nSystem.out.println();\n\n//for增强循环 推荐使用\nSystem.out.println(\"for增强循环：\");\nfor (Object o: linkedList) {\n    System.out.print(o + \" \");\n}\nSystem.out.println();\nSystem.out.println();\n\n//拷贝数组\nLinkedList copy = (LinkedList) linkedList.clone();\nLinkedList copy1 = (LinkedList) linkedList.clone();\nLinkedList copy2 = (LinkedList) linkedList.clone();\nLinkedList copy3 = (LinkedList) linkedList.clone();\n\n/**\n * 下面的遍历方法都会移除原始数据：\n * 使用removeFist()或removeLast()效率最高\n */\n//通过pollFirst()来遍历LinkedList\nSystem.out.println(\"通过pollFirst()来遍历LinkedList：\");\ndo {\n    if (copy.size() > 0) {\n        System.out.print(copy.getFirst() + \" \");\n    }\n} while (copy.pollFirst() != null);\n\nSystem.out.println();\nSystem.out.println();\n\n//通过pollLast()来遍历LinkedList\nSystem.out.println(\"通过pollLast()来遍历LinkedList：\");\ndo {\n    if (copy1.size() > 0) {\n        System.out.print(copy1.getLast() + \" \");\n    }\n} while (copy1.pollLast() != null);\nSystem.out.println();\nSystem.out.println();\n\n//通过removeFirst()来遍历LinkedList\nSystem.out.println(\"通过removeFirst()来遍历LinkedList：\");\ntry {\n    do {\n        if (copy2.size() > 0) {\n            System.out.print(copy2.getFirst() + \" \");\n        }\n    } while(copy2.size() > 0 && copy2.removeFirst() != null);\n    System.out.println();\n} catch (NoSuchElementException e) {\n    e.printStackTrace();\n}\nSystem.out.println();\n\n//通过removeLast()来遍历LinkedList\nSystem.out.println(\"通过removeLast()来遍历LinkedList：\");\ntry {\n    do {\n        if (copy3.size() > 0) {\n            System.out.print(copy3.getLast() + \" \");\n        }\n    } while(copy3.size() > 0 && copy3.removeLast() != null);\n    System.out.println();\n} catch (NoSuchElementException e) {\n    e.printStackTrace();\n}\n```\n\n### ArrayList与LinkedList异同\nArrayList与LinkedList都是List的具体实现类，所以存储的都是有序元素，可以通过下标进行随机访问元素，不过由于实现List的方式不同，导致了两者的差异。ArrayList的底层是数组，数组是一块连续的内存空间，优势就是随机访问速度快，但是插入删除元素导致其他元素的位置改变所以速度慢；LinkedList使用了链表的结构，内部类Entry存储了当前节点所包含的值，上一个节点，下一个节点等信息，查询时需要遍历所有元素找到所查元素这就意味着数据量越大查询速度越慢，除非位置离头部很近；但是插入、删除元素只需要对元素的前一元素的尾部和后一个元素的尾部进行修改即可，其他的元素不需要改动，所以速度很快。\n\n|List集合  |  实现List方式  |  查询速度| 插入删除速度 | 是否有序 |\n| :------ | :------ | :------ | :-------- | :------ |\n|ArrayList  |  数组  |  速度快| 速度慢 | 有序 |\n|LinkedList  |  双向链表  |  速度慢| 速度快 | 有序 |","source":"_posts/2018-10-30-ArrayList和LinkedList的区别比较.md","raw":"---\ntitle: ArrayList和LinkedList的区别比较\ndate: 2018-10-30 22:46:27\ntoc: true\ntags:\n    - 集合\n    - ArrayList\n    - LinkedList\n---\nJava 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。而在集合类型中最常用的就是ArrayList和LinkedList这个集合类，所以了解这个的区别对于使用集合类很有帮助。\n\n### ArrayList与LinkedList的继承关系\nArrayList与LinkedList都是List接口的实现类,因此都实现了List的所有未实现的方法,只是实现的方式有所不同。ArrayList实现了List接口,它是以数组的方式来实现的,数组的特性是可以使用索引的方式来快速定位对象的位置,因此对于快速的随机取得对象的需求,使用ArrayList实现执行效率上会比较好.。LinkedList是采用链表的方式来实现List接口的,它本身有自己特定的方法，如: addFirst(),addLast(),getFirst(),removeFirst()等. 由于是采用链表实现的,因此在进行insert和remove动作时在效率上要比ArrayList要好得多!适合用来实现Stack(堆栈)与Queue(队列),前者先进后出，后者是先进先出。\n\n<!--more-->\n\n![ArrayList与LinkedList的继承关系](/assets/img/listDifferent.png)\n\n### ArrayList 介绍\n* ArrayList 是一个数组队列，和数组不同的是能够动态扩容，也就是我们说的动态数组;\n* 继承自AbstractLis，有实现了List接口，可以使用添加、修改、删除遍历等功能\n* 实现了RandomAccess接口，提供随机访问功能，即通过数组下标访问元素\n* 实现了Cloneable接口，覆盖了函数clone()，能被克隆\n* 实现了java.io.Serializable接口，支持序列化，能通过序列化去传输\n* 和Vector不同的是ArrayList不是线程安全的，所以涉及多线程的时候不建议使用\n\nArrayList的构造函数：\n```\n    //默认构造函数，底层数组大小默认为10，空间不如时新的容量=“(原始容量x3)/2 + 1”\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    //指定数组大小的构造函数，空间不足时容量会添加上次容量的一般\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n        \n    //指定Collection的创建   \n    public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\nArrayList的三种遍历方法，使用随机访问(即，通过索引序号访问)效率最高；使用迭代器进行遍历 效率最低！\n\n```\n    //默认方式创建初始化\n    ArrayList<Integer> array = new ArrayList<Integer>();\n    //添加元素\n    for (int i = 0; i < 10; i++) {\n        array.add(i);\n    }\n    \n     System.out.println(\"随机访问遍历数组array：\");\n     for (int i = 0; i < array.size(); i++) {\n        //获取元素\n        System.out.print(array.get(i) + \" \");\n     }\n     System.out.println();\n     \n     System.out.println(\"随机访问遍历数组array：\");\n     for (Integer i: array) {\n        System.out.print(i + \" \");\n     }\n     System.out.println();\n    \n    //迭代器进行遍历 效率最低！\n    Iterator iterator = array.iterator();\n    System.out.println(\"迭代器遍历数组array中包含元素：\");\n    while (iterator.hasNext()) {\n        System.out.print(iterator.next() + \" \");\n    }\n```\n\n### LinkedList 介绍\n+ LinkedList 是一个继承于AbstractSequentialList的双向链表,可以被当作堆栈、队列或双端队列进行操作\n+ 实现了List接口，可以使用添加、修改、删除遍历等功能\n+ 实现 Deque 接口，即能将LinkedList当作双端队列使用\n+ 实现了Cloneable接口，覆盖了函数clone()，能被克隆\n+ 实现了java.io.Serializable接口，支持序列化，能通过序列化去传输\n+ LinkedList是非线程同步的，所以多线程的场景不建议使用\n\nLinkedList的构造函数：\n```\n //默认构造函数\n public LinkedList() {\n }\n \n //指定Collection的创建   \n public LinkedList(Collection<? extends E> c) {\n     this();\n     addAll(c);\n }\n\n```\n\nLinkedList的简单使用：\n```\n/**\n * LinkedList 实际上是通过双向链表去实现的\n * 内部类Node是双向链表节点所对应的数据结构：当前节点所包含的值，上一个节点，下一个节点\n */\nLinkedList linkedList = new LinkedList();\n\n//添加元素\nfor (int i = 0; i < 10; i++) {\n    //属于Collection接口的方法 会抛出异常\n    linkedList.add(i);\n}\n\n//向头部添加元素 属于Collection接口的方法 会抛出异常\nlinkedList.addFirst(-1);\n\n//获取第一个元素 属于Collection接口的方法 会抛出异常\nObject first = linkedList.getFirst();\nSystem.out.println(\"linkedList数组的第一个元素是：\"+ first);\nSystem.out.println();\n\n//向尾部添加元素 属于Collection接口的方法 会抛出异常\nlinkedList.addLast(100);\n\n//获取最后一个元素 属于Collection接口的方法 会抛出异常\nObject last = linkedList.getLast();\nSystem.out.println(\"linkedList数组的最后一个元素是：\" + last);\nSystem.out.println();\n\n//移除第一个元素 属于Collection接口的方法 会抛出异常\nObject removeF = linkedList.removeFirst();\nSystem.out.println(\"linkedList数组移除第一个元素：\" + removeF);\nfirst = linkedList.getFirst();\nSystem.out.println(\"linkedList数组移除第一个元素后第一元素为：\" + first);\nSystem.out.println();\n\n//移除最后一个元素 属于Collection接口的方法 会抛出异常\nObject removeL = linkedList.removeLast();\nSystem.out.println(\"linkedList数组移除最后一个元素：\" + removeL);\nlast = linkedList.getLast();\nSystem.out.println(\"linkedList数组移除最后一个元素后最后一元素为：\" + last);\nSystem.out.println();\n\n//通过迭代器遍历\nSystem.out.println(\"通过迭代器遍历:\");\nfor (Iterator iterator = linkedList.listIterator(); iterator.hasNext();) {\n    System.out.print(iterator.next() + \" \");\n}\nSystem.out.println();\n\n//Deque队列时使用的添加方法 返回boolean值不会抛出异常\nboolean offer = linkedList.offer(\"offer\");\nSystem.out.println(\"linkedList当做队列时添加元素offer返回：\" + offer);\nSystem.out.println();\n\n//向队列添加到头部\nboolean offerF = linkedList.offerFirst(\"first\");\nSystem.out.println(\"linkedList当做队列时添加头部元素first返回：\" + offerF);\n//获取队列头部元素\nfirst = linkedList.peekFirst();\nSystem.out.println(\"peek linkedList第一个元素：\" + first);\nSystem.out.println();\n\n//向队列尾部添加元素\nboolean offerL = linkedList.offerLast(\"last\");\nSystem.out.println(\"linkedList当做队列时添加尾部元素last返回：\" + offerL);\n//获取队列尾部元素\nlast = linkedList.peekLast();\nSystem.out.println(\"peek linkedList最后一个元素：\" + last);\nSystem.out.println();\n\n//移除头部元素\nObject pollF = linkedList.pollFirst();\nSystem.out.println(\"linkedList数组移除第一个元素：\" + pollF);\n//获取第一元素\nfirst = linkedList.element();\nSystem.out.println(\"linkedList数组移除第一个元素后第一元素为：\" + first);\nSystem.out.println();\n\n//移除尾部元素\nObject pollL = linkedList.pollLast();\nSystem.out.println(\"linkedList数组移除最后一个元素：\" + pollL);\nlast = linkedList.getLast();\nSystem.out.println(\"linkedList数组移除最后一个元素后最后一元素为：\" + last);\nSystem.out.println();\n\n//通过for循环遍历 不推荐使用 速度很慢\nSystem.out.println(\"通过for循环遍历:\");\nfor (int i = 0; i < linkedList.size(); i++) {\n    System.out.print(linkedList.get(i) + \" \");\n}\nSystem.out.println();\n\n//LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时\n//添加到头部\nlinkedList.push(\"push\");\nSystem.out.println(\"linkedList数组的第一元素为：\" + linkedList.peekFirst());\nSystem.out.println();\n\n//移除头部元素\nObject pop = linkedList.pop();\nSystem.out.println(\"linkedList数组移除第一个元素：\" + pop);\nSystem.out.println();\n\n//for增强循环 推荐使用\nSystem.out.println(\"for增强循环：\");\nfor (Object o: linkedList) {\n    System.out.print(o + \" \");\n}\nSystem.out.println();\nSystem.out.println();\n\n//拷贝数组\nLinkedList copy = (LinkedList) linkedList.clone();\nLinkedList copy1 = (LinkedList) linkedList.clone();\nLinkedList copy2 = (LinkedList) linkedList.clone();\nLinkedList copy3 = (LinkedList) linkedList.clone();\n\n/**\n * 下面的遍历方法都会移除原始数据：\n * 使用removeFist()或removeLast()效率最高\n */\n//通过pollFirst()来遍历LinkedList\nSystem.out.println(\"通过pollFirst()来遍历LinkedList：\");\ndo {\n    if (copy.size() > 0) {\n        System.out.print(copy.getFirst() + \" \");\n    }\n} while (copy.pollFirst() != null);\n\nSystem.out.println();\nSystem.out.println();\n\n//通过pollLast()来遍历LinkedList\nSystem.out.println(\"通过pollLast()来遍历LinkedList：\");\ndo {\n    if (copy1.size() > 0) {\n        System.out.print(copy1.getLast() + \" \");\n    }\n} while (copy1.pollLast() != null);\nSystem.out.println();\nSystem.out.println();\n\n//通过removeFirst()来遍历LinkedList\nSystem.out.println(\"通过removeFirst()来遍历LinkedList：\");\ntry {\n    do {\n        if (copy2.size() > 0) {\n            System.out.print(copy2.getFirst() + \" \");\n        }\n    } while(copy2.size() > 0 && copy2.removeFirst() != null);\n    System.out.println();\n} catch (NoSuchElementException e) {\n    e.printStackTrace();\n}\nSystem.out.println();\n\n//通过removeLast()来遍历LinkedList\nSystem.out.println(\"通过removeLast()来遍历LinkedList：\");\ntry {\n    do {\n        if (copy3.size() > 0) {\n            System.out.print(copy3.getLast() + \" \");\n        }\n    } while(copy3.size() > 0 && copy3.removeLast() != null);\n    System.out.println();\n} catch (NoSuchElementException e) {\n    e.printStackTrace();\n}\n```\n\n### ArrayList与LinkedList异同\nArrayList与LinkedList都是List的具体实现类，所以存储的都是有序元素，可以通过下标进行随机访问元素，不过由于实现List的方式不同，导致了两者的差异。ArrayList的底层是数组，数组是一块连续的内存空间，优势就是随机访问速度快，但是插入删除元素导致其他元素的位置改变所以速度慢；LinkedList使用了链表的结构，内部类Entry存储了当前节点所包含的值，上一个节点，下一个节点等信息，查询时需要遍历所有元素找到所查元素这就意味着数据量越大查询速度越慢，除非位置离头部很近；但是插入、删除元素只需要对元素的前一元素的尾部和后一个元素的尾部进行修改即可，其他的元素不需要改动，所以速度很快。\n\n|List集合  |  实现List方式  |  查询速度| 插入删除速度 | 是否有序 |\n| :------ | :------ | :------ | :-------- | :------ |\n|ArrayList  |  数组  |  速度快| 速度慢 | 有序 |\n|LinkedList  |  双向链表  |  速度慢| 速度快 | 有序 |","slug":"ArrayList和LinkedList的区别比较","published":1,"updated":"2018-10-30T15:51:19.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvjg0014ogre8p1640jc","content":"<p>Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。而在集合类型中最常用的就是ArrayList和LinkedList这个集合类，所以了解这个的区别对于使用集合类很有帮助。</p>\n<h3 id=\"ArrayList与LinkedList的继承关系\"><a href=\"#ArrayList与LinkedList的继承关系\" class=\"headerlink\" title=\"ArrayList与LinkedList的继承关系\"></a>ArrayList与LinkedList的继承关系</h3><p>ArrayList与LinkedList都是List接口的实现类,因此都实现了List的所有未实现的方法,只是实现的方式有所不同。ArrayList实现了List接口,它是以数组的方式来实现的,数组的特性是可以使用索引的方式来快速定位对象的位置,因此对于快速的随机取得对象的需求,使用ArrayList实现执行效率上会比较好.。LinkedList是采用链表的方式来实现List接口的,它本身有自己特定的方法，如: addFirst(),addLast(),getFirst(),removeFirst()等. 由于是采用链表实现的,因此在进行insert和remove动作时在效率上要比ArrayList要好得多!适合用来实现Stack(堆栈)与Queue(队列),前者先进后出，后者是先进先出。</p>\n<a id=\"more\"></a>\n<p><img src=\"/assets/img/listDifferent.png\" alt=\"ArrayList与LinkedList的继承关系\"></p>\n<h3 id=\"ArrayList-介绍\"><a href=\"#ArrayList-介绍\" class=\"headerlink\" title=\"ArrayList 介绍\"></a>ArrayList 介绍</h3><ul>\n<li>ArrayList 是一个数组队列，和数组不同的是能够动态扩容，也就是我们说的动态数组;</li>\n<li>继承自AbstractLis，有实现了List接口，可以使用添加、修改、删除遍历等功能</li>\n<li>实现了RandomAccess接口，提供随机访问功能，即通过数组下标访问元素</li>\n<li>实现了Cloneable接口，覆盖了函数clone()，能被克隆</li>\n<li>实现了java.io.Serializable接口，支持序列化，能通过序列化去传输</li>\n<li>和Vector不同的是ArrayList不是线程安全的，所以涉及多线程的时候不建议使用</li>\n</ul>\n<p>ArrayList的构造函数：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造函数，底层数组大小默认为10，空间不如时新的容量=“(原始容量x3)/2 + 1”</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ArrayList() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定数组大小的构造函数，空间不足时容量会添加上次容量的一般</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ArrayList(<span class=\"keyword\">int</span> initialCapacity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//指定Collection的创建   </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ArrayList(Collection&lt;? <span class=\"keyword\">extends</span> E&gt; c) &#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">size</span> = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].<span class=\"keyword\">class</span>)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, <span class=\"keyword\">size</span>, Object[].<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ArrayList的三种遍历方法，使用随机访问(即，通过索引序号访问)效率最高；使用迭代器进行遍历 效率最低！</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认方式创建初始化</span></span><br><span class=\"line\">ArrayList&lt;Integer&gt; <span class=\"keyword\">array</span> = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\"><span class=\"comment\">//添加元素</span></span><br><span class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">array</span>.add(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"随机访问遍历数组array：\"</span>);</span><br><span class=\"line\"> <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">array</span>.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取元素</span></span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(<span class=\"keyword\">array</span>.<span class=\"built_in\">get</span>(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\"> System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"随机访问遍历数组array：\"</span>);</span><br><span class=\"line\"> <span class=\"built_in\">for</span> (Integer i: <span class=\"keyword\">array</span>) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(i + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代器进行遍历 效率最低！</span></span><br><span class=\"line\">Iterator iterator = <span class=\"keyword\">array</span>.iterator();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"迭代器遍历数组array中包含元素：\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(iterator.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LinkedList-介绍\"><a href=\"#LinkedList-介绍\" class=\"headerlink\" title=\"LinkedList 介绍\"></a>LinkedList 介绍</h3><ul>\n<li>LinkedList 是一个继承于AbstractSequentialList的双向链表,可以被当作堆栈、队列或双端队列进行操作</li>\n<li>实现了List接口，可以使用添加、修改、删除遍历等功能</li>\n<li>实现 Deque 接口，即能将LinkedList当作双端队列使用</li>\n<li>实现了Cloneable接口，覆盖了函数clone()，能被克隆</li>\n<li>实现了java.io.Serializable接口，支持序列化，能通过序列化去传输</li>\n<li>LinkedList是非线程同步的，所以多线程的场景不建议使用</li>\n</ul>\n<p>LinkedList的构造函数：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定Collection的创建   </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? <span class=\"keyword\">extends</span> E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>LinkedList的简单使用：<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LinkedList 实际上是通过双向链表去实现的</span></span><br><span class=\"line\"><span class=\"comment\"> * 内部类Node是双向链表节点所对应的数据结构：当前节点所包含的值，上一个节点，下一个节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">LinkedList linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加元素</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\">    linkedList.<span class=\"built_in\">add</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向头部添加元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\">linkedList.addFirst(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取第一个元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> first = linkedList.getFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组的第一个元素是：\"</span>+ first);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向尾部添加元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\">linkedList.addLast(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取最后一个元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> last = linkedList.getLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组的最后一个元素是：\"</span> + last);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除第一个元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> removeF = linkedList.removeFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素：\"</span> + removeF);</span><br><span class=\"line\">first = linkedList.getFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素后第一元素为：\"</span> + first);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除最后一个元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> removeL = linkedList.removeLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除最后一个元素：\"</span> + removeL);</span><br><span class=\"line\">last = linkedList.getLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除最后一个元素后最后一元素为：\"</span> + last);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过迭代器遍历</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过迭代器遍历:\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Iterator iterator = linkedList.listIterator(); iterator.hasNext();) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(iterator.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Deque队列时使用的添加方法 返回boolean值不会抛出异常</span></span><br><span class=\"line\"><span class=\"built_in\">boolean</span> offer = linkedList.offer(<span class=\"string\">\"offer\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList当做队列时添加元素offer返回：\"</span> + offer);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向队列添加到头部</span></span><br><span class=\"line\"><span class=\"built_in\">boolean</span> offerF = linkedList.offerFirst(<span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList当做队列时添加头部元素first返回：\"</span> + offerF);</span><br><span class=\"line\"><span class=\"comment\">//获取队列头部元素</span></span><br><span class=\"line\">first = linkedList.peekFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"peek linkedList第一个元素：\"</span> + first);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向队列尾部添加元素</span></span><br><span class=\"line\"><span class=\"built_in\">boolean</span> offerL = linkedList.offerLast(<span class=\"string\">\"last\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList当做队列时添加尾部元素last返回：\"</span> + offerL);</span><br><span class=\"line\"><span class=\"comment\">//获取队列尾部元素</span></span><br><span class=\"line\">last = linkedList.peekLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"peek linkedList最后一个元素：\"</span> + last);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除头部元素</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> pollF = linkedList.pollFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素：\"</span> + pollF);</span><br><span class=\"line\"><span class=\"comment\">//获取第一元素</span></span><br><span class=\"line\">first = linkedList.element();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素后第一元素为：\"</span> + first);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除尾部元素</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> pollL = linkedList.pollLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除最后一个元素：\"</span> + pollL);</span><br><span class=\"line\">last = linkedList.getLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除最后一个元素后最后一元素为：\"</span> + last);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过for循环遍历 不推荐使用 速度很慢</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过for循环遍历:\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; linkedList.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(linkedList.<span class=\"built_in\">get</span>(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时</span></span><br><span class=\"line\"><span class=\"comment\">//添加到头部</span></span><br><span class=\"line\">linkedList.push(<span class=\"string\">\"push\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组的第一元素为：\"</span> + linkedList.peekFirst());</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除头部元素</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> pop = linkedList.pop();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素：\"</span> + pop);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//for增强循环 推荐使用</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"for增强循环：\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">Object</span> o: linkedList) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(o + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//拷贝数组</span></span><br><span class=\"line\">LinkedList <span class=\"built_in\">copy</span> = (LinkedList) linkedList.clone();</span><br><span class=\"line\">LinkedList copy1 = (LinkedList) linkedList.clone();</span><br><span class=\"line\">LinkedList copy2 = (LinkedList) linkedList.clone();</span><br><span class=\"line\">LinkedList copy3 = (LinkedList) linkedList.clone();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 下面的遍历方法都会移除原始数据：</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用removeFist()或removeLast()效率最高</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//通过pollFirst()来遍历LinkedList</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过pollFirst()来遍历LinkedList：\"</span>);</span><br><span class=\"line\">do &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">copy</span>.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"built_in\">copy</span>.getFirst() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">copy</span>.pollFirst() != <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过pollLast()来遍历LinkedList</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过pollLast()来遍历LinkedList：\"</span>);</span><br><span class=\"line\">do &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy1.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">print</span>(copy1.getLast() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (copy1.pollLast() != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过removeFirst()来遍历LinkedList</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过removeFirst()来遍历LinkedList：\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy2.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">print</span>(copy2.getFirst() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(copy2.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span> &amp;&amp; copy2.removeFirst() != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NoSuchElementException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过removeLast()来遍历LinkedList</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过removeLast()来遍历LinkedList：\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy3.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">print</span>(copy3.getLast() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(copy3.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span> &amp;&amp; copy3.removeLast() != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NoSuchElementException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ArrayList与LinkedList异同\"><a href=\"#ArrayList与LinkedList异同\" class=\"headerlink\" title=\"ArrayList与LinkedList异同\"></a>ArrayList与LinkedList异同</h3><p>ArrayList与LinkedList都是List的具体实现类，所以存储的都是有序元素，可以通过下标进行随机访问元素，不过由于实现List的方式不同，导致了两者的差异。ArrayList的底层是数组，数组是一块连续的内存空间，优势就是随机访问速度快，但是插入删除元素导致其他元素的位置改变所以速度慢；LinkedList使用了链表的结构，内部类Entry存储了当前节点所包含的值，上一个节点，下一个节点等信息，查询时需要遍历所有元素找到所查元素这就意味着数据量越大查询速度越慢，除非位置离头部很近；但是插入、删除元素只需要对元素的前一元素的尾部和后一个元素的尾部进行修改即可，其他的元素不需要改动，所以速度很快。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">List集合</th>\n<th style=\"text-align:left\">实现List方式</th>\n<th style=\"text-align:left\">查询速度</th>\n<th style=\"text-align:left\">插入删除速度</th>\n<th style=\"text-align:left\">是否有序</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ArrayList</td>\n<td style=\"text-align:left\">数组</td>\n<td style=\"text-align:left\">速度快</td>\n<td style=\"text-align:left\">速度慢</td>\n<td style=\"text-align:left\">有序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedList</td>\n<td style=\"text-align:left\">双向链表</td>\n<td style=\"text-align:left\">速度慢</td>\n<td style=\"text-align:left\">速度快</td>\n<td style=\"text-align:left\">有序</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。而在集合类型中最常用的就是ArrayList和LinkedList这个集合类，所以了解这个的区别对于使用集合类很有帮助。</p>\n<h3 id=\"ArrayList与LinkedList的继承关系\"><a href=\"#ArrayList与LinkedList的继承关系\" class=\"headerlink\" title=\"ArrayList与LinkedList的继承关系\"></a>ArrayList与LinkedList的继承关系</h3><p>ArrayList与LinkedList都是List接口的实现类,因此都实现了List的所有未实现的方法,只是实现的方式有所不同。ArrayList实现了List接口,它是以数组的方式来实现的,数组的特性是可以使用索引的方式来快速定位对象的位置,因此对于快速的随机取得对象的需求,使用ArrayList实现执行效率上会比较好.。LinkedList是采用链表的方式来实现List接口的,它本身有自己特定的方法，如: addFirst(),addLast(),getFirst(),removeFirst()等. 由于是采用链表实现的,因此在进行insert和remove动作时在效率上要比ArrayList要好得多!适合用来实现Stack(堆栈)与Queue(队列),前者先进后出，后者是先进先出。</p>","more":"<p><img src=\"/assets/img/listDifferent.png\" alt=\"ArrayList与LinkedList的继承关系\"></p>\n<h3 id=\"ArrayList-介绍\"><a href=\"#ArrayList-介绍\" class=\"headerlink\" title=\"ArrayList 介绍\"></a>ArrayList 介绍</h3><ul>\n<li>ArrayList 是一个数组队列，和数组不同的是能够动态扩容，也就是我们说的动态数组;</li>\n<li>继承自AbstractLis，有实现了List接口，可以使用添加、修改、删除遍历等功能</li>\n<li>实现了RandomAccess接口，提供随机访问功能，即通过数组下标访问元素</li>\n<li>实现了Cloneable接口，覆盖了函数clone()，能被克隆</li>\n<li>实现了java.io.Serializable接口，支持序列化，能通过序列化去传输</li>\n<li>和Vector不同的是ArrayList不是线程安全的，所以涉及多线程的时候不建议使用</li>\n</ul>\n<p>ArrayList的构造函数：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造函数，底层数组大小默认为10，空间不如时新的容量=“(原始容量x3)/2 + 1”</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ArrayList() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定数组大小的构造函数，空间不足时容量会添加上次容量的一般</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ArrayList(<span class=\"keyword\">int</span> initialCapacity) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//指定Collection的创建   </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ArrayList(Collection&lt;? <span class=\"keyword\">extends</span> E&gt; c) &#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">size</span> = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].<span class=\"keyword\">class</span>)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, <span class=\"keyword\">size</span>, Object[].<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ArrayList的三种遍历方法，使用随机访问(即，通过索引序号访问)效率最高；使用迭代器进行遍历 效率最低！</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认方式创建初始化</span></span><br><span class=\"line\">ArrayList&lt;Integer&gt; <span class=\"keyword\">array</span> = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\"><span class=\"comment\">//添加元素</span></span><br><span class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">array</span>.add(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"随机访问遍历数组array：\"</span>);</span><br><span class=\"line\"> <span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">array</span>.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取元素</span></span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(<span class=\"keyword\">array</span>.<span class=\"built_in\">get</span>(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\"> System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"随机访问遍历数组array：\"</span>);</span><br><span class=\"line\"> <span class=\"built_in\">for</span> (Integer i: <span class=\"keyword\">array</span>) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(i + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代器进行遍历 效率最低！</span></span><br><span class=\"line\">Iterator iterator = <span class=\"keyword\">array</span>.iterator();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"迭代器遍历数组array中包含元素：\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(iterator.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LinkedList-介绍\"><a href=\"#LinkedList-介绍\" class=\"headerlink\" title=\"LinkedList 介绍\"></a>LinkedList 介绍</h3><ul>\n<li>LinkedList 是一个继承于AbstractSequentialList的双向链表,可以被当作堆栈、队列或双端队列进行操作</li>\n<li>实现了List接口，可以使用添加、修改、删除遍历等功能</li>\n<li>实现 Deque 接口，即能将LinkedList当作双端队列使用</li>\n<li>实现了Cloneable接口，覆盖了函数clone()，能被克隆</li>\n<li>实现了java.io.Serializable接口，支持序列化，能通过序列化去传输</li>\n<li>LinkedList是非线程同步的，所以多线程的场景不建议使用</li>\n</ul>\n<p>LinkedList的构造函数：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//指定Collection的创建   </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? <span class=\"keyword\">extends</span> E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>LinkedList的简单使用：<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LinkedList 实际上是通过双向链表去实现的</span></span><br><span class=\"line\"><span class=\"comment\"> * 内部类Node是双向链表节点所对应的数据结构：当前节点所包含的值，上一个节点，下一个节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">LinkedList linkedList = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加元素</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\">    linkedList.<span class=\"built_in\">add</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向头部添加元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\">linkedList.addFirst(<span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取第一个元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> first = linkedList.getFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组的第一个元素是：\"</span>+ first);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向尾部添加元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\">linkedList.addLast(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取最后一个元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> last = linkedList.getLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组的最后一个元素是：\"</span> + last);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除第一个元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> removeF = linkedList.removeFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素：\"</span> + removeF);</span><br><span class=\"line\">first = linkedList.getFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素后第一元素为：\"</span> + first);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除最后一个元素 属于Collection接口的方法 会抛出异常</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> removeL = linkedList.removeLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除最后一个元素：\"</span> + removeL);</span><br><span class=\"line\">last = linkedList.getLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除最后一个元素后最后一元素为：\"</span> + last);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过迭代器遍历</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过迭代器遍历:\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Iterator iterator = linkedList.listIterator(); iterator.hasNext();) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(iterator.next() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Deque队列时使用的添加方法 返回boolean值不会抛出异常</span></span><br><span class=\"line\"><span class=\"built_in\">boolean</span> offer = linkedList.offer(<span class=\"string\">\"offer\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList当做队列时添加元素offer返回：\"</span> + offer);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向队列添加到头部</span></span><br><span class=\"line\"><span class=\"built_in\">boolean</span> offerF = linkedList.offerFirst(<span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList当做队列时添加头部元素first返回：\"</span> + offerF);</span><br><span class=\"line\"><span class=\"comment\">//获取队列头部元素</span></span><br><span class=\"line\">first = linkedList.peekFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"peek linkedList第一个元素：\"</span> + first);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向队列尾部添加元素</span></span><br><span class=\"line\"><span class=\"built_in\">boolean</span> offerL = linkedList.offerLast(<span class=\"string\">\"last\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList当做队列时添加尾部元素last返回：\"</span> + offerL);</span><br><span class=\"line\"><span class=\"comment\">//获取队列尾部元素</span></span><br><span class=\"line\">last = linkedList.peekLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"peek linkedList最后一个元素：\"</span> + last);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除头部元素</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> pollF = linkedList.pollFirst();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素：\"</span> + pollF);</span><br><span class=\"line\"><span class=\"comment\">//获取第一元素</span></span><br><span class=\"line\">first = linkedList.element();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素后第一元素为：\"</span> + first);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除尾部元素</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> pollL = linkedList.pollLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除最后一个元素：\"</span> + pollL);</span><br><span class=\"line\">last = linkedList.getLast();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除最后一个元素后最后一元素为：\"</span> + last);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过for循环遍历 不推荐使用 速度很慢</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过for循环遍历:\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; linkedList.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(linkedList.<span class=\"built_in\">get</span>(i) + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时</span></span><br><span class=\"line\"><span class=\"comment\">//添加到头部</span></span><br><span class=\"line\">linkedList.push(<span class=\"string\">\"push\"</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组的第一元素为：\"</span> + linkedList.peekFirst());</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//移除头部元素</span></span><br><span class=\"line\"><span class=\"keyword\">Object</span> pop = linkedList.pop();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"linkedList数组移除第一个元素：\"</span> + pop);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//for增强循环 推荐使用</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"for增强循环：\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">Object</span> o: linkedList) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">print</span>(o + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//拷贝数组</span></span><br><span class=\"line\">LinkedList <span class=\"built_in\">copy</span> = (LinkedList) linkedList.clone();</span><br><span class=\"line\">LinkedList copy1 = (LinkedList) linkedList.clone();</span><br><span class=\"line\">LinkedList copy2 = (LinkedList) linkedList.clone();</span><br><span class=\"line\">LinkedList copy3 = (LinkedList) linkedList.clone();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 下面的遍历方法都会移除原始数据：</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用removeFist()或removeLast()效率最高</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">//通过pollFirst()来遍历LinkedList</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过pollFirst()来遍历LinkedList：\"</span>);</span><br><span class=\"line\">do &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">copy</span>.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"built_in\">copy</span>.getFirst() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">copy</span>.pollFirst() != <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过pollLast()来遍历LinkedList</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过pollLast()来遍历LinkedList：\"</span>);</span><br><span class=\"line\">do &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy1.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">print</span>(copy1.getLast() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (copy1.pollLast() != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过removeFirst()来遍历LinkedList</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过removeFirst()来遍历LinkedList：\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy2.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">print</span>(copy2.getFirst() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(copy2.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span> &amp;&amp; copy2.removeFirst() != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NoSuchElementException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过removeLast()来遍历LinkedList</span></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"通过removeLast()来遍历LinkedList：\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy3.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">print</span>(copy3.getLast() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(copy3.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span> &amp;&amp; copy3.removeLast() != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NoSuchElementException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ArrayList与LinkedList异同\"><a href=\"#ArrayList与LinkedList异同\" class=\"headerlink\" title=\"ArrayList与LinkedList异同\"></a>ArrayList与LinkedList异同</h3><p>ArrayList与LinkedList都是List的具体实现类，所以存储的都是有序元素，可以通过下标进行随机访问元素，不过由于实现List的方式不同，导致了两者的差异。ArrayList的底层是数组，数组是一块连续的内存空间，优势就是随机访问速度快，但是插入删除元素导致其他元素的位置改变所以速度慢；LinkedList使用了链表的结构，内部类Entry存储了当前节点所包含的值，上一个节点，下一个节点等信息，查询时需要遍历所有元素找到所查元素这就意味着数据量越大查询速度越慢，除非位置离头部很近；但是插入、删除元素只需要对元素的前一元素的尾部和后一个元素的尾部进行修改即可，其他的元素不需要改动，所以速度很快。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">List集合</th>\n<th style=\"text-align:left\">实现List方式</th>\n<th style=\"text-align:left\">查询速度</th>\n<th style=\"text-align:left\">插入删除速度</th>\n<th style=\"text-align:left\">是否有序</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ArrayList</td>\n<td style=\"text-align:left\">数组</td>\n<td style=\"text-align:left\">速度快</td>\n<td style=\"text-align:left\">速度慢</td>\n<td style=\"text-align:left\">有序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedList</td>\n<td style=\"text-align:left\">双向链表</td>\n<td style=\"text-align:left\">速度慢</td>\n<td style=\"text-align:left\">速度快</td>\n<td style=\"text-align:left\">有序</td>\n</tr>\n</tbody>\n</table>"},{"title":"Semaphore源码解析","date":"2018-11-16T14:23:48.000Z","toc":true,"_content":"在java 多线程编程中常常需要处理同步问题，处理同步问题时常用的关键字就是synchronized，synchronized的含义就是同步的、互斥的锁，表示同一时刻只能有一个线程能获取执行代码的锁，但是实际情况和应用场景往往是需要多个线程获取锁，并发执行代码，这个时候使用synchronized就不合适了。而java并发工具类中的Semaphore类，就是专门用来处理这种情况的。\n\n<!--more-->\n\n### Semaphore含义\n[Semaphore](https://baike.baidu.com/item/semaphore/1322231) 是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。简单来说，Semaphore就是线程允许执行代码的信号量，或者说是许可证，每个acquire方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个release方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。 \n\n### Semaphore购票示例\n```\npublic class Ticket {\n\n    public static void main(String [] args) {\n\n        List<User> userList = new ArrayList<>(6);\n        User user1 = new User(\"张三\");\n        userList.add(user1);\n        User user2 = new User(\"李四\");\n        userList.add(user2);\n        User user3 = new User(\"王五\");\n        userList.add(user3);\n        User user4 = new User(\"小明\");\n        userList.add(user4);\n        User user5 = new User(\"小李\");\n        userList.add(user5);\n        User user6 = new User(\"韩梅梅\");\n        userList.add(user6);\n\n        //模拟6个用户同时买票\n        for (User user: userList) {\n           user.start();\n        }\n    }\n}\n\nclass User extends Thread{\n\n    // 声明4个窗口窗口\n    final static Semaphore windows = new Semaphore(4);\n\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // 占用窗口\n            windows.acquire();\n            System.out.println(name + \": 开始买票\");\n            // 睡2秒，模拟买票流程\n            sleep(2000);\n            System.out.println(name + \": 购票成功\");\n            // 释放窗口\n            windows.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n从上面可以看到，创建了4个购票窗口，6个用户同时购买，每次购买会调用acquire()获取一个许可证，在购买结束后调用release()释放一个许可证，同一时刻最多支持4人买票，直到所有用户购买结束。\n\n运行结果：\n![semaphore示例结果](/assets/img/semaphoreResult.png)\n\n### Semaphore构造函数\n默认构造函数，只需要指定许可数量，默认非公平模式。\n```\npublic Semaphore(int permits) {\n    sync = new NonfairSync(permits);\n} \n ```\n指定许可数量和是否为公平模式的构造函数：\n```\npublic Semaphore(int permits, boolean fair) {\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n```\nSemaphore内部基于AQS（AbstractQueuedSynchronizer）的共享模式，所以实现都委托给了Sync类。 看一下NonfairSync的源码可以发现，其实是直接调用了父类Sync类的构造函数。\n```\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = -2694183684443567898L;\n\n    NonfairSync(int permits) {\n        super(permits);\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        return nonfairTryAcquireShared(acquires);\n    }\n}\n```\n查看Sync类的源码发现，其实Sync类的构造函数是直接调用了AQS（AbstractQueuedSynchronizer）的setState()方法，也就是AQS中的设置许可数量方法。\n```\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 1192457210091910933L;\n\n    Sync(int permits) {\n        setState(permits);\n    }\n    ...\n}\n```\n\n### 获取许可\nSemaphore默认构造函数是使用的非公平模式，所以我们先看一下非公平模式的获取许可方法acquire()源码。\n```\npublic void acquire() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n```\n发现其实是调用的Sync类继承自AQS的acquireSharedInterruptibly()方法。\n```\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n```\nAQS子类如果要使用共享模式的话，需要实现tryAcquireShared方法，下面看NonfairSync的该方法实现：\n```\nfinal int nonfairTryAcquireShared(int acquires) {\n    for (;;) {\n        //获取剩余许可数量\n        int available = getState();\n        //计算给完这次许可数量后的个数\n        int remaining = available - acquires;\n        //如果许可不够或者可以将许可数量重置的话，返回\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n```\n从上面可以看到每次获取许可都会重新计算许可剩余数量，当剩余数量为0的时候后面的线程将会阻塞，无法执行。\n\n公平模式的获取许可：\n```\nprotected int tryAcquireShared(int acquires) {\n    for (;;) {\n        //如果前面有线程再等待，直接返回-1\n        if (hasQueuedPredecessors())\n            return -1;\n        //获取剩余许可数量\n        int available = getState();\n        //计算给完这次许可数量后的个数\n        int remaining = available - acquires;\n        //如果许可不够或者可以将许可数量重置的话，返回\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n```\n可以看出公平模式除了会首先判断当前队列中有没有线程在等待以外，其他和非公平模式一样，所以公平模式有线程已经在等待，那么下一个线程只能进入等待队列，直到上一个线程执行结束。\n\n### 释放许可\n查看源码可以知道释放许可，最终是调用的AQS的releaseShared()方法。\n```\npublic void release() {\n    sync.releaseShared(1);\n}\n```\nreleaseShared方法在AQS中，如下：\n```\npublic final boolean releaseShared(int arg) {\n    //判断是否改变许可成功\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n```\n首先会执行tryReleaseShared()方法判断是否改变许可成功：\n```\nprotected final boolean tryReleaseShared(int releases) {\n    for (;;) {\n        //获取当前许可数量\n        int current = getState();\n        //计算回收后的数量\n        int next = current + releases;\n        //CAS改变许可数量成功，返回true\n        if (next < current) // overflow\n            throw new Error(\"Maximum permit count exceeded\");\n        if (compareAndSetState(current, next))\n            return true;\n    }\n}\n```\n一旦CAS改变许可数量成功，那么就会调用doReleaseShared()方法释放阻塞的线程。\n```\n private void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n```\n\n### 查看许可数量\n可以通过availablePermits()查看可用许可数量，用于判断是否还有许可可以使用。\n```\npublic int availablePermits() {\n    return sync.getPermits();\n}\n```\n除了availablePermits()方法，Semaphore还可以一次将剩余的许可数量全部取走，那就是drainPermits()方法。\n```\npublic int drainPermits() {\n    return sync.drainPermits();\n}\n```\n调用了Sync类的实现：\n```\nfinal int drainPermits() {\n    for (;;) {\n        //获取当前许可数量\n        int current = getState();\n        //许可数量为0直接返回0\n        if (current == 0 || compareAndSetState(current, 0))\n            return current;\n    }\n}\n```\n\n## 总结\nSemaphore就是用于管理许可的信号量，其内部是基于AQS的共享模式，AQS的状态表示许可证的数量，在许可证数量不够时，线程将会被挂起；而一旦有一个线程释放一个资源，那么就有可能重新唤醒等待队列中的线程继续执行。所以应用场景中需要限制获取某种资源的线程数量的时候往往使用Semaphore。","source":"_posts/2018-11-16-Semaphore源码解析.md","raw":"---\ntitle: Semaphore源码解析\ndate: 2018-11-16 22:23:48\ntoc: true\ntags:\n    - java\n    - 多线程\n    - Semaphore\n    - 源码\n---\n在java 多线程编程中常常需要处理同步问题，处理同步问题时常用的关键字就是synchronized，synchronized的含义就是同步的、互斥的锁，表示同一时刻只能有一个线程能获取执行代码的锁，但是实际情况和应用场景往往是需要多个线程获取锁，并发执行代码，这个时候使用synchronized就不合适了。而java并发工具类中的Semaphore类，就是专门用来处理这种情况的。\n\n<!--more-->\n\n### Semaphore含义\n[Semaphore](https://baike.baidu.com/item/semaphore/1322231) 是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。简单来说，Semaphore就是线程允许执行代码的信号量，或者说是许可证，每个acquire方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个release方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。 \n\n### Semaphore购票示例\n```\npublic class Ticket {\n\n    public static void main(String [] args) {\n\n        List<User> userList = new ArrayList<>(6);\n        User user1 = new User(\"张三\");\n        userList.add(user1);\n        User user2 = new User(\"李四\");\n        userList.add(user2);\n        User user3 = new User(\"王五\");\n        userList.add(user3);\n        User user4 = new User(\"小明\");\n        userList.add(user4);\n        User user5 = new User(\"小李\");\n        userList.add(user5);\n        User user6 = new User(\"韩梅梅\");\n        userList.add(user6);\n\n        //模拟6个用户同时买票\n        for (User user: userList) {\n           user.start();\n        }\n    }\n}\n\nclass User extends Thread{\n\n    // 声明4个窗口窗口\n    final static Semaphore windows = new Semaphore(4);\n\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // 占用窗口\n            windows.acquire();\n            System.out.println(name + \": 开始买票\");\n            // 睡2秒，模拟买票流程\n            sleep(2000);\n            System.out.println(name + \": 购票成功\");\n            // 释放窗口\n            windows.release();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n从上面可以看到，创建了4个购票窗口，6个用户同时购买，每次购买会调用acquire()获取一个许可证，在购买结束后调用release()释放一个许可证，同一时刻最多支持4人买票，直到所有用户购买结束。\n\n运行结果：\n![semaphore示例结果](/assets/img/semaphoreResult.png)\n\n### Semaphore构造函数\n默认构造函数，只需要指定许可数量，默认非公平模式。\n```\npublic Semaphore(int permits) {\n    sync = new NonfairSync(permits);\n} \n ```\n指定许可数量和是否为公平模式的构造函数：\n```\npublic Semaphore(int permits, boolean fair) {\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n```\nSemaphore内部基于AQS（AbstractQueuedSynchronizer）的共享模式，所以实现都委托给了Sync类。 看一下NonfairSync的源码可以发现，其实是直接调用了父类Sync类的构造函数。\n```\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = -2694183684443567898L;\n\n    NonfairSync(int permits) {\n        super(permits);\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        return nonfairTryAcquireShared(acquires);\n    }\n}\n```\n查看Sync类的源码发现，其实Sync类的构造函数是直接调用了AQS（AbstractQueuedSynchronizer）的setState()方法，也就是AQS中的设置许可数量方法。\n```\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 1192457210091910933L;\n\n    Sync(int permits) {\n        setState(permits);\n    }\n    ...\n}\n```\n\n### 获取许可\nSemaphore默认构造函数是使用的非公平模式，所以我们先看一下非公平模式的获取许可方法acquire()源码。\n```\npublic void acquire() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n```\n发现其实是调用的Sync类继承自AQS的acquireSharedInterruptibly()方法。\n```\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n```\nAQS子类如果要使用共享模式的话，需要实现tryAcquireShared方法，下面看NonfairSync的该方法实现：\n```\nfinal int nonfairTryAcquireShared(int acquires) {\n    for (;;) {\n        //获取剩余许可数量\n        int available = getState();\n        //计算给完这次许可数量后的个数\n        int remaining = available - acquires;\n        //如果许可不够或者可以将许可数量重置的话，返回\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n```\n从上面可以看到每次获取许可都会重新计算许可剩余数量，当剩余数量为0的时候后面的线程将会阻塞，无法执行。\n\n公平模式的获取许可：\n```\nprotected int tryAcquireShared(int acquires) {\n    for (;;) {\n        //如果前面有线程再等待，直接返回-1\n        if (hasQueuedPredecessors())\n            return -1;\n        //获取剩余许可数量\n        int available = getState();\n        //计算给完这次许可数量后的个数\n        int remaining = available - acquires;\n        //如果许可不够或者可以将许可数量重置的话，返回\n        if (remaining < 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n```\n可以看出公平模式除了会首先判断当前队列中有没有线程在等待以外，其他和非公平模式一样，所以公平模式有线程已经在等待，那么下一个线程只能进入等待队列，直到上一个线程执行结束。\n\n### 释放许可\n查看源码可以知道释放许可，最终是调用的AQS的releaseShared()方法。\n```\npublic void release() {\n    sync.releaseShared(1);\n}\n```\nreleaseShared方法在AQS中，如下：\n```\npublic final boolean releaseShared(int arg) {\n    //判断是否改变许可成功\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n```\n首先会执行tryReleaseShared()方法判断是否改变许可成功：\n```\nprotected final boolean tryReleaseShared(int releases) {\n    for (;;) {\n        //获取当前许可数量\n        int current = getState();\n        //计算回收后的数量\n        int next = current + releases;\n        //CAS改变许可数量成功，返回true\n        if (next < current) // overflow\n            throw new Error(\"Maximum permit count exceeded\");\n        if (compareAndSetState(current, next))\n            return true;\n    }\n}\n```\n一旦CAS改变许可数量成功，那么就会调用doReleaseShared()方法释放阻塞的线程。\n```\n private void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n```\n\n### 查看许可数量\n可以通过availablePermits()查看可用许可数量，用于判断是否还有许可可以使用。\n```\npublic int availablePermits() {\n    return sync.getPermits();\n}\n```\n除了availablePermits()方法，Semaphore还可以一次将剩余的许可数量全部取走，那就是drainPermits()方法。\n```\npublic int drainPermits() {\n    return sync.drainPermits();\n}\n```\n调用了Sync类的实现：\n```\nfinal int drainPermits() {\n    for (;;) {\n        //获取当前许可数量\n        int current = getState();\n        //许可数量为0直接返回0\n        if (current == 0 || compareAndSetState(current, 0))\n            return current;\n    }\n}\n```\n\n## 总结\nSemaphore就是用于管理许可的信号量，其内部是基于AQS的共享模式，AQS的状态表示许可证的数量，在许可证数量不够时，线程将会被挂起；而一旦有一个线程释放一个资源，那么就有可能重新唤醒等待队列中的线程继续执行。所以应用场景中需要限制获取某种资源的线程数量的时候往往使用Semaphore。","slug":"Semaphore源码解析","published":1,"updated":"2018-11-16T15:50:48.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvjk0015ogrec3rin4as","content":"<p>在java 多线程编程中常常需要处理同步问题，处理同步问题时常用的关键字就是synchronized，synchronized的含义就是同步的、互斥的锁，表示同一时刻只能有一个线程能获取执行代码的锁，但是实际情况和应用场景往往是需要多个线程获取锁，并发执行代码，这个时候使用synchronized就不合适了。而java并发工具类中的Semaphore类，就是专门用来处理这种情况的。</p>\n<a id=\"more\"></a>\n<h3 id=\"Semaphore含义\"><a href=\"#Semaphore含义\" class=\"headerlink\" title=\"Semaphore含义\"></a>Semaphore含义</h3><p><a href=\"https://baike.baidu.com/item/semaphore/1322231\" target=\"_blank\" rel=\"noopener\">Semaphore</a> 是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。简单来说，Semaphore就是线程允许执行代码的信号量，或者说是许可证，每个acquire方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个release方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。 </p>\n<h3 id=\"Semaphore购票示例\"><a href=\"#Semaphore购票示例\" class=\"headerlink\" title=\"Semaphore购票示例\"></a>Semaphore购票示例</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Ticket</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String [] args</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;User&gt; userList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">6</span>);</span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user1);</span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user2);</span><br><span class=\"line\">        User user3 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"王五\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user3);</span><br><span class=\"line\">        User user4 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"小明\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user4);</span><br><span class=\"line\">        User user5 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"小李\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user5);</span><br><span class=\"line\">        User user6 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"韩梅梅\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user6);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//模拟6个用户同时买票</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user: userList) &#123;</span><br><span class=\"line\">           user.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明4个窗口窗口</span></span><br><span class=\"line\">    final <span class=\"keyword\">static</span> Semaphore windows = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span>(<span class=\"params\">String name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 占用窗口</span></span><br><span class=\"line\">            windows.acquire();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(name + <span class=\"string\">\": 开始买票\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 睡2秒，模拟买票流程</span></span><br><span class=\"line\">            sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(name + <span class=\"string\">\": 购票成功\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 释放窗口</span></span><br><span class=\"line\">            windows.release();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面可以看到，创建了4个购票窗口，6个用户同时购买，每次购买会调用acquire()获取一个许可证，在购买结束后调用release()释放一个许可证，同一时刻最多支持4人买票，直到所有用户购买结束。</p>\n<p>运行结果：<br><img src=\"/assets/img/semaphoreResult.png\" alt=\"semaphore示例结果\"></p>\n<h3 id=\"Semaphore构造函数\"><a href=\"#Semaphore构造函数\" class=\"headerlink\" title=\"Semaphore构造函数\"></a>Semaphore构造函数</h3><p>默认构造函数，只需要指定许可数量，默认非公平模式。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123;</span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>指定许可数量和是否为公平模式的构造函数：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync(permits) : <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Semaphore内部基于AQS（AbstractQueuedSynchronizer）的共享模式，所以实现都委托给了Sync类。 看一下NonfairSync的源码可以发现，其实是直接调用了父类Sync类的构造函数。<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> static <span class=\"keyword\">final</span> long serialVersionUID = <span class=\"number\">-2694183684443567898</span>L;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">NonfairSync</span>(int permits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> int tryAcquireShared(int acquires) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquireShared(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看Sync类的源码发现，其实Sync类的构造函数是直接调用了AQS（AbstractQueuedSynchronizer）的setState()方法，也就是AQS中的设置许可数量方法。<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> static <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> static <span class=\"keyword\">final</span> long serialVersionUID = <span class=\"number\">1192457210091910933</span>L;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Sync</span>(int permits) &#123;</span><br><span class=\"line\">        setState(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取许可\"><a href=\"#获取许可\" class=\"headerlink\" title=\"获取许可\"></a>获取许可</h3><p>Semaphore默认构造函数是使用的非公平模式，所以我们先看一下非公平模式的获取许可方法acquire()源码。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>发现其实是调用的Sync类继承自AQS的acquireSharedInterruptibly()方法。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> acquireInterruptibly(<span class=\"keyword\">int</span> arg)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg))</span><br><span class=\"line\">        doAcquireInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AQS子类如果要使用共享模式的话，需要实现tryAcquireShared方法，下面看NonfairSync的该方法实现：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final <span class=\"keyword\">int</span> nonfairTryAcquireShared(<span class=\"keyword\">int</span> acquires) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取剩余许可数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> <span class=\"built_in\">available</span> = getState();</span><br><span class=\"line\">        <span class=\"comment\">//计算给完这次许可数量后的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> remaining = <span class=\"built_in\">available</span> - acquires;</span><br><span class=\"line\">        <span class=\"comment\">//如果许可不够或者可以将许可数量重置的话，返回</span></span><br><span class=\"line\">        <span class=\"built_in\">if</span> (remaining &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            compareAndSetState(<span class=\"built_in\">available</span>, remaining))</span><br><span class=\"line\">            <span class=\"built_in\">return</span> remaining;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从上面可以看到每次获取许可都会重新计算许可剩余数量，当剩余数量为0的时候后面的线程将会阻塞，无法执行。</p>\n<p>公平模式的获取许可：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> tryAcquireShared(<span class=\"keyword\">int</span> acquires) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果前面有线程再等待，直接返回-1</span></span><br><span class=\"line\">        <span class=\"built_in\">if</span> (hasQueuedPredecessors())</span><br><span class=\"line\">            <span class=\"built_in\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//获取剩余许可数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> <span class=\"built_in\">available</span> = getState();</span><br><span class=\"line\">        <span class=\"comment\">//计算给完这次许可数量后的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> remaining = <span class=\"built_in\">available</span> - acquires;</span><br><span class=\"line\">        <span class=\"comment\">//如果许可不够或者可以将许可数量重置的话，返回</span></span><br><span class=\"line\">        <span class=\"built_in\">if</span> (remaining &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            compareAndSetState(<span class=\"built_in\">available</span>, remaining))</span><br><span class=\"line\">            <span class=\"built_in\">return</span> remaining;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出公平模式除了会首先判断当前队列中有没有线程在等待以外，其他和非公平模式一样，所以公平模式有线程已经在等待，那么下一个线程只能进入等待队列，直到上一个线程执行结束。</p>\n<h3 id=\"释放许可\"><a href=\"#释放许可\" class=\"headerlink\" title=\"释放许可\"></a>释放许可</h3><p>查看源码可以知道释放许可，最终是调用的AQS的releaseShared()方法。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>releaseShared方法在AQS中，如下：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否改变许可成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先会执行tryReleaseShared()方法判断是否改变许可成功：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> tryReleaseShared(<span class=\"keyword\">int</span> releases) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前许可数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">        <span class=\"comment\">//计算回收后的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> <span class=\"keyword\">next</span> = current + releases;</span><br><span class=\"line\">        <span class=\"comment\">//CAS改变许可数量成功，返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">next</span> &lt; current) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum permit count exceeded\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(current, <span class=\"keyword\">next</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一旦CAS改变许可数量成功，那么就会调用doReleaseShared()方法释放阻塞的线程。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head)                   <span class=\"comment\">// loop if head changed</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看许可数量\"><a href=\"#查看许可数量\" class=\"headerlink\" title=\"查看许可数量\"></a>查看许可数量</h3><p>可以通过availablePermits()查看可用许可数量，用于判断是否还有许可可以使用。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">availablePermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">return</span> sync.<span class=\"title\">getPermits</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了availablePermits()方法，Semaphore还可以一次将剩余的许可数量全部取走，那就是drainPermits()方法。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">drainPermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">return</span> sync.<span class=\"title\">drainPermits</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用了Sync类的实现：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">drainPermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前许可数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">        <span class=\"comment\">//许可数量为0直接返回0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"number\">0</span> || compareAndSetState(current, <span class=\"number\">0</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Semaphore就是用于管理许可的信号量，其内部是基于AQS的共享模式，AQS的状态表示许可证的数量，在许可证数量不够时，线程将会被挂起；而一旦有一个线程释放一个资源，那么就有可能重新唤醒等待队列中的线程继续执行。所以应用场景中需要限制获取某种资源的线程数量的时候往往使用Semaphore。</p>\n","site":{"data":{}},"excerpt":"<p>在java 多线程编程中常常需要处理同步问题，处理同步问题时常用的关键字就是synchronized，synchronized的含义就是同步的、互斥的锁，表示同一时刻只能有一个线程能获取执行代码的锁，但是实际情况和应用场景往往是需要多个线程获取锁，并发执行代码，这个时候使用synchronized就不合适了。而java并发工具类中的Semaphore类，就是专门用来处理这种情况的。</p>","more":"<h3 id=\"Semaphore含义\"><a href=\"#Semaphore含义\" class=\"headerlink\" title=\"Semaphore含义\"></a>Semaphore含义</h3><p><a href=\"https://baike.baidu.com/item/semaphore/1322231\" target=\"_blank\" rel=\"noopener\">Semaphore</a> 是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。简单来说，Semaphore就是线程允许执行代码的信号量，或者说是许可证，每个acquire方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个release方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。 </p>\n<h3 id=\"Semaphore购票示例\"><a href=\"#Semaphore购票示例\" class=\"headerlink\" title=\"Semaphore购票示例\"></a>Semaphore购票示例</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Ticket</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String [] args</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;User&gt; userList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">6</span>);</span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user1);</span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user2);</span><br><span class=\"line\">        User user3 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"王五\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user3);</span><br><span class=\"line\">        User user4 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"小明\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user4);</span><br><span class=\"line\">        User user5 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"小李\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user5);</span><br><span class=\"line\">        User user6 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"韩梅梅\"</span>);</span><br><span class=\"line\">        userList.<span class=\"keyword\">add</span>(user6);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//模拟6个用户同时买票</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user: userList) &#123;</span><br><span class=\"line\">           user.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明4个窗口窗口</span></span><br><span class=\"line\">    final <span class=\"keyword\">static</span> Semaphore windows = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span>(<span class=\"params\">String name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 占用窗口</span></span><br><span class=\"line\">            windows.acquire();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(name + <span class=\"string\">\": 开始买票\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 睡2秒，模拟买票流程</span></span><br><span class=\"line\">            sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(name + <span class=\"string\">\": 购票成功\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 释放窗口</span></span><br><span class=\"line\">            windows.release();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面可以看到，创建了4个购票窗口，6个用户同时购买，每次购买会调用acquire()获取一个许可证，在购买结束后调用release()释放一个许可证，同一时刻最多支持4人买票，直到所有用户购买结束。</p>\n<p>运行结果：<br><img src=\"/assets/img/semaphoreResult.png\" alt=\"semaphore示例结果\"></p>\n<h3 id=\"Semaphore构造函数\"><a href=\"#Semaphore构造函数\" class=\"headerlink\" title=\"Semaphore构造函数\"></a>Semaphore构造函数</h3><p>默认构造函数，只需要指定许可数量，默认非公平模式。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123;</span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>指定许可数量和是否为公平模式的构造函数：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync(permits) : <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Semaphore内部基于AQS（AbstractQueuedSynchronizer）的共享模式，所以实现都委托给了Sync类。 看一下NonfairSync的源码可以发现，其实是直接调用了父类Sync类的构造函数。<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> static <span class=\"keyword\">final</span> long serialVersionUID = <span class=\"number\">-2694183684443567898</span>L;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">NonfairSync</span>(int permits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> int tryAcquireShared(int acquires) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquireShared(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看Sync类的源码发现，其实Sync类的构造函数是直接调用了AQS（AbstractQueuedSynchronizer）的setState()方法，也就是AQS中的设置许可数量方法。<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> static <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> static <span class=\"keyword\">final</span> long serialVersionUID = <span class=\"number\">1192457210091910933</span>L;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Sync</span>(int permits) &#123;</span><br><span class=\"line\">        setState(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取许可\"><a href=\"#获取许可\" class=\"headerlink\" title=\"获取许可\"></a>获取许可</h3><p>Semaphore默认构造函数是使用的非公平模式，所以我们先看一下非公平模式的获取许可方法acquire()源码。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>发现其实是调用的Sync类继承自AQS的acquireSharedInterruptibly()方法。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> acquireInterruptibly(<span class=\"keyword\">int</span> arg)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg))</span><br><span class=\"line\">        doAcquireInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AQS子类如果要使用共享模式的话，需要实现tryAcquireShared方法，下面看NonfairSync的该方法实现：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final <span class=\"keyword\">int</span> nonfairTryAcquireShared(<span class=\"keyword\">int</span> acquires) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取剩余许可数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> <span class=\"built_in\">available</span> = getState();</span><br><span class=\"line\">        <span class=\"comment\">//计算给完这次许可数量后的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> remaining = <span class=\"built_in\">available</span> - acquires;</span><br><span class=\"line\">        <span class=\"comment\">//如果许可不够或者可以将许可数量重置的话，返回</span></span><br><span class=\"line\">        <span class=\"built_in\">if</span> (remaining &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            compareAndSetState(<span class=\"built_in\">available</span>, remaining))</span><br><span class=\"line\">            <span class=\"built_in\">return</span> remaining;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从上面可以看到每次获取许可都会重新计算许可剩余数量，当剩余数量为0的时候后面的线程将会阻塞，无法执行。</p>\n<p>公平模式的获取许可：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> tryAcquireShared(<span class=\"keyword\">int</span> acquires) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果前面有线程再等待，直接返回-1</span></span><br><span class=\"line\">        <span class=\"built_in\">if</span> (hasQueuedPredecessors())</span><br><span class=\"line\">            <span class=\"built_in\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//获取剩余许可数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> <span class=\"built_in\">available</span> = getState();</span><br><span class=\"line\">        <span class=\"comment\">//计算给完这次许可数量后的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> remaining = <span class=\"built_in\">available</span> - acquires;</span><br><span class=\"line\">        <span class=\"comment\">//如果许可不够或者可以将许可数量重置的话，返回</span></span><br><span class=\"line\">        <span class=\"built_in\">if</span> (remaining &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            compareAndSetState(<span class=\"built_in\">available</span>, remaining))</span><br><span class=\"line\">            <span class=\"built_in\">return</span> remaining;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出公平模式除了会首先判断当前队列中有没有线程在等待以外，其他和非公平模式一样，所以公平模式有线程已经在等待，那么下一个线程只能进入等待队列，直到上一个线程执行结束。</p>\n<h3 id=\"释放许可\"><a href=\"#释放许可\" class=\"headerlink\" title=\"释放许可\"></a>释放许可</h3><p>查看源码可以知道释放许可，最终是调用的AQS的releaseShared()方法。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>releaseShared方法在AQS中，如下：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否改变许可成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先会执行tryReleaseShared()方法判断是否改变许可成功：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> tryReleaseShared(<span class=\"keyword\">int</span> releases) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前许可数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">        <span class=\"comment\">//计算回收后的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> <span class=\"keyword\">next</span> = current + releases;</span><br><span class=\"line\">        <span class=\"comment\">//CAS改变许可数量成功，返回true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">next</span> &lt; current) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum permit count exceeded\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(current, <span class=\"keyword\">next</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一旦CAS改变许可数量成功，那么就会调用doReleaseShared()方法释放阻塞的线程。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head)                   <span class=\"comment\">// loop if head changed</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看许可数量\"><a href=\"#查看许可数量\" class=\"headerlink\" title=\"查看许可数量\"></a>查看许可数量</h3><p>可以通过availablePermits()查看可用许可数量，用于判断是否还有许可可以使用。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">availablePermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">return</span> sync.<span class=\"title\">getPermits</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了availablePermits()方法，Semaphore还可以一次将剩余的许可数量全部取走，那就是drainPermits()方法。<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">drainPermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">return</span> sync.<span class=\"title\">drainPermits</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用了Sync类的实现：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">drainPermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前许可数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">        <span class=\"comment\">//许可数量为0直接返回0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"number\">0</span> || compareAndSetState(current, <span class=\"number\">0</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Semaphore就是用于管理许可的信号量，其内部是基于AQS的共享模式，AQS的状态表示许可证的数量，在许可证数量不够时，线程将会被挂起；而一旦有一个线程释放一个资源，那么就有可能重新唤醒等待队列中的线程继续执行。所以应用场景中需要限制获取某种资源的线程数量的时候往往使用Semaphore。</p>"},{"title":"java线程池的使用与区别解析","date":"2018-11-14T13:48:01.000Z","toc":true,"_content":"java 多线程编程使用线程如果只是一味的new Thread()创建新线程，不仅不会提高程序执行性能，反而会因为过多的占用资源或者内存空间导致死机，所以针对这种情况引进了线程池的概念。\n\n### java 线程池\n[线程池](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E6%B1%A0/4745661?fr=aladdin)是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。简单来说线程池就是用来创建管理线程的。线程池可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。同时通过重用存在的线程，可以减少线程创建、销毁的开销，提高性能。而且线程池还提供定时执行、定期执行、单线程、并发数控制等功能，使得线程应用场景更加丰富。\n\n<!--more-->\n\n### 线程池的分类\nJava 提供了四种线程池使用：\n+ newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程\n+ newFixedThreadPool 创建一个指定线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待\n+ newScheduledThreadPool 创建一个指定线程数量的线程池，支持定时及周期性任务执行\n+ newSingleThreadExecutor 创建一个单线程化的线程池，单线程执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\n\n### 线程池创建示例\n\n\n##### newCachedThreadPool\n```\nExecutorService cachedThreadPool = Executors.newCachedThreadPool();\n\nSystem.out.println(\"创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程\");\n\nfor (int i = 0; i < 10; i++) {\n    try {\n        //线程休眠\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    cachedThreadPool.execute(new Runnable() {\n        @Override\n        public void run() {\n            //打印当前时间\n            System.out.println(new Date().toString());\n        }\n    });\n}\n\n//关闭线程池，释放资源\ncachedThreadPool.shutdown();\n```\n\n##### newFixedThreadPool\n```\n//指定线程数量为3\nExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);\n\nSystem.out.println(\"创建一个指定线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待\");\n\nfor (int i = 0; i < 10; i++) {\n\n    //执行线程\n    fixedThreadPool.execute(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                //打印当前时间\n                System.out.println(new Date().toString());\n                //休眠线程\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    });\n}\n//关闭线程池，释放资源\nfixedThreadPool.shutdown();\n```\n\n##### newScheduledThreadPool\n```\nScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);\n\nSystem.out.println(\"创建一个指定线程数量的线程池，支持定时及周期性任务执行\");\n\n//延迟3秒执行\nscheduledThreadPool.schedule(new Runnable() {\n\n    @Override\n    public void run() {\n        System.out.println(\"延迟3秒 \" + new Date().toString());\n    }\n}, 3, TimeUnit.SECONDS);\n\n//延迟1秒后每3秒执行一次\nscheduledThreadPool.scheduleAtFixedRate(new Runnable() {\n\n    @Override\n    public void run() {\n        System.out.println(\"延迟1秒，每3秒执行1次 \" + new Date().toString());\n    }\n}, 1, 3, TimeUnit.SECONDS);\n```\n\n##### newSingleThreadExecutor\n```\nExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();\n\nSystem.out.println(\"创建一个单线程化的线程池，单线程执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\");\n\nfor (int i = 0; i < 10; i++) {\n\nsingleThreadExecutor.execute(new Runnable() {\n\n    @Override\n    public void run() {\n        try {\n            //打印当前日期\n            System.out.println(new Date().toString());\n            //休眠一秒\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n});\n}\n\n//关闭线程池，释放资源\nsingleThreadExecutor.shutdown();\n```\n\n### 线程池的作用\n线程池的作用就是限制系统创建线程的数量，并对线程进行统一管理。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；减少了系统资源的浪费，充分提高程序运行性能。用线程池控制线程数量，线程创建后处于等待，程序执行线程启动后如果有空余线程而之间使用，没有空余先后才能则进入等待队列，知道有可用的线程资源释放。这样充分的利用了系统资源，同时保证了并发性能。\n\n线程池相关的几个重要类：\n\n| 接口 | 实现类 |\n| :------ | :------ |\n|ExecutorService |  ThreadPoolExecutor|\n|ScheduledExecutorService | ScheduledThreadPoolExecutor|\nJava里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService,无论创建那种线程池 必须要调用ThreadPoolExecutor。\n\n### ThreadPoolExecutor\n\nThreadPoolExecutor构造函数：\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          RejectedExecutionHandler handler) {\n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n         Executors.defaultThreadFactory(), handler);\n}\n```\n* corePoolSize： 线程池维护线程的最少数量 \n* maximumPoolSize：线程池维护线程的最大数量 \n* keepAliveTime： 线程池维护线程所允许的空闲时间 \n* unit： 线程池维护线程所允许的空闲时间的单位 \n + java.util.concurrent.TimeUnit中的几个静态属性：\n   * NANOSECONDS、MICROSECONDS、MILLISECONDS、SECOND\n* workQueue： 线程池所使用的缓冲队列 \n* handler： 线程池对拒绝任务的处理策略 \n + ThreadPoolExecutor.AbortPolicy() 抛出java.util.concurrent.RejectedExecutionException异常 \n + ThreadPoolExecutor.CallerRunsPolicy() 重试添加当前的任务，他会自动重复调用execute()方法 \n + ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务\n + ThreadPoolExecutor.DiscardPolicy() 抛弃当前的任务 \n + 根据使用场景实现RejectedExecutionHandler接口，自定义饱和策略\n \n### 线程池执行过程\n不管是那种线程池，大体的执行过程都可以分为下面三步进行，具体线程池略有不同。\n1.如果当前工作中的线程数量少于corePool的数量，就创建一个新的线程来执行任务。\n2.当线程池的工作中的线程数量达到了corePool，则将任务加入队列中。\n3.线程执行完1中的任务后会从队列中去任务。\n\n![线程池执行过程](/assets/img/threadPoolExcute.png)\n\n**FixedThreadPool：** 队列为LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n**SingleThreadExecutor：** SingleThreadExecutor的corePoolSize和maxiumPoolSize都被设置1。其他参数均与FixedThreadPool相同,由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行\n```\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n ```\n \n**CachedThreadPool：** CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源\n ```\npublic static ExecutorService newCachedThreadPool() {\n     return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                   60L, TimeUnit.SECONDS,\n                                   new SynchronousQueue<Runnable>());\n }\n ```\n \n### 阻塞队列\n+ ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列\n+ LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列\n+ PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列\n+ DelayQueue：一个使用优先级队列实现的无界阻塞队列\n+ SynchronousQueue：一个不存储元素的阻塞队列\n+ LinkedTransferQueue：一个由链表结构组成的无界阻塞队列\n+ LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列","source":"_posts/2018-11-14-java线程池的使用与区别解析.md","raw":"---\ntitle: java线程池的使用与区别解析\ndate: 2018-11-14 21:48:01\ntoc: true\ntags:\n    - java\n    - 多线程\n    - 线程池\n---\njava 多线程编程使用线程如果只是一味的new Thread()创建新线程，不仅不会提高程序执行性能，反而会因为过多的占用资源或者内存空间导致死机，所以针对这种情况引进了线程池的概念。\n\n### java 线程池\n[线程池](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E6%B1%A0/4745661?fr=aladdin)是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。简单来说线程池就是用来创建管理线程的。线程池可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。同时通过重用存在的线程，可以减少线程创建、销毁的开销，提高性能。而且线程池还提供定时执行、定期执行、单线程、并发数控制等功能，使得线程应用场景更加丰富。\n\n<!--more-->\n\n### 线程池的分类\nJava 提供了四种线程池使用：\n+ newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程\n+ newFixedThreadPool 创建一个指定线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待\n+ newScheduledThreadPool 创建一个指定线程数量的线程池，支持定时及周期性任务执行\n+ newSingleThreadExecutor 创建一个单线程化的线程池，单线程执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\n\n### 线程池创建示例\n\n\n##### newCachedThreadPool\n```\nExecutorService cachedThreadPool = Executors.newCachedThreadPool();\n\nSystem.out.println(\"创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程\");\n\nfor (int i = 0; i < 10; i++) {\n    try {\n        //线程休眠\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    cachedThreadPool.execute(new Runnable() {\n        @Override\n        public void run() {\n            //打印当前时间\n            System.out.println(new Date().toString());\n        }\n    });\n}\n\n//关闭线程池，释放资源\ncachedThreadPool.shutdown();\n```\n\n##### newFixedThreadPool\n```\n//指定线程数量为3\nExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);\n\nSystem.out.println(\"创建一个指定线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待\");\n\nfor (int i = 0; i < 10; i++) {\n\n    //执行线程\n    fixedThreadPool.execute(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                //打印当前时间\n                System.out.println(new Date().toString());\n                //休眠线程\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    });\n}\n//关闭线程池，释放资源\nfixedThreadPool.shutdown();\n```\n\n##### newScheduledThreadPool\n```\nScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);\n\nSystem.out.println(\"创建一个指定线程数量的线程池，支持定时及周期性任务执行\");\n\n//延迟3秒执行\nscheduledThreadPool.schedule(new Runnable() {\n\n    @Override\n    public void run() {\n        System.out.println(\"延迟3秒 \" + new Date().toString());\n    }\n}, 3, TimeUnit.SECONDS);\n\n//延迟1秒后每3秒执行一次\nscheduledThreadPool.scheduleAtFixedRate(new Runnable() {\n\n    @Override\n    public void run() {\n        System.out.println(\"延迟1秒，每3秒执行1次 \" + new Date().toString());\n    }\n}, 1, 3, TimeUnit.SECONDS);\n```\n\n##### newSingleThreadExecutor\n```\nExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();\n\nSystem.out.println(\"创建一个单线程化的线程池，单线程执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\");\n\nfor (int i = 0; i < 10; i++) {\n\nsingleThreadExecutor.execute(new Runnable() {\n\n    @Override\n    public void run() {\n        try {\n            //打印当前日期\n            System.out.println(new Date().toString());\n            //休眠一秒\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n});\n}\n\n//关闭线程池，释放资源\nsingleThreadExecutor.shutdown();\n```\n\n### 线程池的作用\n线程池的作用就是限制系统创建线程的数量，并对线程进行统一管理。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；减少了系统资源的浪费，充分提高程序运行性能。用线程池控制线程数量，线程创建后处于等待，程序执行线程启动后如果有空余线程而之间使用，没有空余先后才能则进入等待队列，知道有可用的线程资源释放。这样充分的利用了系统资源，同时保证了并发性能。\n\n线程池相关的几个重要类：\n\n| 接口 | 实现类 |\n| :------ | :------ |\n|ExecutorService |  ThreadPoolExecutor|\n|ScheduledExecutorService | ScheduledThreadPoolExecutor|\nJava里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService,无论创建那种线程池 必须要调用ThreadPoolExecutor。\n\n### ThreadPoolExecutor\n\nThreadPoolExecutor构造函数：\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          RejectedExecutionHandler handler) {\n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n         Executors.defaultThreadFactory(), handler);\n}\n```\n* corePoolSize： 线程池维护线程的最少数量 \n* maximumPoolSize：线程池维护线程的最大数量 \n* keepAliveTime： 线程池维护线程所允许的空闲时间 \n* unit： 线程池维护线程所允许的空闲时间的单位 \n + java.util.concurrent.TimeUnit中的几个静态属性：\n   * NANOSECONDS、MICROSECONDS、MILLISECONDS、SECOND\n* workQueue： 线程池所使用的缓冲队列 \n* handler： 线程池对拒绝任务的处理策略 \n + ThreadPoolExecutor.AbortPolicy() 抛出java.util.concurrent.RejectedExecutionException异常 \n + ThreadPoolExecutor.CallerRunsPolicy() 重试添加当前的任务，他会自动重复调用execute()方法 \n + ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务\n + ThreadPoolExecutor.DiscardPolicy() 抛弃当前的任务 \n + 根据使用场景实现RejectedExecutionHandler接口，自定义饱和策略\n \n### 线程池执行过程\n不管是那种线程池，大体的执行过程都可以分为下面三步进行，具体线程池略有不同。\n1.如果当前工作中的线程数量少于corePool的数量，就创建一个新的线程来执行任务。\n2.当线程池的工作中的线程数量达到了corePool，则将任务加入队列中。\n3.线程执行完1中的任务后会从队列中去任务。\n\n![线程池执行过程](/assets/img/threadPoolExcute.png)\n\n**FixedThreadPool：** 队列为LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n**SingleThreadExecutor：** SingleThreadExecutor的corePoolSize和maxiumPoolSize都被设置1。其他参数均与FixedThreadPool相同,由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行\n```\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n ```\n \n**CachedThreadPool：** CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源\n ```\npublic static ExecutorService newCachedThreadPool() {\n     return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                   60L, TimeUnit.SECONDS,\n                                   new SynchronousQueue<Runnable>());\n }\n ```\n \n### 阻塞队列\n+ ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列\n+ LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列\n+ PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列\n+ DelayQueue：一个使用优先级队列实现的无界阻塞队列\n+ SynchronousQueue：一个不存储元素的阻塞队列\n+ LinkedTransferQueue：一个由链表结构组成的无界阻塞队列\n+ LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列","slug":"java线程池的使用与区别解析","published":1,"updated":"2018-11-16T14:33:48.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpshgvjm0018ogre4b3ww9xv","content":"<p>java 多线程编程使用线程如果只是一味的new Thread()创建新线程，不仅不会提高程序执行性能，反而会因为过多的占用资源或者内存空间导致死机，所以针对这种情况引进了线程池的概念。</p>\n<h3 id=\"java-线程池\"><a href=\"#java-线程池\" class=\"headerlink\" title=\"java 线程池\"></a>java 线程池</h3><p><a href=\"https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E6%B1%A0/4745661?fr=aladdin\" target=\"_blank\" rel=\"noopener\">线程池</a>是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。简单来说线程池就是用来创建管理线程的。线程池可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。同时通过重用存在的线程，可以减少线程创建、销毁的开销，提高性能。而且线程池还提供定时执行、定期执行、单线程、并发数控制等功能，使得线程应用场景更加丰富。</p>\n<a id=\"more\"></a>\n<h3 id=\"线程池的分类\"><a href=\"#线程池的分类\" class=\"headerlink\" title=\"线程池的分类\"></a>线程池的分类</h3><p>Java 提供了四种线程池使用：</p>\n<ul>\n<li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>\n<li>newFixedThreadPool 创建一个指定线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待</li>\n<li>newScheduledThreadPool 创建一个指定线程数量的线程池，支持定时及周期性任务执行</li>\n<li>newSingleThreadExecutor 创建一个单线程化的线程池，单线程执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>\n</ul>\n<h3 id=\"线程池创建示例\"><a href=\"#线程池创建示例\" class=\"headerlink\" title=\"线程池创建示例\"></a>线程池创建示例</h3><h5 id=\"newCachedThreadPool\"><a href=\"#newCachedThreadPool\" class=\"headerlink\" title=\"newCachedThreadPool\"></a>newCachedThreadPool</h5><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//线程休眠</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cachedThreadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">            <span class=\"comment\">//打印当前时间</span></span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//关闭线程池，释放资源</span></span><br><span class=\"line\">cachedThreadPool.<span class=\"built_in\">shutdown</span>();</span><br></pre></td></tr></table></figure>\n<h5 id=\"newFixedThreadPool\"><a href=\"#newFixedThreadPool\" class=\"headerlink\" title=\"newFixedThreadPool\"></a>newFixedThreadPool</h5><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//指定线程数量为3</span></span><br><span class=\"line\">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"创建一个指定线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行线程</span></span><br><span class=\"line\">    fixedThreadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//打印当前时间</span></span><br><span class=\"line\">                System.out.<span class=\"built_in\">println</span>(<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">                <span class=\"comment\">//休眠线程</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"built_in\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//关闭线程池，释放资源</span></span><br><span class=\"line\">fixedThreadPool.<span class=\"built_in\">shutdown</span>();</span><br></pre></td></tr></table></figure>\n<h5 id=\"newScheduledThreadPool\"><a href=\"#newScheduledThreadPool\" class=\"headerlink\" title=\"newScheduledThreadPool\"></a>newScheduledThreadPool</h5><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"创建一个指定线程数量的线程池，支持定时及周期性任务执行\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//延迟3秒执行</span></span><br><span class=\"line\">scheduledThreadPool.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"延迟3秒 \"</span> + <span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//延迟1秒后每3秒执行一次</span></span><br><span class=\"line\">scheduledThreadPool.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"延迟1秒，每3秒执行1次 \"</span> + <span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n<h5 id=\"newSingleThreadExecutor\"><a href=\"#newSingleThreadExecutor\" class=\"headerlink\" title=\"newSingleThreadExecutor\"></a>newSingleThreadExecutor</h5><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"创建一个单线程化的线程池，单线程执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">singleThreadExecutor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//打印当前日期</span></span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">            <span class=\"comment\">//休眠一秒</span></span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"built_in\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//关闭线程池，释放资源</span></span><br><span class=\"line\">singleThreadExecutor.<span class=\"built_in\">shutdown</span>();</span><br></pre></td></tr></table></figure>\n<h3 id=\"线程池的作用\"><a href=\"#线程池的作用\" class=\"headerlink\" title=\"线程池的作用\"></a>线程池的作用</h3><p>线程池的作用就是限制系统创建线程的数量，并对线程进行统一管理。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；减少了系统资源的浪费，充分提高程序运行性能。用线程池控制线程数量，线程创建后处于等待，程序执行线程启动后如果有空余线程而之间使用，没有空余先后才能则进入等待队列，知道有可用的线程资源释放。这样充分的利用了系统资源，同时保证了并发性能。</p>\n<p>线程池相关的几个重要类：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口</th>\n<th style=\"text-align:left\">实现类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ExecutorService</td>\n<td style=\"text-align:left\">ThreadPoolExecutor</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ScheduledExecutorService</td>\n<td style=\"text-align:left\">ScheduledThreadPoolExecutor</td>\n</tr>\n</tbody>\n</table>\n<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService,无论创建那种线程池 必须要调用ThreadPoolExecutor。</p>\n<h3 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor构造函数：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ThreadPoolExecutor(<span class=\"keyword\">int</span> corePoolSize,</span><br><span class=\"line\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span><br><span class=\"line\">                          <span class=\"keyword\">long</span> keepAliveTime,</span><br><span class=\"line\">                          TimeUnit unit,</span><br><span class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                          RejectedExecutionHandler <span class=\"keyword\">handler</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class=\"line\">         Executors.defaultThreadFactory(), <span class=\"keyword\">handler</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>corePoolSize： 线程池维护线程的最少数量 </li>\n<li>maximumPoolSize：线程池维护线程的最大数量 </li>\n<li>keepAliveTime： 线程池维护线程所允许的空闲时间 </li>\n<li>unit： 线程池维护线程所允许的空闲时间的单位 <ul>\n<li>java.util.concurrent.TimeUnit中的几个静态属性：<ul>\n<li>NANOSECONDS、MICROSECONDS、MILLISECONDS、SECOND</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>workQueue： 线程池所使用的缓冲队列 </li>\n<li>handler： 线程池对拒绝任务的处理策略 <ul>\n<li>ThreadPoolExecutor.AbortPolicy() 抛出java.util.concurrent.RejectedExecutionException异常 </li>\n<li>ThreadPoolExecutor.CallerRunsPolicy() 重试添加当前的任务，他会自动重复调用execute()方法 </li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务</li>\n<li>ThreadPoolExecutor.DiscardPolicy() 抛弃当前的任务 </li>\n<li>根据使用场景实现RejectedExecutionHandler接口，自定义饱和策略</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程池执行过程\"><a href=\"#线程池执行过程\" class=\"headerlink\" title=\"线程池执行过程\"></a>线程池执行过程</h3><p>不管是那种线程池，大体的执行过程都可以分为下面三步进行，具体线程池略有不同。<br>1.如果当前工作中的线程数量少于corePool的数量，就创建一个新的线程来执行任务。<br>2.当线程池的工作中的线程数量达到了corePool，则将任务加入队列中。<br>3.线程执行完1中的任务后会从队列中去任务。</p>\n<p><img src=\"/assets/img/threadPoolExcute.png\" alt=\"线程池执行过程\"></p>\n<p><strong>FixedThreadPool：</strong> 队列为LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"keyword\">new</span><span class=\"type\">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"type\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>SingleThreadExecutor：</strong> SingleThreadExecutor的corePoolSize和maxiumPoolSize都被设置1。其他参数均与FixedThreadPool相同,由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"keyword\">new</span><span class=\"type\">SingleThreadExecutor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\"><span class=\"type\"></span>        (<span class=\"keyword\">new</span> <span class=\"type\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"type\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>CachedThreadPool：</strong> CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源<br> <figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"keyword\">new</span><span class=\"type\">CachedThreadPool</span>() &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                   <span class=\"number\">60</span>L, TimeUnit.SECONDS,</span><br><span class=\"line\">                                   <span class=\"keyword\">new</span> <span class=\"type\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h3><ul>\n<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li>\n<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>\n<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>\n<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li>\n<li>SynchronousQueue：一个不存储元素的阻塞队列</li>\n<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>\n<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>java 多线程编程使用线程如果只是一味的new Thread()创建新线程，不仅不会提高程序执行性能，反而会因为过多的占用资源或者内存空间导致死机，所以针对这种情况引进了线程池的概念。</p>\n<h3 id=\"java-线程池\"><a href=\"#java-线程池\" class=\"headerlink\" title=\"java 线程池\"></a>java 线程池</h3><p><a href=\"https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E6%B1%A0/4745661?fr=aladdin\" target=\"_blank\" rel=\"noopener\">线程池</a>是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。简单来说线程池就是用来创建管理线程的。线程池可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。同时通过重用存在的线程，可以减少线程创建、销毁的开销，提高性能。而且线程池还提供定时执行、定期执行、单线程、并发数控制等功能，使得线程应用场景更加丰富。</p>","more":"<h3 id=\"线程池的分类\"><a href=\"#线程池的分类\" class=\"headerlink\" title=\"线程池的分类\"></a>线程池的分类</h3><p>Java 提供了四种线程池使用：</p>\n<ul>\n<li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>\n<li>newFixedThreadPool 创建一个指定线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待</li>\n<li>newScheduledThreadPool 创建一个指定线程数量的线程池，支持定时及周期性任务执行</li>\n<li>newSingleThreadExecutor 创建一个单线程化的线程池，单线程执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>\n</ul>\n<h3 id=\"线程池创建示例\"><a href=\"#线程池创建示例\" class=\"headerlink\" title=\"线程池创建示例\"></a>线程池创建示例</h3><h5 id=\"newCachedThreadPool\"><a href=\"#newCachedThreadPool\" class=\"headerlink\" title=\"newCachedThreadPool\"></a>newCachedThreadPool</h5><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//线程休眠</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cachedThreadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">            <span class=\"comment\">//打印当前时间</span></span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//关闭线程池，释放资源</span></span><br><span class=\"line\">cachedThreadPool.<span class=\"built_in\">shutdown</span>();</span><br></pre></td></tr></table></figure>\n<h5 id=\"newFixedThreadPool\"><a href=\"#newFixedThreadPool\" class=\"headerlink\" title=\"newFixedThreadPool\"></a>newFixedThreadPool</h5><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//指定线程数量为3</span></span><br><span class=\"line\">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"创建一个指定线程数量的线程池，可控制线程最大并发数，超出的线程会在队列中等待\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//执行线程</span></span><br><span class=\"line\">    fixedThreadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//打印当前时间</span></span><br><span class=\"line\">                System.out.<span class=\"built_in\">println</span>(<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">                <span class=\"comment\">//休眠线程</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"built_in\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//关闭线程池，释放资源</span></span><br><span class=\"line\">fixedThreadPool.<span class=\"built_in\">shutdown</span>();</span><br></pre></td></tr></table></figure>\n<h5 id=\"newScheduledThreadPool\"><a href=\"#newScheduledThreadPool\" class=\"headerlink\" title=\"newScheduledThreadPool\"></a>newScheduledThreadPool</h5><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"创建一个指定线程数量的线程池，支持定时及周期性任务执行\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//延迟3秒执行</span></span><br><span class=\"line\">scheduledThreadPool.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"延迟3秒 \"</span> + <span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//延迟1秒后每3秒执行一次</span></span><br><span class=\"line\">scheduledThreadPool.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"延迟1秒，每3秒执行1次 \"</span> + <span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n<h5 id=\"newSingleThreadExecutor\"><a href=\"#newSingleThreadExecutor\" class=\"headerlink\" title=\"newSingleThreadExecutor\"></a>newSingleThreadExecutor</h5><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"创建一个单线程化的线程池，单线程执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">singleThreadExecutor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//打印当前日期</span></span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">            <span class=\"comment\">//休眠一秒</span></span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"built_in\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//关闭线程池，释放资源</span></span><br><span class=\"line\">singleThreadExecutor.<span class=\"built_in\">shutdown</span>();</span><br></pre></td></tr></table></figure>\n<h3 id=\"线程池的作用\"><a href=\"#线程池的作用\" class=\"headerlink\" title=\"线程池的作用\"></a>线程池的作用</h3><p>线程池的作用就是限制系统创建线程的数量，并对线程进行统一管理。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；减少了系统资源的浪费，充分提高程序运行性能。用线程池控制线程数量，线程创建后处于等待，程序执行线程启动后如果有空余线程而之间使用，没有空余先后才能则进入等待队列，知道有可用的线程资源释放。这样充分的利用了系统资源，同时保证了并发性能。</p>\n<p>线程池相关的几个重要类：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口</th>\n<th style=\"text-align:left\">实现类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ExecutorService</td>\n<td style=\"text-align:left\">ThreadPoolExecutor</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ScheduledExecutorService</td>\n<td style=\"text-align:left\">ScheduledThreadPoolExecutor</td>\n</tr>\n</tbody>\n</table>\n<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService,无论创建那种线程池 必须要调用ThreadPoolExecutor。</p>\n<h3 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h3><p>ThreadPoolExecutor构造函数：<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ThreadPoolExecutor(<span class=\"keyword\">int</span> corePoolSize,</span><br><span class=\"line\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span><br><span class=\"line\">                          <span class=\"keyword\">long</span> keepAliveTime,</span><br><span class=\"line\">                          TimeUnit unit,</span><br><span class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                          RejectedExecutionHandler <span class=\"keyword\">handler</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class=\"line\">         Executors.defaultThreadFactory(), <span class=\"keyword\">handler</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>corePoolSize： 线程池维护线程的最少数量 </li>\n<li>maximumPoolSize：线程池维护线程的最大数量 </li>\n<li>keepAliveTime： 线程池维护线程所允许的空闲时间 </li>\n<li>unit： 线程池维护线程所允许的空闲时间的单位 <ul>\n<li>java.util.concurrent.TimeUnit中的几个静态属性：<ul>\n<li>NANOSECONDS、MICROSECONDS、MILLISECONDS、SECOND</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>workQueue： 线程池所使用的缓冲队列 </li>\n<li>handler： 线程池对拒绝任务的处理策略 <ul>\n<li>ThreadPoolExecutor.AbortPolicy() 抛出java.util.concurrent.RejectedExecutionException异常 </li>\n<li>ThreadPoolExecutor.CallerRunsPolicy() 重试添加当前的任务，他会自动重复调用execute()方法 </li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务</li>\n<li>ThreadPoolExecutor.DiscardPolicy() 抛弃当前的任务 </li>\n<li>根据使用场景实现RejectedExecutionHandler接口，自定义饱和策略</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程池执行过程\"><a href=\"#线程池执行过程\" class=\"headerlink\" title=\"线程池执行过程\"></a>线程池执行过程</h3><p>不管是那种线程池，大体的执行过程都可以分为下面三步进行，具体线程池略有不同。<br>1.如果当前工作中的线程数量少于corePool的数量，就创建一个新的线程来执行任务。<br>2.当线程池的工作中的线程数量达到了corePool，则将任务加入队列中。<br>3.线程执行完1中的任务后会从队列中去任务。</p>\n<p><img src=\"/assets/img/threadPoolExcute.png\" alt=\"线程池执行过程\"></p>\n<p><strong>FixedThreadPool：</strong> 队列为LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"keyword\">new</span><span class=\"type\">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"type\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>SingleThreadExecutor：</strong> SingleThreadExecutor的corePoolSize和maxiumPoolSize都被设置1。其他参数均与FixedThreadPool相同,由于在线程池中只有一个工作线程，所以任务可以按照添加顺序执行<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"keyword\">new</span><span class=\"type\">SingleThreadExecutor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\"><span class=\"type\"></span>        (<span class=\"keyword\">new</span> <span class=\"type\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"type\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>CachedThreadPool：</strong> CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源<br> <figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"keyword\">new</span><span class=\"type\">CachedThreadPool</span>() &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                   <span class=\"number\">60</span>L, TimeUnit.SECONDS,</span><br><span class=\"line\">                                   <span class=\"keyword\">new</span> <span class=\"type\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h3><ul>\n<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li>\n<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>\n<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>\n<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li>\n<li>SynchronousQueue：一个不存储元素的阻塞队列</li>\n<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>\n<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjpshgvim0007ogre1c01u6sd","category_id":"cjpshgviq0009ogre8grsfoqy","_id":"cjpshgvit000eogre1688dwgi"}],"PostTag":[{"post_id":"cjpshgvi00000ogre5v8y2j2f","tag_id":"cjpshgvid0002ogre5q4kxvj7","_id":"cjpshgvis000bogreuho70bed"},{"post_id":"cjpshgvi00000ogre5v8y2j2f","tag_id":"cjpshgvil0006ogreqbqdwxig","_id":"cjpshgvis000cogreekwpm508"},{"post_id":"cjpshgvi00000ogre5v8y2j2f","tag_id":"cjpshgvio0008ogrew99ay69t","_id":"cjpshgvit000fogrelxvts70n"},{"post_id":"cjpshgvi90001ogre6po0nehb","tag_id":"cjpshgvir000aogrejukih1xg","_id":"cjpshgvix000hogreoezms2md"},{"post_id":"cjpshgvi90001ogre6po0nehb","tag_id":"cjpshgvit000dogre9ifjc8mk","_id":"cjpshgvix000iogre3v97hgdv"},{"post_id":"cjpshgvig0003ogreqzl90vjm","tag_id":"cjpshgvir000aogrejukih1xg","_id":"cjpshgviz000mogre4us4l9yp"},{"post_id":"cjpshgvig0003ogreqzl90vjm","tag_id":"cjpshgvix000jogrev5sva8sd","_id":"cjpshgvj0000nogredgrlka2v"},{"post_id":"cjpshgvig0003ogreqzl90vjm","tag_id":"cjpshgviy000kogre4qbck83p","_id":"cjpshgvj0000pogre96k786w1"},{"post_id":"cjpshgvii0004ogrek8c5w31w","tag_id":"cjpshgviz000logre38jacijn","_id":"cjpshgvj1000rogregncnkr0a"},{"post_id":"cjpshgvii0004ogrek8c5w31w","tag_id":"cjpshgvj0000oogrememppoze","_id":"cjpshgvj1000sogreh7sr5mpe"},{"post_id":"cjpshgvik0005ogrehmufhgch","tag_id":"cjpshgvj0000qogre4pagdyfj","_id":"cjpshgvj2000wogregrt6p9uz"},{"post_id":"cjpshgvik0005ogrehmufhgch","tag_id":"cjpshgvj1000togregpm6z20h","_id":"cjpshgvj2000xogre0zwlaaos"},{"post_id":"cjpshgvik0005ogrehmufhgch","tag_id":"cjpshgvj1000uogreuoz9kydi","_id":"cjpshgvj2000yogrefadmw8ln"},{"post_id":"cjpshgvim0007ogre1c01u6sd","tag_id":"cjpshgvj2000vogresfvigoo0","_id":"cjpshgvj2000zogreyg5gnhte"},{"post_id":"cjpshgvj80010ogre6s296zuw","tag_id":"cjpshgvje0012ogreg1rjeu92","_id":"cjpshgvjm0017ogre1rcs7tsm"},{"post_id":"cjpshgvj80010ogre6s296zuw","tag_id":"cjpshgvil0006ogreqbqdwxig","_id":"cjpshgvjo0019ogrey2qb1stl"},{"post_id":"cjpshgvjb0011ogreeucqqosy","tag_id":"cjpshgvir000aogrejukih1xg","_id":"cjpshgvjo001bogrev9fvek6y"},{"post_id":"cjpshgvjb0011ogreeucqqosy","tag_id":"cjpshgvil0006ogreqbqdwxig","_id":"cjpshgvjo001cogre2kxug5qv"},{"post_id":"cjpshgvjb0011ogreeucqqosy","tag_id":"cjpshgvjm0016ogreg743f0ns","_id":"cjpshgvjp001eogre4anb2bov"},{"post_id":"cjpshgvje0013ogreyzsuu8v5","tag_id":"cjpshgvir000aogrejukih1xg","_id":"cjpshgvjp001fogre7sz83j9s"},{"post_id":"cjpshgvje0013ogreyzsuu8v5","tag_id":"cjpshgvil0006ogreqbqdwxig","_id":"cjpshgvjq001hogrevk6lonzj"},{"post_id":"cjpshgvje0013ogreyzsuu8v5","tag_id":"cjpshgvjo001aogreyso1ojde","_id":"cjpshgvjq001iogrecc6pbitf"},{"post_id":"cjpshgvjg0014ogre8p1640jc","tag_id":"cjpshgvj0000qogre4pagdyfj","_id":"cjpshgvjq001kogre604ql23p"},{"post_id":"cjpshgvjg0014ogre8p1640jc","tag_id":"cjpshgvjp001dogre0za1u8yb","_id":"cjpshgvjr001logrefxbd2ntd"},{"post_id":"cjpshgvjg0014ogre8p1640jc","tag_id":"cjpshgvjp001gogrevmo1munb","_id":"cjpshgvjr001nogree38b07pg"},{"post_id":"cjpshgvjk0015ogrec3rin4as","tag_id":"cjpshgvir000aogrejukih1xg","_id":"cjpshgvjs001qogre7ndeuyyo"},{"post_id":"cjpshgvjk0015ogrec3rin4as","tag_id":"cjpshgvjq001jogrejaaz4rrp","_id":"cjpshgvjs001rogremagdqq58"},{"post_id":"cjpshgvjk0015ogrec3rin4as","tag_id":"cjpshgvjr001mogre57mb8tm0","_id":"cjpshgvjt001togrebcd9klzq"},{"post_id":"cjpshgvjk0015ogrec3rin4as","tag_id":"cjpshgvjr001oogreygaoj6j4","_id":"cjpshgvjt001uogrenq7tb07x"},{"post_id":"cjpshgvjm0018ogre4b3ww9xv","tag_id":"cjpshgvir000aogrejukih1xg","_id":"cjpshgvjt001vogregkmf6b02"},{"post_id":"cjpshgvjm0018ogre4b3ww9xv","tag_id":"cjpshgvjq001jogrejaaz4rrp","_id":"cjpshgvju001wogrecjyto97r"},{"post_id":"cjpshgvjm0018ogre4b3ww9xv","tag_id":"cjpshgvjt001sogre2jsucxyf","_id":"cjpshgvju001xogrejq3rsrzr"}],"Tag":[{"name":"hexo","_id":"cjpshgvid0002ogre5q4kxvj7"},{"name":"blog","_id":"cjpshgvil0006ogreqbqdwxig"},{"name":"github","_id":"cjpshgvio0008ogrew99ay69t"},{"name":"java","_id":"cjpshgvir000aogrejukih1xg"},{"name":"创建过程","_id":"cjpshgvit000dogre9ifjc8mk"},{"name":"Overriding","_id":"cjpshgvix000jogrev5sva8sd"},{"name":"Overloading","_id":"cjpshgviy000kogre4qbck83p"},{"name":"markdown","_id":"cjpshgviz000logre38jacijn"},{"name":"basic","_id":"cjpshgvj0000oogrememppoze"},{"name":"集合","_id":"cjpshgvj0000qogre4pagdyfj"},{"name":"HashMap","_id":"cjpshgvj1000togregpm6z20h"},{"name":"Hashtable","_id":"cjpshgvj1000uogreuoz9kydi"},{"name":"demo","_id":"cjpshgvj2000vogresfvigoo0"},{"name":"String","_id":"cjpshgvje0012ogreg1rjeu92"},{"name":"内存分配","_id":"cjpshgvjm0016ogreg743f0ns"},{"name":"GC","_id":"cjpshgvjo001aogreyso1ojde"},{"name":"ArrayList","_id":"cjpshgvjp001dogre0za1u8yb"},{"name":"LinkedList","_id":"cjpshgvjp001gogrevmo1munb"},{"name":"多线程","_id":"cjpshgvjq001jogrejaaz4rrp"},{"name":"Semaphore","_id":"cjpshgvjr001mogre57mb8tm0"},{"name":"源码","_id":"cjpshgvjr001oogreygaoj6j4"},{"name":"线程池","_id":"cjpshgvjt001sogre2jsucxyf"}]}}